// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// AnchorBlocksBlockHashWitness is an auto generated low-level Go binding around an user-defined struct.
type AnchorBlocksBlockHashWitness struct {
	Left  []byte
	Right []byte
}

// BeaconBlockHeader is an auto generated low-level Go binding around an user-defined struct.
type BeaconBlockHeader struct {
	Slot          uint64
	ProposerIndex uint64
	ParentRoot    [32]byte
	StateRoot     [32]byte
	BodyRoot      [32]byte
}

// BrevisProofData is an auto generated low-level Go binding around an user-defined struct.
type BrevisProofData struct {
	CommitHash    [32]byte
	VkHash        [32]byte
	AppCommitHash [32]byte
	AppVkHash     [32]byte
	SmtRoot       [32]byte
}

// ExecutionPayload is an auto generated low-level Go binding around an user-defined struct.
type ExecutionPayload struct {
	StateRoot   LeafWithBranch
	BlockHash   LeafWithBranch
	BlockNumber LeafWithBranch
}

// HeaderWithExecution is an auto generated low-level Go binding around an user-defined struct.
type HeaderWithExecution struct {
	Beacon        BeaconBlockHeader
	Execution     ExecutionPayload
	ExecutionRoot LeafWithBranch
}

// HooksCalls is an auto generated low-level Go binding around an user-defined struct.
type HooksCalls struct {
	BeforeInitialize     bool
	AfterInitialize      bool
	BeforeModifyPosition bool
	AfterModifyPosition  bool
	BeforeSwap           bool
	AfterSwap            bool
	BeforeDonate         bool
	AfterDonate          bool
}

// IBeaconVerifierProof is an auto generated low-level Go binding around an user-defined struct.
type IBeaconVerifierProof struct {
	A          [2]*big.Int
	B          [2][2]*big.Int
	C          [2]*big.Int
	Commitment [2]*big.Int
}

// IBlockChunksBlockHashWitness is an auto generated low-level Go binding around an user-defined struct.
type IBlockChunksBlockHashWitness struct {
	ChainId        uint64
	BlkNum         uint32
	ClaimedBlkHash [32]byte
	PrevHash       [32]byte
	NumFinal       uint32
	MerkleProof    [7][32]byte
}

// IBrevisRequestCallback is an auto generated low-level Go binding around an user-defined struct.
type IBrevisRequestCallback struct {
	Target common.Address
	Gas    uint64
}

// IBrevisRequestRequestDataHash is an auto generated low-level Go binding around an user-defined struct.
type IBrevisRequestRequestDataHash struct {
	Hashes [][32]byte
	Root   [32]byte
}

// IPoolManagerModifyPositionParams is an auto generated low-level Go binding around an user-defined struct.
type IPoolManagerModifyPositionParams struct {
	TickLower      *big.Int
	TickUpper      *big.Int
	LiquidityDelta *big.Int
}

// IPoolManagerSwapParams is an auto generated low-level Go binding around an user-defined struct.
type IPoolManagerSwapParams struct {
	ZeroForOne        bool
	AmountSpecified   *big.Int
	SqrtPriceLimitX96 *big.Int
}

// IReceiptVerifierLogInfo is an auto generated low-level Go binding around an user-defined struct.
type IReceiptVerifierLogInfo struct {
	Addr   common.Address
	Topics [][32]byte
	Data   []byte
}

// IReceiptVerifierReceiptInfo is an auto generated low-level Go binding around an user-defined struct.
type IReceiptVerifierReceiptInfo struct {
	Success bool
	ChainId uint64
	BlkHash [32]byte
	BlkNum  uint32
	BlkTime uint64
	Logs    []IReceiptVerifierLogInfo
}

// ISMTSmtUpdate is an auto generated low-level Go binding around an user-defined struct.
type ISMTSmtUpdate struct {
	NewSmtRoot          [32]byte
	EndBlockNum         uint64
	EndBlockHash        [32]byte
	NextChunkMerkleRoot [32]byte
	Proof               IVerifierProof
	CommitPub           [32]byte
}

// ISlotValueVerifierSlotInfo is an auto generated low-level Go binding around an user-defined struct.
type ISlotValueVerifierSlotInfo struct {
	ChainId     uint64
	AddrHash    [32]byte
	BlkHash     [32]byte
	SlotKeyHash [32]byte
	SlotValue   [32]byte
	BlkNum      uint32
}

// ITxVerifierTxInfo is an auto generated low-level Go binding around an user-defined struct.
type ITxVerifierTxInfo struct {
	ChainId   uint64
	Nonce     uint64
	GasTipCap *big.Int
	GasFeeCap *big.Int
	Gas       *big.Int
	To        common.Address
	Value     *big.Int
	Data      []byte
	From      common.Address
	BlkNum    uint32
	BlkHash   [32]byte
	BlkTime   uint64
}

// IVerifierProof is an auto generated low-level Go binding around an user-defined struct.
type IVerifierProof struct {
	A          [2]*big.Int
	B          [2][2]*big.Int
	C          [2]*big.Int
	Commitment [2]*big.Int
}

// LeafWithBranch is an auto generated low-level Go binding around an user-defined struct.
type LeafWithBranch struct {
	Leaf   [32]byte
	Branch [][32]byte
}

// LightClientOptimisticUpdate is an auto generated low-level Go binding around an user-defined struct.
type LightClientOptimisticUpdate struct {
	AttestedHeader HeaderWithExecution
	SyncAggregate  SyncAggregate
	SignatureSlot  uint64
}

// LightClientUpdate is an auto generated low-level Go binding around an user-defined struct.
type LightClientUpdate struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	FinalityBranch                    [][32]byte
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteeBranch           [][32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}

// PoolKey is an auto generated low-level Go binding around an user-defined struct.
type PoolKey struct {
	Currency0   common.Address
	Currency1   common.Address
	Fee         *big.Int
	TickSpacing *big.Int
	Hooks       common.Address
}

// PositionInfo is an auto generated low-level Go binding around an user-defined struct.
type PositionInfo struct {
	Liquidity                *big.Int
	FeeGrowthInside0LastX128 *big.Int
	FeeGrowthInside1LastX128 *big.Int
}

// SyncAggregate is an auto generated low-level Go binding around an user-defined struct.
type SyncAggregate struct {
	Participation uint64
	PoseidonRoot  [32]byte
	Commitment    *big.Int
	Proof         IBeaconVerifierProof
}

// TxTxInfo is an auto generated low-level Go binding around an user-defined struct.
type TxTxInfo struct {
	ChainId   uint64
	Nonce     uint64
	GasTipCap *big.Int
	GasFeeCap *big.Int
	Gas       *big.Int
	To        common.Address
	Value     *big.Int
	Data      []byte
	From      common.Address
}

// AddressMetaData contains all meta data concerning the Address contract.
var AddressMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122084316ae7f90ab02dedc5c08bd3c2dea313dd1e29a325b4271a7f1a5bcf89953864736f6c63430008140033",
}

// AddressABI is the input ABI used to generate the binding from.
// Deprecated: Use AddressMetaData.ABI instead.
var AddressABI = AddressMetaData.ABI

// AddressBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AddressMetaData.Bin instead.
var AddressBin = AddressMetaData.Bin

// DeployAddress deploys a new Ethereum contract, binding an instance of Address to it.
func DeployAddress(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Address, error) {
	parsed, err := AddressMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AddressBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// Address is an auto generated Go binding around an Ethereum contract.
type Address struct {
	AddressCaller     // Read-only binding to the contract
	AddressTransactor // Write-only binding to the contract
	AddressFilterer   // Log filterer for contract events
}

// AddressCaller is an auto generated read-only Go binding around an Ethereum contract.
type AddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AddressSession struct {
	Contract     *Address          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AddressCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AddressCallerSession struct {
	Contract *AddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// AddressTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AddressTransactorSession struct {
	Contract     *AddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AddressRaw is an auto generated low-level Go binding around an Ethereum contract.
type AddressRaw struct {
	Contract *Address // Generic contract binding to access the raw methods on
}

// AddressCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AddressCallerRaw struct {
	Contract *AddressCaller // Generic read-only contract binding to access the raw methods on
}

// AddressTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AddressTransactorRaw struct {
	Contract *AddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddress creates a new instance of Address, bound to a specific deployed contract.
func NewAddress(address common.Address, backend bind.ContractBackend) (*Address, error) {
	contract, err := bindAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// NewAddressCaller creates a new read-only instance of Address, bound to a specific deployed contract.
func NewAddressCaller(address common.Address, caller bind.ContractCaller) (*AddressCaller, error) {
	contract, err := bindAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressCaller{contract: contract}, nil
}

// NewAddressTransactor creates a new write-only instance of Address, bound to a specific deployed contract.
func NewAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressTransactor, error) {
	contract, err := bindAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressTransactor{contract: contract}, nil
}

// NewAddressFilterer creates a new log filterer instance of Address, bound to a specific deployed contract.
func NewAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressFilterer, error) {
	contract, err := bindAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressFilterer{contract: contract}, nil
}

// bindAddress binds a generic wrapper to an already deployed contract.
func bindAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AddressMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.AddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.contract.Transact(opts, method, params...)
}

// AnchorBlocksMetaData contains all meta data concerning the AnchorBlocks contract.
var AnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"AnchorBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightClient\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientOptimisticUpdate\",\"name\":\"hb\",\"type\":\"tuple\"}],\"name\":\"processUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientOptimisticUpdate\",\"name\":\"hb\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"left\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"right\",\"type\":\"bytes\"}],\"internalType\":\"structAnchorBlocks.BlockHashWitness[]\",\"name\":\"chainProof\",\"type\":\"tuple[]\"}],\"name\":\"processUpdateWithChainProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"name\":\"setLightClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346101ac57601f62001f8c38819003918201601f1916830192916001600160401b038411838510176101b057808392604095865283396020928391810103126101ac57516001600160a01b038082169290918390036101ac575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff1661016c5750600254680100000000000000008110156101585760018101806002558110156101445790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a1600554161760055551611dc79081620001c58239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f803560e01c8063158535ff14610ced5780632e3466f614610c5f5780633e553bab14610c0c5780633f4ba83a14610b0c57806346fbf68e146108c05780634f4fef1814610aee57806358a16b4414610acf5780635c975abb14610aaa578063677625f21461094d5780636b2c0f55146109165780636ef8d66d146108fc57806380f51c12146108c057806382dc1ec4146108895780638456cb591461076f5780638da5cb5b14610749578063a036e799146106f9578063b5700e68146106d1578063e6c6fcec14610681578063e79b7a5114610628578063f25b3f9914610600578063f2fde38b14610515578063fabc74f5146104bc578063fb8cfb5114610195578063fbbea34c146101725763fd1190ea14610130575f80fd5b3461016f57602036600319011261016f578235925483101561016f57506001600160a01b03610160602093610d65565b92905490519260031b1c168152f35b80fd5b5090346101915781600319360112610191576020906007549051908152f35b5080fd5b509190346104b85760603660031901126104b85767ffffffffffffffff9180358381116104b4576101c99036908301610f2f565b91602480359460449283358281116104b057366023820112156104b05780860135906101f482610e3d565b9161020184519384610e02565b808352602094868685019260051b840101923684116104ac57878101925b8484106104365750505050503389526003835260ff828a2054169660038810156104245760018098036103e3578151156103a25761025c90611275565b9190978151890398891161039057808a928c925b6102c9575b5050500361028b5787610288888861175c565b80f35b5162461bcd60e51b8152938401526012908301527f696e76616c696420636861696e50726f6f66000000000000000000000000000090820152606490fd5b909192815184101561038a57896102e08584611827565b515151036103495761034190876103386102fa8786611827565b51519261032a8361030b8a89611827565b5101518b51948593610320828601809961183b565b908152019061183b565b03601f198101835282610e02565b51902093611805565b919081610270565b855162461bcd60e51b8152808b018890526010818a01527f696e76616c6964206c656674206c656e00000000000000000000000000000000818b0152606490fd5b92610275565b634e487b7160e01b8b5260118852858bfd5b825162461bcd60e51b81528088018590526014818701527f696e76616c69642070726f6f66206c656e67746800000000000000000000000081880152606490fd5b825162461bcd60e51b81528088018590526012818701527f6e6f7420696e76616c69642070726f766572000000000000000000000000000081880152606490fd5b634e487b7160e01b8a5260218752848afd5b83358381116104a85782018760231982360301126104a85787519161045a83610d9a565b8a8201358581116104a357610474908c36918501016111f8565b83528b820135928584116104a3576104948b94938d8695369201016111f8565b8382015281520193019261021f565b508f80fd5b8e80fd5b8c80fd5b8880fd5b8480fd5b8280fd5b509034610191576020366003190112610191576001600160a01b036104df611153565b168252600360205260ff8183205416905191600382101561050257602083838152f35b634e487b7160e01b815260218452602490fd5b5091346104b85760203660031901126104b857610530611153565b908354906001600160a01b038083169361054b338614611864565b1693841561059757505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b5091346104b85760203660031901126104b85760209282913581526006845220549051908152f35b503461016f5761063736611169565b906001600160a01b039161064f838354163314611864565b815b815181101561067d57806106738561066c6106789486611827565b5116611af0565b611805565b610651565b8280f35b503461016f5761069036611169565b906001600160a01b03916106a8838354163314611864565b815b815181101561067d5780610673856106c56106cc9486611827565b511661191a565b6106aa565b5090346101915781600319360112610191576020906001600160a01b03600554169051908152f35b503461016f5761070836611169565b906001600160a01b0391610720838354163314611864565b815b815181101561067d57806106738561073d6107449486611827565b5116611bd5565b610722565b5090346101915781600319360112610191576001600160a01b0360209254169051908152f35b509190346104b857826003193601126104b85733835260019160209083825261079d60ff84872054166118ce565b845460ff8160a01c166108475760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b6107fe578580f35b815481101561084357806001600160a01b0361081c61083d93610d65565b919054600392831b1c1688528452848720600260ff19825416179055611805565b846107f6565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b503461016f57602036600319011261016f576102886108a6611153565b6108bb6001600160a01b038454163314611864565b611af0565b5090346101915760203660031901126101915760ff816020936001600160a01b036108e9611153565b1681526001855220541690519015158152f35b503461016f578060031936011261016f5761028833611bd5565b503461016f57602036600319011261016f57610288610933611153565b6109486001600160a01b038454163314611864565b611bd5565b503461016f5761095c36611169565b916001600160a01b03610973818454163314611864565b825b8451811015610aa657816109898287611827565b511680855260039060209180835260ff868820541681811015610a9357610a5057885468010000000000000000811015610a3d579189610a38959492610a1b836109fb7fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684976001958682019055610d65565b90919082549060031b916001600160a01b03809116831b921b1916179055565b828a5283528789209060ff198254161790558651908152a1611805565b610975565b634e487b7160e01b885260418a52602488fd5b855162461bcd60e51b8152808a01849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b885260218a52602488fd5b8380f35b50903461019157816003193601126101915760ff6020925460a01c1690519015158152f35b5090346101915781600319360112610191576020906002549051908152f35b5091346104b857826003193601126104b85760209250549051908152f35b5090346101915781600319360112610191573382526001906020828152610b3860ff83862054166118ce565b83549460ff8660a01c1615610bcb5760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b610b86578580f35b805484101561084357610bc5846001600160a01b03610ba58897610d65565b919054600392831b1c16895284528488208660ff19825416179055611805565b93610b7e565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b503461016f57602036600319011261016f57610c26611153565b6001600160a01b0390610c3d828454163314611864565b1673ffffffffffffffffffffffffffffffffffffffff19600554161760055580f35b50823461019157602036600319011261019157803567ffffffffffffffff81116104b857610c93610c989136908401610f2f565b611275565b918215610caa5750906102889161175c565b606490602086519162461bcd60e51b8352820152600f60248201527f656d70747920626c6f636b4861736800000000000000000000000000000000006044820152fd5b5091346104b85760203660031901126104b857359160025483101561016f57506001600160a01b036101606020935b600254811015610d515760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b600454811015610d515760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6040810190811067ffffffffffffffff821117610db657604052565b634e487b7160e01b5f52604160045260245ffd5b6060810190811067ffffffffffffffff821117610db657604052565b6080810190811067ffffffffffffffff821117610db657604052565b90601f8019910116810190811067ffffffffffffffff821117610db657604052565b359067ffffffffffffffff82168203610e3957565b5f80fd5b67ffffffffffffffff8111610db65760051b60200190565b9190604083820312610e395760405192610e6e84610d9a565b8381358152602091828101359067ffffffffffffffff8211610e3957019280601f85011215610e39578335610ea281610e3d565b94610eb06040519687610e02565b818652848087019260051b820101928311610e395784809101915b838310610eda57505050500152565b8235815291810191859101610ecb565b9080601f83011215610e395760405191610f0383610d9a565b829060408101928311610e3957905b828210610f1f5750505090565b8135815260209182019101610f12565b9190828103926101e08412610e3957604090815192610f4d84610dca565b839582359067ffffffffffffffff91828111610e395784019182840360e08112610e395760a0875191610f7f83610dca565b12610e395786519160a0830183811082821117610db6578852610fa185610e24565b8352602094610fb1868201610e24565b868501528881013589850152606093848201358582015260808201356080820152835260a0810135828111610e395781018481890312610e3957895190610ff782610dca565b8035848111610e39578961100c918301610e55565b825287810135848111610e395789611025918301610e55565b888301528a81013590848211610e3957611041918a9101610e55565b8a8201528684015260c0810135918211610e395761106191879101610e55565b8188015287526101a0601f19830112610e395785519361108085610de6565b61108b848701610e24565b8552868601358486015281860135878601526101408093607f190112610e39578651926110b784610de6565b6110c48260808901610eea565b84528160df88011215610e395787516110dc81610d9a565b8091880191838311610e39578960c08a01915b84831061113a57505050826111178694889694611125946111359c9a6101c09c9a0152610eea565b8a8501526101808701610eea565b8183015283015286015201610e24565b910152565b88906111468785610eea565b8152019101908a906110ef565b600435906001600160a01b0382168203610e3957565b602080600319830112610e39576004359167ffffffffffffffff8311610e395780602384011215610e395782600401356111a281610e3d565b936111b06040519586610e02565b81855260248486019260051b820101928311610e3957602401905b8282106111d9575050505090565b81356001600160a01b0381168103610e395781529083019083016111cb565b81601f82011215610e395780359067ffffffffffffffff8211610db6576040519261122d601f8401601f191660200185610e02565b82845260208383010111610e3957815f926020809301838601378301015290565b5f915b6002831061125e57505050565b600190825181526020809101920192019190611251565b602091828201928351925f94600367ffffffffffffffff8096511602858116908103611748576104001161170357815191604094858401908151936080865101519887865196015195968b975b87518910156113745760ff8911611360576001808a1b1561134c578a918e9160198c1c8116036113345761130361130e916112fd8d8d611827565b516118af565b8d519182809261183b565b039060025afa1561132a576113248c5198611805565b976112c2565b89513d8d823e3d90fd5b61130361130e916113458d8d611827565b51906118af565b634e487b7160e01b8e52601260045260248efd5b634e487b7160e01b8d52601160045260248dfd5b92959a91949750929550036116bf578501938685510151938151519887865196015195968b975b87518910156114035760ff8911611360576001808a1b1561134c578a918e9160168c1c8116036113f2576113036113d6916112fd8d8d611827565b039060025afa1561132a576113ec8c5198611805565b9761139b565b6113036113d6916113458d8d611827565b92959a919497509295500361168f57859051015192515196858451940151939489955b85518710156114cb5760ff87116114b757600180881b156114a35788918c91601c8a1c8116036114925761146161146c916112fd8b8b611827565b8b519182809261183b565b039060025afa15611488576114828a5196611805565b95611426565b87513d8b823e3d90fd5b61146161146c916113458b8b611827565b634e487b7160e01b8c52601260045260248cfd5b634e487b7160e01b8b52601160045260248bfd5b92955092979093509594950361165f576001600160a01b0360055416818585015116928451519051823b1561165b579160608a9360808997949751978895631ee9fa5560e11b87526004870152878151166024870152878c8201511660448701528a8101516064870152838101516084870152015160a48501528581511660c48501528981015160e48501528881015161010485015201516115726101248401825161124e565b80890151848a8a61016487015b6002841061163157506102649593506115b8925060609150936115ab87958201516101e487019061124e565b015161022484019061124e565b5afa801561162757611600575b50508290510190815101515184905b8382106115e45750505101515190565b600895861b60ff821617951c906115fa90611805565b906115d4565b819692961161161357825293825f6115c5565b634e487b7160e01b82526041600452602482fd5b84513d89823e3d90fd5b90919294965083959750611648816001955161124e565b0193019101908693918a8a8e979561157f565b8980fd5b835162461bcd60e51b81526004810186905260096024820152683130b210383937b7b360b91b6044820152606490fd5b865162461bcd60e51b81526004810187905260096024820152683130b210383937b7b360b91b6044820152606490fd5b865162461bcd60e51b815260048101879052601360248201527f626164206578656320726f6f742070726f6f66000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260048101849052601260248201527f71756f72756d206e6f74207265616368656400000000000000000000000000006044820152606490fd5b634e487b7160e01b87526011600452602487fd5b90815f52600660205260405f20546117c057816040917fa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85935f52600660205280835f205560075482116117b7575b82519182526020820152a1565b816007556117aa565b60405162461bcd60e51b815260206004820152601960248201527f626c6f636b206861736820616c726561647920657869737473000000000000006044820152606490fd5b5f1981146118135760010190565b634e487b7160e01b5f52601160045260245ffd5b8051821015610d515760209160051b010190565b908151915f5b838110611851575050015f815290565b8060208092840101518185015201611841565b1561186b57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b91906040519260208401526040830152604082526118cc82610dca565b565b156118d557565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611adc5715611a98576004968754965f1990818901988911611a8557835b8a54811015611a4257868261197383610d65565b905490871b1c161461198d5761198890611805565b61195f565b909192939495969798808210611a1d575b50505087548015611a0a5797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985989901906119f46119df83610d65565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611a3a92611a2d6109fb92610d65565b905490871b1c1691610d65565b5f808061199e565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611b905760025468010000000000000000811015611b7c57602092611b607f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936109fb84600160409601600255610d1c565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611d4d576002805490915f1991828101908111611d3957908695949392918a975b611c64575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611d30578185611c7c8c610d1c565b929054600393841b1c1614611ca55750611c9c8798999a97959697611805565b97969594611c1b565b9293949796959991818310611d0b575b5050505081548015611cf757918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e98999301906119f46119df83610d1c565b634e487b7160e01b89526031600452602489fd5b611d2793611d1b6109fb93610d1c565b9054911b1c1691610d1c565b5f808080611cb5565b87989950611c20565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea264697066735822122063fbd9b78775008965230cd8a7078e5a752d02e5af0baae5c76b33fc9411bc8064736f6c63430008140033",
}

// AnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use AnchorBlocksMetaData.ABI instead.
var AnchorBlocksABI = AnchorBlocksMetaData.ABI

// AnchorBlocksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AnchorBlocksMetaData.Bin instead.
var AnchorBlocksBin = AnchorBlocksMetaData.Bin

// DeployAnchorBlocks deploys a new Ethereum contract, binding an instance of AnchorBlocks to it.
func DeployAnchorBlocks(auth *bind.TransactOpts, backend bind.ContractBackend, _lightClient common.Address) (common.Address, *types.Transaction, *AnchorBlocks, error) {
	parsed, err := AnchorBlocksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AnchorBlocksBin), backend, _lightClient)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AnchorBlocks{AnchorBlocksCaller: AnchorBlocksCaller{contract: contract}, AnchorBlocksTransactor: AnchorBlocksTransactor{contract: contract}, AnchorBlocksFilterer: AnchorBlocksFilterer{contract: contract}}, nil
}

// AnchorBlocks is an auto generated Go binding around an Ethereum contract.
type AnchorBlocks struct {
	AnchorBlocksCaller     // Read-only binding to the contract
	AnchorBlocksTransactor // Write-only binding to the contract
	AnchorBlocksFilterer   // Log filterer for contract events
}

// AnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type AnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AnchorBlocksSession struct {
	Contract     *AnchorBlocks     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AnchorBlocksCallerSession struct {
	Contract *AnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// AnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AnchorBlocksTransactorSession struct {
	Contract     *AnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// AnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type AnchorBlocksRaw struct {
	Contract *AnchorBlocks // Generic contract binding to access the raw methods on
}

// AnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AnchorBlocksCallerRaw struct {
	Contract *AnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// AnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AnchorBlocksTransactorRaw struct {
	Contract *AnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAnchorBlocks creates a new instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocks(address common.Address, backend bind.ContractBackend) (*AnchorBlocks, error) {
	contract, err := bindAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocks{AnchorBlocksCaller: AnchorBlocksCaller{contract: contract}, AnchorBlocksTransactor: AnchorBlocksTransactor{contract: contract}, AnchorBlocksFilterer: AnchorBlocksFilterer{contract: contract}}, nil
}

// NewAnchorBlocksCaller creates a new read-only instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*AnchorBlocksCaller, error) {
	contract, err := bindAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksCaller{contract: contract}, nil
}

// NewAnchorBlocksTransactor creates a new write-only instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*AnchorBlocksTransactor, error) {
	contract, err := bindAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksTransactor{contract: contract}, nil
}

// NewAnchorBlocksFilterer creates a new log filterer instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*AnchorBlocksFilterer, error) {
	contract, err := bindAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksFilterer{contract: contract}, nil
}

// bindAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnchorBlocks *AnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnchorBlocks.Contract.AnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnchorBlocks *AnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnchorBlocks *AnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnchorBlocks *AnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnchorBlocks *AnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnchorBlocks *AnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksCaller) Blocks(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "blocks", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksSession) Blocks(arg0 *big.Int) ([32]byte, error) {
	return _AnchorBlocks.Contract.Blocks(&_AnchorBlocks.CallOpts, arg0)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksCallerSession) Blocks(arg0 *big.Int) ([32]byte, error) {
	return _AnchorBlocks.Contract.Blocks(&_AnchorBlocks.CallOpts, arg0)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) IsPauser(account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsPauser(&_AnchorBlocks.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) IsPauser(account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsPauser(&_AnchorBlocks.CallOpts, account)
}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) LatestBlockNum(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "latestBlockNum")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) LatestBlockNum() (*big.Int, error) {
	return _AnchorBlocks.Contract.LatestBlockNum(&_AnchorBlocks.CallOpts)
}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) LatestBlockNum() (*big.Int, error) {
	return _AnchorBlocks.Contract.LatestBlockNum(&_AnchorBlocks.CallOpts)
}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) LightClient(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "lightClient")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) LightClient() (common.Address, error) {
	return _AnchorBlocks.Contract.LightClient(&_AnchorBlocks.CallOpts)
}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) LightClient() (common.Address, error) {
	return _AnchorBlocks.Contract.LightClient(&_AnchorBlocks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) NumPausers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumPausers(&_AnchorBlocks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) NumPausers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumPausers(&_AnchorBlocks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) NumProvers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumProvers(&_AnchorBlocks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) NumProvers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumProvers(&_AnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) Owner() (common.Address, error) {
	return _AnchorBlocks.Contract.Owner(&_AnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) Owner() (common.Address, error) {
	return _AnchorBlocks.Contract.Owner(&_AnchorBlocks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) Paused() (bool, error) {
	return _AnchorBlocks.Contract.Paused(&_AnchorBlocks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) Paused() (bool, error) {
	return _AnchorBlocks.Contract.Paused(&_AnchorBlocks.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.PauserList(&_AnchorBlocks.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.PauserList(&_AnchorBlocks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) Pausers(arg0 common.Address) (bool, error) {
	return _AnchorBlocks.Contract.Pausers(&_AnchorBlocks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _AnchorBlocks.Contract.Pausers(&_AnchorBlocks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _AnchorBlocks.Contract.ProverStates(&_AnchorBlocks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _AnchorBlocks.Contract.ProverStates(&_AnchorBlocks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.Provers(&_AnchorBlocks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.Provers(&_AnchorBlocks.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPauser(&_AnchorBlocks.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPauser(&_AnchorBlocks.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPausers(&_AnchorBlocks.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPausers(&_AnchorBlocks.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksSession) Pause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Pause(&_AnchorBlocks.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) Pause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Pause(&_AnchorBlocks.TransactOpts)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) ProcessUpdate(opts *bind.TransactOpts, hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "processUpdate", hb)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksSession) ProcessUpdate(hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdate(&_AnchorBlocks.TransactOpts, hb)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) ProcessUpdate(hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdate(&_AnchorBlocks.TransactOpts, hb)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) ProcessUpdateWithChainProof(opts *bind.TransactOpts, hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "processUpdateWithChainProof", hb, blockHash, chainProof)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksSession) ProcessUpdateWithChainProof(hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdateWithChainProof(&_AnchorBlocks.TransactOpts, hb, blockHash, chainProof)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) ProcessUpdateWithChainProof(hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdateWithChainProof(&_AnchorBlocks.TransactOpts, hb, blockHash, chainProof)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePauser(&_AnchorBlocks.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePauser(&_AnchorBlocks.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePausers(&_AnchorBlocks.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePausers(&_AnchorBlocks.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemoveProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemoveProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksSession) RenouncePauser() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RenouncePauser(&_AnchorBlocks.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RenouncePauser(&_AnchorBlocks.TransactOpts)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) SetLightClient(opts *bind.TransactOpts, _lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "setLightClient", _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksSession) SetLightClient(_lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.SetLightClient(&_AnchorBlocks.TransactOpts, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) SetLightClient(_lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.SetLightClient(&_AnchorBlocks.TransactOpts, _lightClient)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.TransferOwnership(&_AnchorBlocks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.TransferOwnership(&_AnchorBlocks.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksSession) Unpause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Unpause(&_AnchorBlocks.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) Unpause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Unpause(&_AnchorBlocks.TransactOpts)
}

// AnchorBlocksAnchorBlockUpdatedIterator is returned from FilterAnchorBlockUpdated and is used to iterate over the raw logs and unpacked data for AnchorBlockUpdated events raised by the AnchorBlocks contract.
type AnchorBlocksAnchorBlockUpdatedIterator struct {
	Event *AnchorBlocksAnchorBlockUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksAnchorBlockUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksAnchorBlockUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksAnchorBlockUpdated represents a AnchorBlockUpdated event raised by the AnchorBlocks contract.
type AnchorBlocksAnchorBlockUpdated struct {
	BlockNum  *big.Int
	BlockHash [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAnchorBlockUpdated is a free log retrieval operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterAnchorBlockUpdated(opts *bind.FilterOpts) (*AnchorBlocksAnchorBlockUpdatedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "AnchorBlockUpdated")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksAnchorBlockUpdatedIterator{contract: _AnchorBlocks.contract, event: "AnchorBlockUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorBlockUpdated is a free log subscription operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchAnchorBlockUpdated(opts *bind.WatchOpts, sink chan<- *AnchorBlocksAnchorBlockUpdated) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "AnchorBlockUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksAnchorBlockUpdated)
				if err := _AnchorBlocks.contract.UnpackLog(event, "AnchorBlockUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorBlockUpdated is a log parse operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseAnchorBlockUpdated(log types.Log) (*AnchorBlocksAnchorBlockUpdated, error) {
	event := new(AnchorBlocksAnchorBlockUpdated)
	if err := _AnchorBlocks.contract.UnpackLog(event, "AnchorBlockUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the AnchorBlocks contract.
type AnchorBlocksOwnershipTransferredIterator struct {
	Event *AnchorBlocksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksOwnershipTransferred represents a OwnershipTransferred event raised by the AnchorBlocks contract.
type AnchorBlocksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*AnchorBlocksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksOwnershipTransferredIterator{contract: _AnchorBlocks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *AnchorBlocksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksOwnershipTransferred)
				if err := _AnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseOwnershipTransferred(log types.Log) (*AnchorBlocksOwnershipTransferred, error) {
	event := new(AnchorBlocksOwnershipTransferred)
	if err := _AnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the AnchorBlocks contract.
type AnchorBlocksPausedIterator struct {
	Event *AnchorBlocksPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPaused represents a Paused event raised by the AnchorBlocks contract.
type AnchorBlocksPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPaused(opts *bind.FilterOpts) (*AnchorBlocksPausedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPausedIterator{contract: _AnchorBlocks.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPaused) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPaused)
				if err := _AnchorBlocks.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePaused(log types.Log) (*AnchorBlocksPaused, error) {
	event := new(AnchorBlocksPaused)
	if err := _AnchorBlocks.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the AnchorBlocks contract.
type AnchorBlocksPauserAddedIterator struct {
	Event *AnchorBlocksPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPauserAdded represents a PauserAdded event raised by the AnchorBlocks contract.
type AnchorBlocksPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*AnchorBlocksPauserAddedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPauserAddedIterator{contract: _AnchorBlocks.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPauserAdded) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPauserAdded)
				if err := _AnchorBlocks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePauserAdded(log types.Log) (*AnchorBlocksPauserAdded, error) {
	event := new(AnchorBlocksPauserAdded)
	if err := _AnchorBlocks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the AnchorBlocks contract.
type AnchorBlocksPauserRemovedIterator struct {
	Event *AnchorBlocksPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPauserRemoved represents a PauserRemoved event raised by the AnchorBlocks contract.
type AnchorBlocksPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*AnchorBlocksPauserRemovedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPauserRemovedIterator{contract: _AnchorBlocks.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPauserRemoved)
				if err := _AnchorBlocks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePauserRemoved(log types.Log) (*AnchorBlocksPauserRemoved, error) {
	event := new(AnchorBlocksPauserRemoved)
	if err := _AnchorBlocks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the AnchorBlocks contract.
type AnchorBlocksProverAddedIterator struct {
	Event *AnchorBlocksProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksProverAdded represents a ProverAdded event raised by the AnchorBlocks contract.
type AnchorBlocksProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterProverAdded(opts *bind.FilterOpts) (*AnchorBlocksProverAddedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksProverAddedIterator{contract: _AnchorBlocks.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *AnchorBlocksProverAdded) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksProverAdded)
				if err := _AnchorBlocks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseProverAdded(log types.Log) (*AnchorBlocksProverAdded, error) {
	event := new(AnchorBlocksProverAdded)
	if err := _AnchorBlocks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the AnchorBlocks contract.
type AnchorBlocksProverRemovedIterator struct {
	Event *AnchorBlocksProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksProverRemoved represents a ProverRemoved event raised by the AnchorBlocks contract.
type AnchorBlocksProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*AnchorBlocksProverRemovedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksProverRemovedIterator{contract: _AnchorBlocks.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *AnchorBlocksProverRemoved) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksProverRemoved)
				if err := _AnchorBlocks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseProverRemoved(log types.Log) (*AnchorBlocksProverRemoved, error) {
	event := new(AnchorBlocksProverRemoved)
	if err := _AnchorBlocks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the AnchorBlocks contract.
type AnchorBlocksUnpausedIterator struct {
	Event *AnchorBlocksUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksUnpaused represents a Unpaused event raised by the AnchorBlocks contract.
type AnchorBlocksUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterUnpaused(opts *bind.FilterOpts) (*AnchorBlocksUnpausedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksUnpausedIterator{contract: _AnchorBlocks.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *AnchorBlocksUnpaused) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksUnpaused)
				if err := _AnchorBlocks.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseUnpaused(log types.Log) (*AnchorBlocksUnpaused, error) {
	event := new(AnchorBlocksUnpaused)
	if err := _AnchorBlocks.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BalanceDeltaLibraryMetaData contains all meta data concerning the BalanceDeltaLibrary contract.
var BalanceDeltaLibraryMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212206e3692eb33aea83cd795699c12f4f7b4a33bb1c36938a64e278e627d513cafc464736f6c63430008140033",
}

// BalanceDeltaLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use BalanceDeltaLibraryMetaData.ABI instead.
var BalanceDeltaLibraryABI = BalanceDeltaLibraryMetaData.ABI

// BalanceDeltaLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BalanceDeltaLibraryMetaData.Bin instead.
var BalanceDeltaLibraryBin = BalanceDeltaLibraryMetaData.Bin

// DeployBalanceDeltaLibrary deploys a new Ethereum contract, binding an instance of BalanceDeltaLibrary to it.
func DeployBalanceDeltaLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BalanceDeltaLibrary, error) {
	parsed, err := BalanceDeltaLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BalanceDeltaLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BalanceDeltaLibrary{BalanceDeltaLibraryCaller: BalanceDeltaLibraryCaller{contract: contract}, BalanceDeltaLibraryTransactor: BalanceDeltaLibraryTransactor{contract: contract}, BalanceDeltaLibraryFilterer: BalanceDeltaLibraryFilterer{contract: contract}}, nil
}

// BalanceDeltaLibrary is an auto generated Go binding around an Ethereum contract.
type BalanceDeltaLibrary struct {
	BalanceDeltaLibraryCaller     // Read-only binding to the contract
	BalanceDeltaLibraryTransactor // Write-only binding to the contract
	BalanceDeltaLibraryFilterer   // Log filterer for contract events
}

// BalanceDeltaLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BalanceDeltaLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BalanceDeltaLibrarySession struct {
	Contract     *BalanceDeltaLibrary // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BalanceDeltaLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BalanceDeltaLibraryCallerSession struct {
	Contract *BalanceDeltaLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// BalanceDeltaLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BalanceDeltaLibraryTransactorSession struct {
	Contract     *BalanceDeltaLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// BalanceDeltaLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type BalanceDeltaLibraryRaw struct {
	Contract *BalanceDeltaLibrary // Generic contract binding to access the raw methods on
}

// BalanceDeltaLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryCallerRaw struct {
	Contract *BalanceDeltaLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// BalanceDeltaLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryTransactorRaw struct {
	Contract *BalanceDeltaLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBalanceDeltaLibrary creates a new instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibrary(address common.Address, backend bind.ContractBackend) (*BalanceDeltaLibrary, error) {
	contract, err := bindBalanceDeltaLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibrary{BalanceDeltaLibraryCaller: BalanceDeltaLibraryCaller{contract: contract}, BalanceDeltaLibraryTransactor: BalanceDeltaLibraryTransactor{contract: contract}, BalanceDeltaLibraryFilterer: BalanceDeltaLibraryFilterer{contract: contract}}, nil
}

// NewBalanceDeltaLibraryCaller creates a new read-only instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryCaller(address common.Address, caller bind.ContractCaller) (*BalanceDeltaLibraryCaller, error) {
	contract, err := bindBalanceDeltaLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryCaller{contract: contract}, nil
}

// NewBalanceDeltaLibraryTransactor creates a new write-only instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*BalanceDeltaLibraryTransactor, error) {
	contract, err := bindBalanceDeltaLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryTransactor{contract: contract}, nil
}

// NewBalanceDeltaLibraryFilterer creates a new log filterer instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*BalanceDeltaLibraryFilterer, error) {
	contract, err := bindBalanceDeltaLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryFilterer{contract: contract}, nil
}

// bindBalanceDeltaLibrary binds a generic wrapper to an already deployed contract.
func bindBalanceDeltaLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BalanceDeltaLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BalanceDeltaLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.contract.Transact(opts, method, params...)
}

// BaseFactoryMetaData contains all meta data concerning the BaseFactory contract.
var BaseFactoryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"TargetPrefix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FLAG_MASK\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// BaseFactoryABI is the input ABI used to generate the binding from.
// Deprecated: Use BaseFactoryMetaData.ABI instead.
var BaseFactoryABI = BaseFactoryMetaData.ABI

// BaseFactory is an auto generated Go binding around an Ethereum contract.
type BaseFactory struct {
	BaseFactoryCaller     // Read-only binding to the contract
	BaseFactoryTransactor // Write-only binding to the contract
	BaseFactoryFilterer   // Log filterer for contract events
}

// BaseFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type BaseFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BaseFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BaseFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BaseFactorySession struct {
	Contract     *BaseFactory      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BaseFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BaseFactoryCallerSession struct {
	Contract *BaseFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BaseFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BaseFactoryTransactorSession struct {
	Contract     *BaseFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BaseFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type BaseFactoryRaw struct {
	Contract *BaseFactory // Generic contract binding to access the raw methods on
}

// BaseFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BaseFactoryCallerRaw struct {
	Contract *BaseFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// BaseFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BaseFactoryTransactorRaw struct {
	Contract *BaseFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBaseFactory creates a new instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactory(address common.Address, backend bind.ContractBackend) (*BaseFactory, error) {
	contract, err := bindBaseFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BaseFactory{BaseFactoryCaller: BaseFactoryCaller{contract: contract}, BaseFactoryTransactor: BaseFactoryTransactor{contract: contract}, BaseFactoryFilterer: BaseFactoryFilterer{contract: contract}}, nil
}

// NewBaseFactoryCaller creates a new read-only instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryCaller(address common.Address, caller bind.ContractCaller) (*BaseFactoryCaller, error) {
	contract, err := bindBaseFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryCaller{contract: contract}, nil
}

// NewBaseFactoryTransactor creates a new write-only instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*BaseFactoryTransactor, error) {
	contract, err := bindBaseFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryTransactor{contract: contract}, nil
}

// NewBaseFactoryFilterer creates a new log filterer instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*BaseFactoryFilterer, error) {
	contract, err := bindBaseFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryFilterer{contract: contract}, nil
}

// bindBaseFactory binds a generic wrapper to an already deployed contract.
func bindBaseFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BaseFactoryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseFactory *BaseFactoryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseFactory.Contract.BaseFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseFactory *BaseFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseFactory.Contract.BaseFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseFactory *BaseFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseFactory.Contract.BaseFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseFactory *BaseFactoryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseFactory *BaseFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseFactory *BaseFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseFactory.Contract.contract.Transact(opts, method, params...)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactoryCaller) TargetPrefix(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "TargetPrefix")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactorySession) TargetPrefix() (common.Address, error) {
	return _BaseFactory.Contract.TargetPrefix(&_BaseFactory.CallOpts)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactoryCallerSession) TargetPrefix() (common.Address, error) {
	return _BaseFactory.Contract.TargetPrefix(&_BaseFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactoryCaller) UNISWAPFLAGMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "UNISWAP_FLAG_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactorySession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _BaseFactory.Contract.UNISWAPFLAGMASK(&_BaseFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactoryCallerSession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _BaseFactory.Contract.UNISWAPFLAGMASK(&_BaseFactory.CallOpts)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactoryCaller) MineSalt(opts *bind.CallOpts, poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "mineSalt", poolManager, startSalt)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactorySession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _BaseFactory.Contract.MineSalt(&_BaseFactory.CallOpts, poolManager, startSalt)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactoryCallerSession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _BaseFactory.Contract.MineSalt(&_BaseFactory.CallOpts, poolManager, startSalt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactoryTransactor) Deploy(opts *bind.TransactOpts, poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "deploy", poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactorySession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.Contract.Deploy(&_BaseFactory.TransactOpts, poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.Contract.Deploy(&_BaseFactory.TransactOpts, poolManager, salt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactoryTransactor) MineDeploy(opts *bind.TransactOpts, poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "mineDeploy", poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactorySession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy(&_BaseFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy(&_BaseFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactoryTransactor) MineDeploy0(opts *bind.TransactOpts, poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "mineDeploy0", poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactorySession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy0(&_BaseFactory.TransactOpts, poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy0(&_BaseFactory.TransactOpts, poolManager)
}

// BaseHookMetaData contains all meta data concerning the BaseHook contract.
var BaseHookMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustUseDynamicFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHooksCalls\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"beforeInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeDonate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterDonate\",\"type\":\"bool\"}],\"internalType\":\"structHooks.Calls\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lockAcquired\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// BaseHookABI is the input ABI used to generate the binding from.
// Deprecated: Use BaseHookMetaData.ABI instead.
var BaseHookABI = BaseHookMetaData.ABI

// BaseHook is an auto generated Go binding around an Ethereum contract.
type BaseHook struct {
	BaseHookCaller     // Read-only binding to the contract
	BaseHookTransactor // Write-only binding to the contract
	BaseHookFilterer   // Log filterer for contract events
}

// BaseHookCaller is an auto generated read-only Go binding around an Ethereum contract.
type BaseHookCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BaseHookTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BaseHookFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BaseHookSession struct {
	Contract     *BaseHook         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BaseHookCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BaseHookCallerSession struct {
	Contract *BaseHookCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// BaseHookTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BaseHookTransactorSession struct {
	Contract     *BaseHookTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// BaseHookRaw is an auto generated low-level Go binding around an Ethereum contract.
type BaseHookRaw struct {
	Contract *BaseHook // Generic contract binding to access the raw methods on
}

// BaseHookCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BaseHookCallerRaw struct {
	Contract *BaseHookCaller // Generic read-only contract binding to access the raw methods on
}

// BaseHookTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BaseHookTransactorRaw struct {
	Contract *BaseHookTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBaseHook creates a new instance of BaseHook, bound to a specific deployed contract.
func NewBaseHook(address common.Address, backend bind.ContractBackend) (*BaseHook, error) {
	contract, err := bindBaseHook(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BaseHook{BaseHookCaller: BaseHookCaller{contract: contract}, BaseHookTransactor: BaseHookTransactor{contract: contract}, BaseHookFilterer: BaseHookFilterer{contract: contract}}, nil
}

// NewBaseHookCaller creates a new read-only instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookCaller(address common.Address, caller bind.ContractCaller) (*BaseHookCaller, error) {
	contract, err := bindBaseHook(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BaseHookCaller{contract: contract}, nil
}

// NewBaseHookTransactor creates a new write-only instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookTransactor(address common.Address, transactor bind.ContractTransactor) (*BaseHookTransactor, error) {
	contract, err := bindBaseHook(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BaseHookTransactor{contract: contract}, nil
}

// NewBaseHookFilterer creates a new log filterer instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookFilterer(address common.Address, filterer bind.ContractFilterer) (*BaseHookFilterer, error) {
	contract, err := bindBaseHook(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BaseHookFilterer{contract: contract}, nil
}

// bindBaseHook binds a generic wrapper to an already deployed contract.
func bindBaseHook(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BaseHookMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseHook *BaseHookRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseHook.Contract.BaseHookCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseHook *BaseHookRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.Contract.BaseHookTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseHook *BaseHookRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseHook.Contract.BaseHookTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseHook *BaseHookCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseHook.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseHook *BaseHookTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseHook *BaseHookTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseHook.Contract.contract.Transact(opts, method, params...)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookCaller) GetHooksCalls(opts *bind.CallOpts) (HooksCalls, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "getHooksCalls")

	if err != nil {
		return *new(HooksCalls), err
	}

	out0 := *abi.ConvertType(out[0], new(HooksCalls)).(*HooksCalls)

	return out0, err

}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookSession) GetHooksCalls() (HooksCalls, error) {
	return _BaseHook.Contract.GetHooksCalls(&_BaseHook.CallOpts)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookCallerSession) GetHooksCalls() (HooksCalls, error) {
	return _BaseHook.Contract.GetHooksCalls(&_BaseHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookSession) Owner() (common.Address, error) {
	return _BaseHook.Contract.Owner(&_BaseHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookCallerSession) Owner() (common.Address, error) {
	return _BaseHook.Contract.Owner(&_BaseHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookCaller) PoolManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "poolManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookSession) PoolManager() (common.Address, error) {
	return _BaseHook.Contract.PoolManager(&_BaseHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookCallerSession) PoolManager() (common.Address, error) {
	return _BaseHook.Contract.PoolManager(&_BaseHook.CallOpts)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterDonate", arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterInitialize", arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterModifyPosition", arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterSwap", arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeDonate", arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeInitialize", arg0, arg1, arg2, arg3)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeModifyPosition", arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeSwap", arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookTransactor) LockAcquired(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "lockAcquired", data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.LockAcquired(&_BaseHook.TransactOpts, data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookTransactorSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.LockAcquired(&_BaseHook.TransactOpts, data)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookSession) RenounceOwnership() (*types.Transaction, error) {
	return _BaseHook.Contract.RenounceOwnership(&_BaseHook.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BaseHook.Contract.RenounceOwnership(&_BaseHook.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.Contract.TransferOwnership(&_BaseHook.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.Contract.TransferOwnership(&_BaseHook.TransactOpts, newOwner)
}

// BaseHookOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BaseHook contract.
type BaseHookOwnershipTransferredIterator struct {
	Event *BaseHookOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BaseHookOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BaseHookOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BaseHookOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BaseHookOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BaseHookOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BaseHookOwnershipTransferred represents a OwnershipTransferred event raised by the BaseHook contract.
type BaseHookOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BaseHookOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BaseHook.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BaseHookOwnershipTransferredIterator{contract: _BaseHook.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BaseHookOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BaseHook.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BaseHookOwnershipTransferred)
				if err := _BaseHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) ParseOwnershipTransferred(log types.Log) (*BaseHookOwnershipTransferred, error) {
	event := new(BaseHookOwnershipTransferred)
	if err := _BaseHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BeaconVerifierMetaData contains all meta data concerning the BeaconVerifier contract.
var BeaconVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[35]\",\"name\":\"input\",\"type\":\"uint256[35]\"}],\"name\":\"verifyBlsSigProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[33]\",\"name\":\"input\",\"type\":\"uint256[33]\"}],\"name\":\"verifyCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"signingRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"participation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySignatureProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySyncCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001657613067908161001b8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f803560e01c9081630cc26769146100575750806352356da0146100525780637a5387811461004d5763ab00dde614610048575f80fd5b610662565b6105dd565b61052b565b346100bc576105a03660031901126100bc5761007236610236565b9061007c36610331565b61008536610273565b9061008f366102b1565b923661016312156100bc5760206100b2868686866100ac3661015a565b93610ad1565b6040519015158152f35b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906080820182811067ffffffffffffffff8211176100f357604052565b6100bf565b604051906040820182811067ffffffffffffffff8211176100f357604052565b60405190610460820182811067ffffffffffffffff8211176100f357604052565b60405190610420820182811067ffffffffffffffff8211176100f357604052565b90610163610118565b91826105a491821161019057610144905b82821061018057505050565b8135815260209182019101610174565b5f80fd5b9061019d6100f8565b918261018491821161019057610144905b8282106101ba57505050565b81358152602091820191016101ae565b906101d36100f8565b91826101c491821161019057610184905b8282106101f057505050565b81358152602091820191016101e4565b906102096100f8565b918261014491821161019057610104905b82821061022657505050565b813581526020918201910161021a565b8060231215610190576102476100f8565b90816044918211610190576004905b8282106102635750505090565b8135815260209182019101610256565b8060e31215610190576102846100f8565b90816101049182116101905760c4905b8282106102a15750505090565b8135815260209182019101610294565b806101231215610190576102c36100f8565b908161014491821161019057610104905b8282106102e15750505090565b81358152602091820191016102d4565b9080601f83011215610190576103056100f8565b80926040810192831161019057905b8282106103215750505090565b8135815260209182019101610314565b8060631215610190576103426100f8565b908160c491808311610190576044915b838310610360575050505090565b602060409161036f84866102f1565b815201920191610352565b8060e312156101905761038b6100f8565b9081610144918083116101905760c4915b8383106103aa575050505090565b60206040916103b984866102f1565b81520192019161039c565b8060a31215610190576103d56100f8565b908161010491808311610190576084915b8383106103f4575050505090565b602060409161040384866102f1565b8152019201916103e6565b90610140608319830112610190576104246100d3565b918060a31215610190576104366100f8565b60c481838211610190576084905b8282106104905750505083526104598161037a565b60208401528061016312156101905761047181610194565b6040840152806101a3121561019057610489906101ca565b6060830152565b8135815260209182019101610444565b90610140604319830112610190576104b66100d3565b918060631215610190576104c86100f8565b608481838211610190576044905b82821061051b5750505083526104eb816103c4565b60208401528061012312156101905761050381610200565b60408401528061016312156101905761048990610194565b81358152602091820191016104d6565b34610190576101c0366003190112610190576105463661040e565b61054e610118565b906104603683375f6004355b602082106105b3576105af61059d858560443561040083015260243561042083015260643561044083015280519060208101516060604083015192015192610ad1565b60405190151581529081906020820190565b0390f35b8060ff6105d792166105cd6105c785610757565b87610779565b5260081c91610749565b9061055a565b3461019057610180366003190112610190576105f8366104a0565b610600610139565b906104203683375f6004355b60208210610638576105af61059d85856024356104008301528051906040602082015191015191611c65565b601f9082820391821161065d57610657916105cd60ff8316918761078f565b9061060c565b610735565b34610190576105203660031901126101905761067d36610236565b61068636610331565b9061069036610273565b91366101231215610190576106a3610139565b9283916105249336851161019057602095610104905b8682106106cc5750506100b29450611c65565b813581529087019087016106b9565b6106e36100d3565b906080368337565b604051906060820182811067ffffffffffffffff8211176100f3576040526060368337565b604051906020820182811067ffffffffffffffff8211176100f3576040526020368337565b634e487b7160e01b5f52601160045260245ffd5b5f19811461065d5760010190565b601f0390601f821161065d57565b634e487b7160e01b5f52603260045260245ffd5b90602381101561078a5760051b0190565b610765565b90602181101561078a5760051b0190565b6107a86100f8565b906107b16100f8565b604036823782526107c06100f8565b60403682376020830152565b6107d46100d3565b906107dd6100f8565b5f9081815281602082015283526107f26107a0565b60208401526107ff6100f8565b81815281602082015260408401526108156100f8565b9080825260208201526060830152565b1561082c57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561087857565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b156108c457565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561091057565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561095c57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156109a857565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b156109f457565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b15610a4057565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b15610a8c57565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b94939492919092610ae06107cc565b8151602080930151610af06100f8565b918252838201528152610b016100f8565b948051518652610b12815160200190565b5183870152610b3183610b236100f8565b920180515183525160200190565b5183820152610b3e6100f8565b95865282860152818101948552818351930151610b596100f8565b9384528284015260408101928352835193828101948551610b786100f8565b9182528482015260608301908152610c2c7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47610bb78186515110610825565b610bc681878751015110610871565b610bd4818a515151106108bd565b610be481878b5101515110610909565b610bfb81610bf48b515160200190565b5110610955565b610c1481610c0d888c51015160200190565b51106109a1565b610c2181885151106109ed565b858751015110610a39565b5f5b602381106119685750906119419798939291610c486119e9565b96610c516100f8565b925f845261190884878101985f8a528199610c6a6106db565b918a610440610c776106eb565b927f2065b90c648581703a4ef82833653ae713aaf62c2dc4ef26b0a9bbbdf254b48a610ca16100f8565b955f87525f858801527f0da0d09dcc32c2d20c9905307190ffb91538db928804c70e7ed77639f2cee0fe8952527f2fcf362c494439bcae24ab0ab7dd0bd40825ed18725c1d11d25eeb863f24194884527f184edce371c121d112278a4d1239f9d65421fb00e688d7612320bb5f66e7409d8385017f1a7a0f4ef55687795fa98c4585fc66e26ddea1f6e161a837ef4a4f1ae9c8808b815282519460408701958652610d4e8a8a8a8a612c69565b7f159c9e6c6ad47c3114dd4bdc88dc34359cae49de8306c8f56c9ba9d56429755e87527f261a0e3bad2b8c7b4057a7708b68ddaa9684eaa9d458088e7a2fe7813e08d06082528301518552610da589898989612c69565b7f1243c2c01b1a238bd0937eed8a5eb5f962eae681000356540ae1cfb36e1e308b86527e816901d1be816971e5f7e84b32a92c58a9f8971ff921adc37884d47db225e2815260408301518552610dfd89898989612c69565b7f25ebb06beeca9f8b08c511a86423c8f8705f115fe942220b9f8e30d54b016e0686527f1a598b2d183a54a959959d562879ae4b48df2203151d223973543b7d9584c59e815260608301518552610e5689898989612c69565b7f0ede030d344e453627bd0d2e849cd89947ed04b1825b0d4f7d6a8bf8b6ca5bae86527f01e7b010c4ab8cfc4791d0886bb39e1e8785b51a2a2165514d1fe026b8de24ad815260808301518552610eaf89898989612c69565b7f1f81ffd062f9644e01e392d39b8de8e030afd731c770e58f96050ed1d36d553286527f0ac85a9509ed9a6e21c1e933b10794303a4b77d9fd1fb036e966fef320cb4dad815260a08301518552610f0889898989612c69565b7f2d46add97dc6a65ee2f3dd3ea61060bf9fd510929a701e4cec0913f8ab1cafe386527f1e8e47b54e79299b14dfe604a3c8ce10ee4cb2d09be71e23628c13888c29a254815260c08301518552610f6189898989612c69565b7f146a85b7d5644a318ee8d2a44d995f580695fb92ade1dc0bbfc84cb4010ac1c386527f1d3734ea6fc621a0710ba60b024e87e0442525b2c77aff46634f6c5c0035e073815260e08301518552610fba89898989612c69565b7f12664f87a4a89be5df17d8f4cb797e102a083e505835ddfa68bfff968ded011f86527f062c4ef046ea89c77def686012d175292e6cca3adb8dc9e0234bbbe4384e6b188152610100830151855261101489898989612c69565b7f22ecd52df7b85f6392fa550619d401fedebde3332b7c8857f3b26caac17f4b7986527f25696ccea69b88905a95af209f6daa0d638426ae494b1b5800d1bb32aa271c3c8152610120830151855261106e89898989612c69565b7ee5e920eb2bd31bc7480c75e93c11a2a8f421af3e287f37a87453a96b4dd6c086527f2b82a4685f51b881675e3e4958242a11585b1aa2211bef1ba101ade59d484fcb815261014083015185526110c789898989612c69565b7f1bb112783a4bd8e95decec6012a6b0c06d076f07806241e64d5bb279055ce2e386527f03aacbe5b76da6ffe5a38b5f74bb1defdf60afde8f7bed77c2103c7d6d285c458152610160830151855261112189898989612c69565b7e89a49d6c462af5737f4f74e89ee3fd5fcda9b129a6885f4402b7191ce06ecc86527f03670d5e8e16d0f9e9351a53b707cddd87f0df01f7e71f8ef942b35a63c54d808152610180830151855261117a89898989612c69565b7f148203b1cf918d850c2e4eb482623111d69a0d149273d88bd472cc2dc667788886527f09e3685cddd844c117894cf1560ee45625a29890eb111e539598ac6c8510b26f81526101a083015185526111d489898989612c69565b7f038bda99e81e5aee528c18e38ab4a8806508a531d1f22f6618919bffb81f59f686527f14ce622b4ba47284ea8c421b00498ea220fb6f88026998098cbb21d38d8e0b0a81526101c0830151855261122e89898989612c69565b7f0c1641e14f8c4509f0c675448654f877363c981ca8c18363b549cfb115737ea386527f0b8cc9ed761dfbad8b821e125c571ba83a857c405c10df3bdeb64fc9b3248e2a81526101e0830151855261128889898989612c69565b7f14c11b03d9e6d4e5c71174b991b0b1b63f5a8539d4449e10a08275be0454646586527f014e6374d23fc81a10b61fd108e7b0e59003f8d3ed87edd40a722aafbc1c2635815261020083015185526112e289898989612c69565b7f2a195965e3a4ebe550289af22bb4c1118e21dc2c74be94ad6455e8f6eb70c8c486527f12024e0b3b82946c93024f8e1159da64dc1d3c72c49929836a5f2577d5a0ed688152610220830151855261133c89898989612c69565b7f1f679e8223e56ae364c7fe5b1eb44e3b3c66cbf45645c364d308c505539047c986527f2c32d125628fae7d840d3f28e83a7fa88112f60ee52f5f86fba53c08e474ff698152610240830151855261139689898989612c69565b7f1b73d0bdb2a03d112f31e25b60799a767fb82a9d6418db824c632ffba80be47d86527f21b9840d5d347552e43ea2e7bd19560353b633a278b602c6074025ddb9f63a21815261026083015185526113f089898989612c69565b7f16b45c0468819f85893ab1c4877c4fe4f49c146b976419b48aa07a0f6cbfb2e286527f06b26b18879ce8c03298c0302e22e9be3407e4b50aa15e3153b0eea99ce024148152610280830151855261144a89898989612c69565b7f1fe6017431f3e3861894f3e1871a3627f3fc61c832f3e951b3e55c86c4b9615886527f2236d30c0a8738dcac59bc76c975d2ac9c9f1347adfc85c977fc196f4a963f5e81526102a083015185526114a489898989612c69565b7f2fd10aed9958e2d8257e4a70a742fa4774402f36a25babac21c8e0b5f661c12886527f0f8a616d021292af83c9631904c885899f5fe78a5489c14462c97f8472ce5bbf81526102c083015185526114fe89898989612c69565b7f280a41e1efcd026c87f851e0180aad3ac57df1f93286a57f53c400268d8752c386527f1633532825ddc9c0da04246a44b706dcfd57ae2f4c1bb69738ff8433d5b2a8bb81526102e0830151855261155889898989612c69565b7e027cbc9193ee97f7eec57e57cb0ff7347cc0b2586a1637f4ce954bea3ff97186527f1c897b0f8a07cbc7a4b69597227129b4a12ba68e1926ecc7a45a4ec4bdc5bf07815261030083015185526115b189898989612c69565b7f1b1da35eea8e3139d38e9db84386f59853a18040d1a2216b74679e08c191a01c86527f0bfab57806284de52685f6dda04330043efee9399c75b78e48b5b1d7cb80038e8152610320830151855261160b89898989612c69565b7f012154f85b76ea46de9dc3f61d7c053aa9a583e3e2e57d6a076db599b1326a2f86527f1d25427c48b7647c1efe27b5e7da3240ee333d288ebabeb8b45e30c113c6474e8152610340830151855261166589898989612c69565b7f111fb275c27d543c507e0c685728727d2344f736a345419dd396d083296211ed86527f01c636dbb603223ca61aee282e75c2ee554f6639e813f990cc7e045128e9ba6e815261036083015185526116bf89898989612c69565b7f0e3ef51ec2992fd4fd4e08d2fc6c02cb6586ec574edec92b74583bd38cc15cae86527f0eeb3ece8b4b83ce8946832b6dd7f35204669e47ccd8b1fc31cba6c71808f6898152610380830151855261171989898989612c69565b7f0a7e2bd7bb8aeb9e84739db84898a9115aa023c279d2df4536366e445e618b1e86527f0141bc992ed56ad3af847ed62afe254e174e6df8efbc36cf3314adad1244b42381526103a0830151855261177389898989612c69565b7f0f2ecde94b061c256edb823ac557ce52f907f612791c85a2e66fb888ce8a417b86527f1c09474255a3b4c33f9452b362e6352c65acb1406a454a1d4b212538d529ed9a81526103c083015185526117cd89898989612c69565b7f1a2a4a634641112a1b940ba3b089193dfde76611dc7a7c29538a0f93bbdaf83086527f1752d5a3839dedbad8cd819b7b86a82982d1c7663453d236c559353725c2901381526103e0830151855261182789898989612c69565b7f2e9b2e2e4921cd57e24d3215d41cfa43545b0fa8907380f2b4eca856b242ace086527f192ca02d2e86b7636626a919c871396ba8108cc7f2358ded277a32ed4ba10d4b8152610400830151855261188189898989612c69565b7f1266b7cbb61c28d580a6aa8e4a6b3455bf5c925fe9321c0b0afd01596c4a950586527f0f945b9129e6749912477338802d286af2f6aca2e71cdf199f387d570acf5f10815261042083015185526118db89898989612c69565b7f1be6c06af2b7182fc509c0c72a3874173c0e9b8ef208c89a6ffcbe343f74440a86525201519052612c69565b51159081159161195d575b50611944575b50506119259051612cba565b9451908451908501519160606040870151955196015196612ed3565b90565b519193506119259161195591612d8d565b92905f611919565b90505115155f611913565b806119a17f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161199a6119a6948e610779565b5110610a85565b610749565b610c2e565b6119b36100d3565b906119bc6100f8565b5f81525f602082015282526119cf6107a0565b60208301526119dc6107a0565b60408301526104896107a0565b6119f16119ab565b906119fa6100f8565b7f3059a4f6581fbdcc0d5e847306a4862568fbf62d22d49958fc3902e4bc379ef381526020907f1dd7c04824ae7a26cbb4bb2e8e647030df4de01e51764344c9da30b1ac0317c8828201528352611a4f6100f8565b7f0f98f7aa65c680ca7cd4b7f95afc5f6827e95398c599befdd9a9eca741e46b6181527f0a6f18525c7167edf6945aa57ecf8e0dde824c50912f1fe71574e86908579b6882820152611a9f6100f8565b7f1d1dacfe7971320b875aa2dbcdafb33d4141ca0b0435904e1e2ead83b600d26b81527f1e0cdae1aa15580307c121c8518d1b513fb8bfc62718065a60e88eee79d0288d83820152611aef6100f8565b9182528282015281840152611b026100f8565b7f1887c867c4428fd8c7157ac7f5e81a19271ea37ac336aa87203e65bd77cdcad281527f10d21089c03935120870563d17d271a9165f3d541cf4b41a450b8c3741e8442382820152611b526100f8565b7f105ceb8102cb4bd76c903c3f045988d7407aab02a26e2b0ac08c58af1edec5a481527f0b32e41ba74a1a65c885129ca2c3c87475d584c75ebc553cb79d4468de6483a883820152611ba26100f8565b918252828201526040840152611bb66100f8565b907f04e9e06a4684b3f9cfea22a0b5d19239c957ba0b12a17f2d9dc9d1e63f9ae49482527f0ef0df2626365d3222024595b1cd400614d2db4a442bb59f5ab585b4717528f881830152611c076100f8565b907f239dd78f7b5dba6a6d81f994b3060a73e4d7602aeb8909fd9785a0f1e04367e382527f178fb89664e86e6758f974887c6d9d19cd52b518c16d799e75556a7ae9a2582981830152611c586100f8565b9283528201526060830152565b9091939293611c726107cc565b918051602080920151611c836100f8565b918252828201528352611c946100f8565b938051518552611ca5815160200190565b5182860152611cb682610b236100f8565b5182820152611cc36100f8565b94855281850152808301938452808251920151611cde6100f8565b9283528183015260408301918252611d847f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47611d1d8186515110610825565b611d2c81848751015110610871565b611d3a8187515151106108bd565b611d4a8184885101515110610909565b611d5a81610bf488515160200190565b611d6c81610c0d858951015160200190565b611d7981855151106109ed565b828451015110610a39565b5f5b602181106129b25750946119419495611925611da06129e9565b946129ac611dac6100f8565b80955f82528582015f8152611dbf6106db565b91611dc86106eb565b907f305c9c1aa4a3294d7d6f331d65dc097fd9b9011350a6065eed3d56ad4d48a5e2611df26100f8565b935f85525f8b8601527f2d704aa2e65d5ad168e2ebdd814a37bf7f58961077a78e2ce2eea371cf886b0e8752527f05595e70b8c63dfb8fe2f8adb49c225ee5e6f783b5736f3221d423194db5585d8252610400898301917e7f03a8f871280b33c0292e973247afd9cddfa419e978678bde69323baece8383527f0e4ddacfcf167969963d2bb01ca92fa86b4bfd92c37917bad4ab760f0279625081519360408601948552611ea289898989612c69565b7f2cbe10c7c83f6dbe1bc89736f5dc9a9b91e55be6941a4b99b058acd8001fb00486527f1500351867036612a9db15b6f7d4198993f31565af0610ed3fda8d92ffb5e67181528c8301518552611efa89898989612c69565b7f2ff215cfa1c7c99fc0b382d9d7225a0636ccd9a01be83959da430a3a25d4481f86527f2918236b7c008f70fc98cc3bcc41eb60fb8b85d02b4e83100de7a9a7eed34645815260408301518552611f5389898989612c69565b7f0943a399c312616b46deee38e49b364b3449d7bab638b580df78aece26ecedf186527f11c937747adbd7b45585d385c0174241e937dce9fa818ca66d00f550b3f3d128815260608301518552611fac89898989612c69565b7f05dd54c0736f8a8d838a097e3151776cc6f602439ecc7833d223dc6cc69d585186527ee6465472f5b3647daa18848088f62f4fe1e57c401172d39f45b827bcc898f781526080830151855261200489898989612c69565b7f0d64a91e0e28a2e96b12a3211ebd9f66d854efbc1bd17fccc28e33993722b96d86527f0b30126ec8f40991e90ef34a78e10acb9848fe65e84547e64346fbaebafc9a98815260a0830151855261205d89898989612c69565b7f08272a78392bca7c2597f09f39daf6f7129808e6a6b34a49239dbf2a264e4e3b86527f02ac17971af65a980f6ab150b8ebaf573008d90c0af4eeed28d50374e8eed16b815260c083015185526120b689898989612c69565b7f19e3f8ff1265325376056bd2155edf79762433ec7b24c2196701da40ff2e6b3186527f0b33297cf3ae84083dab64e559bccd29e271c3e7d9ba307b7d623d223d091ead815260e0830151855261210f89898989612c69565b7f01341f47e05793a19ea7b92ff3b84c73f7223d56104d070f246e00eb1db7967986527f052fb71e652150885399cfb863b33f0dc0dfe9b279d0bf29df0fc403810fdb178152610100830151855261216989898989612c69565b7f04e2785630031d901e87c72d18c1e526142d7b79ee5b4360f5f9373d385aa1be86527f13fdbcc7f866114bdd363bc99c54b3ea0921b9b5526e46885291a00f8f9feea7815261012083015185526121c389898989612c69565b7f0bc888012014ac70c1692250c46020392de91756724c6c890edbc8d860450b8086527f02ce5d7f6c5c1ec90a48c08531305543ef94f25d0d03f67124280afb560406d48152610140830151855261221d89898989612c69565b7f0aee169033d6ddce5c5dde351a6ce45eb60dc3018752274e14f68e3f19a5359686527f1481dacc3a815550ede26690b83395cb031c17fb4aca75baa0a74acc404233518152610160830151855261227789898989612c69565b7f1c24a404b575734133f0c03bbf71c74c5b03a34f1d0817662c7d9293eaecaad586527f10af37e497d439239dfdab04bce89b1eaeaa12bc5f327129816a7a3841863fdd815261018083015185526122d189898989612c69565b7f14a256de1a2c7bb25672a1acc5406b90543c8a3b8c7c6e0a1895f019171141a886527f08f0539c9fd5ef363053e6560e4769e20e56dd0a510c30dce8adab0230c5fdb181526101a0830151855261232b89898989612c69565b7f082d61eb34a0a6544527e7db6b9bd16a8f6488733c83bee559ec5378191c93ba86527f144b7ab9c8fd2fb71b51c102820f2b08303be60f9fdd313e68f412d3f027a82081526101c0830151855261238589898989612c69565b7f22510e5ce22c30374993b2a360ceed3bdc20bd64b8d14cb3baedf76ddbd8062386527f0c0c88dfbf63ebc976d642a63c3d22288c546570b101f0219b3e2f3af5bedcfb81526101e083015185526123df89898989612c69565b7f2c71d775cc194f6e13408a12a33cb48babccfee137654d1443371de1d0f30c0c86527f1ba219dea8d4ffd8339c1c10cda690451c10fb5058f36ce7e1407118d871cc808152610200830151855261243989898989612c69565b7f14e7d115c5cfbe3c075697f305b8660abf41c5725a40557d3e14c9703aef64c286527f0cbc84b02d09b3f498b122ab5819248195aea678e0a41e744967da6bd8d0ce118152610220830151855261249389898989612c69565b7f0332f7d5660e970f229a174367929acabfa2f9fdab763460fd7acebddd944dde86527f15be1ce817121a7c25340b8d9c50a584a179d3dffd489f54311a12f922a6942f815261024083015185526124ed89898989612c69565b7f0257933903a2e91846df829f8084008ddf5fc35dd8d4acdebd426bff0d97e2a386527f17e9653840e81e1a68076e0c5f8c89f61463791e918991df86c86f63dccd93918152610260830151855261254789898989612c69565b7f106f1170be9c02c979b3d6e1d43737530d6bfc444c16df873400384d39e393be86527f1c2b9f619d809bb543e712ac0ee22cc3c6aa99ae73c97246c9769c9c98713fc5815261028083015185526125a189898989612c69565b7f131eb8c00ed76432c870a74c71365748a51807c021e678beb083b0e7e8b5b61186527f2491a76ab72146d0aeb330815df908ad5dd6cd86201e97d220b63d0d8d0f3ac481526102a083015185526125fb89898989612c69565b7f2561f4abb9fabeeb813dcc6d4d487d8f6e36fdd18805e785cccdf2b0a2ff085786527f2e6269f87539d6b464a25b6bd4522d1e2b78c3918f48e79de55dd640261faa4281526102c0830151855261265589898989612c69565b7f2e485df27f23a93b97e296061758e7dd3d34c4722c6fd7ae249433c55d259adc86527f1614f76a407ac31a5acb91266c2c7f54166ee17112e69f0b5e5fad32dafe5f6581526102e083015185526126af89898989612c69565b7f153af4e0fe4af748819ca675d8781da95111510763de4bec8abf25bca637703b86527f0b1f5a812c51999ebc7ac97de6ab2409b894ad5fb02d45f0798acc2548344cb98152610300830151855261270989898989612c69565b7f2c69e0646f6bfc70dfd02cf64d0b781ab481cafbd190dba9ee603f8160c44dcd86527f126015936956b109beba47938f9808cd9eed7ba5fc4531e6f6f267cadb13f4f88152610320830151855261276389898989612c69565b7f22c6d8b6cf6965d431abf72b985b44f1d0831026a43d6dc8cbcb9ca85ab4a0bc86527f19fd6ce3da2b55331cdd361a63f29e95c52f07bcf9cbe355077e5141bf020d83815261034083015185526127bd89898989612c69565b7f0cc996a6a427bcf59dad5cb6a2da92164e142372347a8ca5b1b3b32d8b20a0ef86527f232f08e45f51e15d57617fc960278b4dd236ed78e9014d43950751ea862841f18152610360830151855261281789898989612c69565b7f1e03c25c13870ae3e127e009be017aa0f47c7b53fc8636bd519ad68f035aa55c86527f04d8795eee1d4bcb8a4042ed861d91024ec5ce76c4fdac892d0c0047987451998152610380830151855261287189898989612c69565b7f2690cf34bdf3837f3036c3c61e73f94f8026f6a6e9be13695cf81ccebbac7ca886527f0db77d728541f6ab723d2dc8389a97864f9e61349120d35d76c004579c3fc10881526103a083015185526128cb89898989612c69565b7f10f3808b8fb7eb5be9d22fa5e7b4599e94116d5803607ae38bd3c637c10224f286527f06cb766b59e904c5b47098c0f98af9c4444f614cf303f1c939fd24b6bd60cc9c81526103c0830151855261292589898989612c69565b7f1610f9fbade90d90feada79ae229d67175dee93355fbbf229133ce0d6e75e3a186527f1a3084c2af6e7f823d2044866e00b80af74b5586f26c9685943786f355712ddd81526103e0830151855261297f89898989612c69565b7f1b88a7f08e12e3e28b9b10c0c0cbfd8d7df8b8a8fae1840b33c1cd4d24c8b23c86525201519052612c69565b51612cba565b806119a17f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161199a6129e4948b61078f565b611d86565b6129f16119ab565b906129fa6100f8565b7f0a3a3884405b8d1fe46693685f02ba163634fd63d14bf91b6a433825b9ed6b5a81526020907f111fc830b029cfb2c94e450b570cf3be3eac81076213c2dcb1e1059330c605bf828201528352612a4f6100f8565b7f23ab779b99bf99c421500d8fe70c4e84fc1ff6eefdf3e92d8f581d046cb3eab781527f1611f26f3d9d6b19c4a418d02f19f6796be688f08507bc59ee5f9862dd46fa5b82820152612a9f6100f8565b7f2d34a3d654ca9ea36195f8167d653fa7240b0af8acad4b224aed268f9d8756ff81527f178cda417a663a79267fba64b28caf8fc8484866bfe0f423cb8d3b7da164d7f983820152612aef6100f8565b9182528282015281840152612b026100f8565b7f1f682eee4eeb25b38c3bff07fad9aaeb8c1ae87a95472a7819a57fd8b37a6e1581527f0db20bc4434468f4ce7f5888da80c6013c5392645400eee1ddbb77b0696ea1a782820152612b526100f8565b7f01979b2d16e0fb974244f72e399fd4d24be132523f4aeb010c75f26b6452d53c81527f21900fdcdfde4102dbbcd9525e925c0f4ea5317aefc7a1c350753b5c9741ebd583820152612ba26100f8565b918252828201526040840152612bb66100f8565b907f04969a13dd24e7586c1e7e668f9be1cfab2bfb7baf9e48cd94428a55b4cfb89882527f3026f4334a515ea181839681e5a601e08615013a7355b0a0ad1c6ffce279eb1681830152612c076100f8565b907f0987e27c310f4a785adc7dfc5324848dc4b1b4957907733a04c889777c88a78582527f13c07cb3a59387f85f315e9b41060f8a993a3c3d22113439d63f9be212afc23481830152611c586100f8565b90600481101561078a5760051b0190565b90929160608460806107cf19946007865a01fa15612cb857600660c0926020606096865185528187015182860152805160408601520151868401525a01fa8015612cb857612cb690612d41565b565bfe5b5f6020612cc56100f8565b8281520152805190811580612d35575b15612cf0575050612ce46100f8565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4790819006810390811161065d57612d2a6100f8565b918252602082015290565b50602081015115612cd5565b15612d4857565b60405162461bcd60e51b815260206004820152601260248201527f70616972696e672d6164642d6661696c656400000000000000000000000000006044820152606490fd5b60609092919260c0612d9d6100f8565b915f83525f60208401526020839681612db46100d3565b936080368637805185520151828401528051604084015201518482015260066107cf195a01fa8015612cb857612cb690612d41565b60405190610320820182811067ffffffffffffffff8211176100f35760405260188252610300366020840137565b9060068202918083046006149015171561065d57565b906001820180921161065d57565b906002820180921161065d57565b906003820180921161065d57565b906004820180921161065d57565b906005820180921161065d57565b805182101561078a5760209160051b010190565b15612e8e57565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b9491959692909396612ee36100d3565b95865260209788978888015260408701526060860152612f016100d3565b9384528584015260408301526060820152612f1a612de9565b915f5b60048110612f5557505050610300612f33610710565b9384920160086107cf195a01fa8015612cb857612f4f90612e87565b51151590565b6130279192939450612f6681612e17565b612f708285612c58565b5151612f7c8288612e73565b5286612f888386612c58565b510151612f9d612f9783612e2d565b88612e73565b52612fa88286612c58565b515151612fb7612f9783612e3b565b52612fcd612fc58387612c58565b515160200190565b51612fda612f9783612e49565b5286612fe68387612c58565b51015151612ff6612f9783612e57565b5261302161301b6130148961300b868a612c58565b51015160200190565b5192612e65565b87612e73565b52610749565b9084939291612f1d56fea26469706673582212200cbb34895528328b369fdbe0a71127c10fed5266fe321703b5d2f42c7a8f73ca64736f6c63430008140033",
}

// BeaconVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use BeaconVerifierMetaData.ABI instead.
var BeaconVerifierABI = BeaconVerifierMetaData.ABI

// BeaconVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BeaconVerifierMetaData.Bin instead.
var BeaconVerifierBin = BeaconVerifierMetaData.Bin

// DeployBeaconVerifier deploys a new Ethereum contract, binding an instance of BeaconVerifier to it.
func DeployBeaconVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BeaconVerifier, error) {
	parsed, err := BeaconVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BeaconVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BeaconVerifier{BeaconVerifierCaller: BeaconVerifierCaller{contract: contract}, BeaconVerifierTransactor: BeaconVerifierTransactor{contract: contract}, BeaconVerifierFilterer: BeaconVerifierFilterer{contract: contract}}, nil
}

// BeaconVerifier is an auto generated Go binding around an Ethereum contract.
type BeaconVerifier struct {
	BeaconVerifierCaller     // Read-only binding to the contract
	BeaconVerifierTransactor // Write-only binding to the contract
	BeaconVerifierFilterer   // Log filterer for contract events
}

// BeaconVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type BeaconVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BeaconVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BeaconVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BeaconVerifierSession struct {
	Contract     *BeaconVerifier   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BeaconVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BeaconVerifierCallerSession struct {
	Contract *BeaconVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BeaconVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BeaconVerifierTransactorSession struct {
	Contract     *BeaconVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BeaconVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type BeaconVerifierRaw struct {
	Contract *BeaconVerifier // Generic contract binding to access the raw methods on
}

// BeaconVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BeaconVerifierCallerRaw struct {
	Contract *BeaconVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// BeaconVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BeaconVerifierTransactorRaw struct {
	Contract *BeaconVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBeaconVerifier creates a new instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifier(address common.Address, backend bind.ContractBackend) (*BeaconVerifier, error) {
	contract, err := bindBeaconVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifier{BeaconVerifierCaller: BeaconVerifierCaller{contract: contract}, BeaconVerifierTransactor: BeaconVerifierTransactor{contract: contract}, BeaconVerifierFilterer: BeaconVerifierFilterer{contract: contract}}, nil
}

// NewBeaconVerifierCaller creates a new read-only instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierCaller(address common.Address, caller bind.ContractCaller) (*BeaconVerifierCaller, error) {
	contract, err := bindBeaconVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierCaller{contract: contract}, nil
}

// NewBeaconVerifierTransactor creates a new write-only instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*BeaconVerifierTransactor, error) {
	contract, err := bindBeaconVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierTransactor{contract: contract}, nil
}

// NewBeaconVerifierFilterer creates a new log filterer instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*BeaconVerifierFilterer, error) {
	contract, err := bindBeaconVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierFilterer{contract: contract}, nil
}

// bindBeaconVerifier binds a generic wrapper to an already deployed contract.
func bindBeaconVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BeaconVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BeaconVerifier *BeaconVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BeaconVerifier.Contract.BeaconVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BeaconVerifier *BeaconVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.BeaconVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BeaconVerifier *BeaconVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.BeaconVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BeaconVerifier *BeaconVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BeaconVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BeaconVerifier *BeaconVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BeaconVerifier *BeaconVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCaller) VerifyBlsSigProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifyBlsSigProof", a, b, c, commit, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyBlsSigProof(&_BeaconVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyBlsSigProof(&_BeaconVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCaller) VerifyCommitteeRootMappingProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifyCommitteeRootMappingProof", a, b, c, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, a, b, c, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, a, b, c, input)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCaller) VerifySignatureProof(opts *bind.CallOpts, signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifySignatureProof", signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySignatureProof(&_BeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySignatureProof(&_BeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCaller) VerifySyncCommitteeRootMappingProof(opts *bind.CallOpts, sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifySyncCommitteeRootMappingProof", sszRoot, poseidonRoot, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// BitMathMetaData contains all meta data concerning the BitMath contract.
var BitMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212204fcad26d51f9e2fcbaefd77f37d42d8bc5270fb1a65cdf7f8e7f3e422596f97b64736f6c63430008140033",
}

// BitMathABI is the input ABI used to generate the binding from.
// Deprecated: Use BitMathMetaData.ABI instead.
var BitMathABI = BitMathMetaData.ABI

// BitMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BitMathMetaData.Bin instead.
var BitMathBin = BitMathMetaData.Bin

// DeployBitMath deploys a new Ethereum contract, binding an instance of BitMath to it.
func DeployBitMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BitMath, error) {
	parsed, err := BitMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BitMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BitMath{BitMathCaller: BitMathCaller{contract: contract}, BitMathTransactor: BitMathTransactor{contract: contract}, BitMathFilterer: BitMathFilterer{contract: contract}}, nil
}

// BitMath is an auto generated Go binding around an Ethereum contract.
type BitMath struct {
	BitMathCaller     // Read-only binding to the contract
	BitMathTransactor // Write-only binding to the contract
	BitMathFilterer   // Log filterer for contract events
}

// BitMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type BitMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BitMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BitMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BitMathSession struct {
	Contract     *BitMath          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BitMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BitMathCallerSession struct {
	Contract *BitMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// BitMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BitMathTransactorSession struct {
	Contract     *BitMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// BitMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type BitMathRaw struct {
	Contract *BitMath // Generic contract binding to access the raw methods on
}

// BitMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BitMathCallerRaw struct {
	Contract *BitMathCaller // Generic read-only contract binding to access the raw methods on
}

// BitMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BitMathTransactorRaw struct {
	Contract *BitMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBitMath creates a new instance of BitMath, bound to a specific deployed contract.
func NewBitMath(address common.Address, backend bind.ContractBackend) (*BitMath, error) {
	contract, err := bindBitMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BitMath{BitMathCaller: BitMathCaller{contract: contract}, BitMathTransactor: BitMathTransactor{contract: contract}, BitMathFilterer: BitMathFilterer{contract: contract}}, nil
}

// NewBitMathCaller creates a new read-only instance of BitMath, bound to a specific deployed contract.
func NewBitMathCaller(address common.Address, caller bind.ContractCaller) (*BitMathCaller, error) {
	contract, err := bindBitMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BitMathCaller{contract: contract}, nil
}

// NewBitMathTransactor creates a new write-only instance of BitMath, bound to a specific deployed contract.
func NewBitMathTransactor(address common.Address, transactor bind.ContractTransactor) (*BitMathTransactor, error) {
	contract, err := bindBitMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BitMathTransactor{contract: contract}, nil
}

// NewBitMathFilterer creates a new log filterer instance of BitMath, bound to a specific deployed contract.
func NewBitMathFilterer(address common.Address, filterer bind.ContractFilterer) (*BitMathFilterer, error) {
	contract, err := bindBitMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BitMathFilterer{contract: contract}, nil
}

// bindBitMath binds a generic wrapper to an already deployed contract.
func bindBitMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BitMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BitMath *BitMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BitMath.Contract.BitMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BitMath *BitMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BitMath.Contract.BitMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BitMath *BitMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BitMath.Contract.BitMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BitMath *BitMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BitMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BitMath *BitMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BitMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BitMath *BitMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BitMath.Contract.contract.Transact(opts, method, params...)
}

// BlockChunksMetaData contains all meta data concerning the BlockChunks contract.
var BlockChunksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateAnchorBlockProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"}],\"name\":\"UpdateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorBlockProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"}],\"name\":\"historicalRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"claimedBlkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[7]\",\"name\":\"merkleProof\",\"type\":\"bytes32[7]\"}],\"internalType\":\"structIBlockChunks.BlockHashWitness\",\"name\":\"witness\",\"type\":\"tuple\"}],\"name\":\"isBlockHashValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"updateAnchorBlockProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"nextNumFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateOld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateRecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234610162575f8054909190336001600160a01b0382167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08580a36001600160a81b0319163360ff60a01b19811691909117835582526001602052604082205460ff166101205750600254906801000000000000000082101561010c5760018201806002558210156100f8576040916002825260208220013360018060a01b0319825416179055338152600160205220600160ff198254161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f86020604051338152a1604051611e0490816101678239f35b634e487b7160e01b81526032600452602490fd5b634e487b7160e01b81526041600452602490fd5b62461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f80fdfe60c06040526004361015610011575f80fd5b5f608060a0528060a05152803560e01c908163158535ff1461130f575080631d8441a1146112495780633f4ba83a1461112e57806346fbf68e146107075780634f4fef181461110d57806350a26d4814610e8757806352cfc56014610c5d578063544f73a414610a4257806358a16b4414610a215780635c975abb146109f95780635d727e97146109b1578063677625f2146107a05780636b2c0f55146107675780636ef8d66d1461074a57806380f51c121461070757806382dc1ec4146106ce5780638456cb59146105975780638da5cb5b1461056b578063a036e79914610517578063b551a187146104b8578063e6c6fcec14610464578063e79b7a5114610404578063ec4ffc5214610334578063f2fde38b14610244578063f5cec6af146101fc578063fabc74f5146101975763fd1190ea1461014f575f80fd5b3461019057602036600319011261019057600435600454811015610190576001600160a01b03610180602092611386565b9190546040519260031b1c168152f35b60a0515180fd5b34610190576020366003190112610190576001600160a01b036101b86113ec565b1660a0515152600360205260a0515160ff6040822054166040519060038110156101e457602092508152f35b634e487b7160e01b8352602160045260a05151602490fd5b346101905760203660031901126101905767ffffffffffffffff61021e6113bb565b1660a0515152600560205260206001600160a01b03604060a05151205416604051908152f35b346101905760203660031901126101905761025d6113ec565b60a0515154906001600160a01b038083169161027a33841461151f565b169081156102c9578173ffffffffffffffffffffffffffffffffffffffff1960a0515194161783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b34610190576040366003190112610190577ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f61036e6113bb565b6103766113d6565b906001600160a01b036103908160a051515416331461151f565b67ffffffffffffffff821660a05151526005602052604060a051512090831673ffffffffffffffffffffffffffffffffffffffff198254161790556103fa604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b0390a160a0515180f35b346101905761041236611496565b6001600160a01b039061042c8260a051515416331461151f565b60a051515b815181101561045d57806104538461044c61045894866118f7565b5116611b2d565b6118e9565b610431565b60a0515180f35b346101905761047236611496565b6001600160a01b039061048c8260a051515416331461151f565b60a051515b815181101561045d5780610453846104ac6104b394866118f7565b5116611957565b610491565b34610190576040366003190112610190576104d16113bb565b6024359063ffffffff82168092036101905767ffffffffffffffff1660a0515152600760205260a05151906040822091526020526020604060a051512054604051908152f35b346101905761052536611496565b6001600160a01b039061053f8260a051515416331461151f565b60a051515b815181101561045d57806104538461055f61056694866118f7565b5116611c12565b610544565b346101905760a0515180600319360112610594576001600160a01b036020915416604051908152f35b80fd5b346101905760a05151806003193601126105945733905260016020908082526105c960ff604060a0515120541661190b565b60a051515460ff8160a01c166106895760ff60a01b197401000000000000000000000000000000000000000091161760a05151557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a160a05151815b6106375760a0515180f35b60045481101561068457806001600160a01b0361065661067e93611386565b919054600392831b1c1660a05151528452604060a0515120600260ff198254161790556118e9565b8161062c565b61045d565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b346101905760203660031901126101905761045d6106ea6113ec565b6107026001600160a01b0360a051515416331461151f565b611b2d565b34610190576020366003190112610190576001600160a01b036107286113ec565b1660a05151526001602052602060ff604060a051512054166040519015158152f35b346101905760a05151806003193601126105945761045d33611c12565b346101905760203660031901126101905761045d6107836113ec565b61079b6001600160a01b0360a051515416331461151f565b611c12565b34610190576020806003193601126101905767ffffffffffffffff6004358181116101905736602382011215610190578060040135918211610997578160051b90604051926107f185840185611474565b835260249181018201908484013683116101905783869201905b83821061098057505050506001600160a01b0361082f8160a051515416331461151f565b60a051515b835181101561045d578161084882866118f7565b51168060a0515152600380875260a0515160ff6040822054169082821015610969575061092557600454906801000000000000000082101561090c57827fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849289926108e261090797966108c2600194858101600455611386565b90919082549060031b916001600160a01b03809116831b921b1916179055565b8260a05151528352604060a05151209060ff19825416179055604051908152a16118e9565b610834565b85634e487b7160e01b60a0515152604160045260a05151fd5b60405162461bcd60e51b8152600481018890526011818701527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b9052602160045260a051518690fd5b82809161098c84611402565b81520191019061080b565b634e487b7160e01b60a05151526041600452602460a05151fd5b346101905760203660031901126101905767ffffffffffffffff6109d36113bb565b1660a0515152600660205260206001600160a01b03604060a05151205416604051908152f35b346101905760a05151806003193601126105945760ff6020915460a01c166040519015158152f35b346101905760a0515180600319360112610594576020600254604051908152f35b3461019057610180366003190112610190576044358015610c1857607f610a676118c4565b1690610a7a82610a756118c4565b6115b6565b6004359067ffffffffffffffff8216820361019057610abc9167ffffffffffffffff165f52600760205263ffffffff60405f2091165f5260205260405f205490565b908115610bd3579060a05151915b60ff83166007811015610b6d5784811c600116610b3c57610aea906118d7565b356040519060208201928352604082015260408152610b0881611444565b519020915b60ff809116908114610b225760010191610aca565b634e487b7160e01b60a05151526011600452602460a05151fd5b610b45906118d7565b35906040519060208201928352604082015260408152610b6481611444565b51902091610b0d565b50906084359163ffffffff8316830361019057610bb9610bc7602094604051928391878301956064358791604493918352602083015263ffffffff60e01b9060e01b1660408201520190565b03601f198101835282611474565b51902014604051908152f35b60405162461bcd60e51b815260206004820152601a60248201527f626c6b20686973746f7279206e6f742073746f726564207965740000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601a60248201527f636c61696d6564426c6b48617368206e6f742070726573656e740000000000006044820152606490fd5b346101905760a05136600319011261019057610c776113bb565b6044359063ffffffff9081831683036101905767ffffffffffffffff9260643584811161019057610cac903690600401611416565b9390913360a0515152600360205260a0515160ff604082205416906003821015610e6f57509582610d1293607f93610cea6001610d199a9b1461156a565b600182610cf78c8a61182c565b939b819f939b929891610d0c8482161561162c565b856115b6565b16146115e0565b160191838311610b22577fa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e9a6103fa98610dd5610de094610ddb94610d85610db8988f67ffffffffffffffff165f52600760205263ffffffff60405f2091165f5260205260405f205490565b916040519889916020830193602435908591604493918352602083015263ffffffff60e01b9060e01b1660408201520190565b0397610dcc601f19998a8101835282611474565b51902014611678565b8a611710565b6116c4565b6040805160208101868152918101879052600160e71b6060820152606492830181529091610e0e9082611474565b51902091861660a0515152600760205260a05151604081209188169052602052604060a0515120556040519485948590949360809363ffffffff859467ffffffffffffffff60a0860199168552166020840152604083015260608201520152565b634e487b7160e01b9052602160045260a05151602490fd5b3461019057604036600319011261019057610ea06113bb565b67ffffffffffffffff9060243582811161019057610ec2903690600401611416565b9190913360a0515152600360205260a0515160ff604082205416906003821015610e6f57506001610ef3911461156a565b610efd818461182c565b9197929394909663ffffffff988989169360a05185018b8111610b22578b165f19019a808c11610b225780610f3692169b168b146115e0565b610f43607f8a161561162c565b84881660a051515260066020526001600160a01b0380604060a05151205416156110c857602090868a1660a051515260068252604060a051512054169a6024604051809d819363f25b3f9960e01b835260048301525afa998a156110ba5760a051519a611074575b506103fa9695949392610fed92610fe7610ddb937fa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e9d14611678565b89611710565b6040805160208101858152918101869052600160e71b60608201526110158160648101610bb9565b51902091861660a0515152600760205260a0515190604082209152602052604060a0515120556040519485948590949360809363ffffffff859467ffffffffffffffff60a0860199168552166020840152604083015260608201520152565b91969594939299506020823d6020116110b2575b8161109560209383611474565b8101031261019057905198949593949293919291906103fa610fab565b3d9150611088565b6040513d60a05151823e3d90fd5b60405162461bcd60e51b815260206004820152601d60248201527f636861696e20616e63686f722070726f7669646572206e6f74207365740000006044820152606490fd5b346101905760a0515180600319360112610594576020600454604051908152f35b346101905760a051518060031936011261059457339052600160209080825261116060ff604060a0515120541661190b565b60a051515460ff8160a01c16156112045760ff60a01b191660a05151557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a160a05151815b6111b75760a0515180f35b600454811015610684576111fe816001600160a01b036111d78594611386565b919054600392831b1c1660a05151528552604060a05151208360ff198254161790556118e9565b906111ac565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b34610190576040366003190112610190577f4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b6112836113bb565b61128b6113d6565b906001600160a01b036112a58160a051515416331461151f565b67ffffffffffffffff821660a05151526006602052604060a051512090831673ffffffffffffffffffffffffffffffffffffffff198254161790556103fa604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b3461059457602036600319011261059457600435906002548210156105945760206001600160a01b03610180845b6002548110156113725760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156113725760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff821682036113d257565b5f80fd5b602435906001600160a01b03821682036113d257565b600435906001600160a01b03821682036113d257565b35906001600160a01b03821682036113d257565b9181601f840112156113d25782359167ffffffffffffffff83116113d257602083818601950101116113d257565b6060810190811067ffffffffffffffff82111761146057604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761146057604052565b6020806003198301126113d25767ffffffffffffffff916004358381116113d257816023820112156113d2578060040135938411611460578360051b90604051946114e385840187611474565b85526024848601928201019283116113d257602401905b828210611508575050505090565b83809161151484611402565b8152019101906114fa565b1561152657565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b1561157157565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b63ffffffff91821690821603919082116115cc57565b634e487b7160e01b5f52601160045260245ffd5b156115e757565b60405162461bcd60e51b815260206004820152600d60248201527f6e6565642031323820626c6b73000000000000000000000000000000000000006044820152606490fd5b1561163357565b60405162461bcd60e51b815260206004820152601460248201527f6e6565642073746172742066726f6d20313238780000000000000000000000006044820152606490fd5b1561167f57565b60405162461bcd60e51b815260206004820152601360248201527f656e6448617368206e6f7420636f7272656374000000000000000000000000006044820152606490fd5b156116cb57565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b67ffffffffffffffff16915f91838352602093600585526001600160a01b039081604086205416156117e75791839186938652600584526040862054169060446040518096819582946322bb937360e11b8452886004850152816024850152848401378181018301899052601f01601f191681010301915afa9283156117dc57829361179d575b50505090565b9080929350813d83116117d5575b6117b58183611474565b810103126117d1575190811515820361059457505f8080611797565b5080fd5b503d6117ab565b6040513d84823e3d90fd5b60405162461bcd60e51b815260048101879052601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b91909182610160116113d257610180928084116113d257608092610170830135841c610140840135851b1794826101a0116113d2576101c0908382116113d2576101b0850135861c90850135861b1794836101e0116113d25783610200116113d2576101f0850135811c91850135901b179282610220116113d25761021c81013560e01c92610240116113d25761023c013560e01c90565b60243563ffffffff811681036113d25790565b60078110156113725760051b60a40190565b5f1981146115cc5760010190565b80518210156113725760209160051b010190565b1561191257565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611b195715611ad5576004968754965f1990818901988911611ac257835b8a54811015611a7f5786826119b083611386565b905490871b1c16146119ca576119c5906118e9565b61199c565b909192939495969798808210611a5a575b50505087548015611a475797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611a31611a1c83611386565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611a7792611a6a6108c292611386565b905490871b1c1691611386565b5f80806119db565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611bcd5760025468010000000000000000811015611bb957602092611b9d7f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936108c28460016040960160025561133d565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611d8a576002805490915f1991828101908111611d7657908695949392918a975b611ca1575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611d6d578185611cb98c61133d565b929054600393841b1c1614611ce25750611cd98798999a979596976118e9565b97969594611c58565b9293949796959991818310611d48575b5050505081548015611d3457918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611a31611a1c8361133d565b634e487b7160e01b89526031600452602489fd5b611d6493611d586108c29361133d565b9054911b1c169161133d565b5f808080611cf2565b87989950611c5d565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220a62289875d9303ac9ceaa313f8354d0c3153fe9b961948a6001f6950ebf8b8e664736f6c63430008140033",
}

// BlockChunksABI is the input ABI used to generate the binding from.
// Deprecated: Use BlockChunksMetaData.ABI instead.
var BlockChunksABI = BlockChunksMetaData.ABI

// BlockChunksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BlockChunksMetaData.Bin instead.
var BlockChunksBin = BlockChunksMetaData.Bin

// DeployBlockChunks deploys a new Ethereum contract, binding an instance of BlockChunks to it.
func DeployBlockChunks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BlockChunks, error) {
	parsed, err := BlockChunksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BlockChunksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BlockChunks{BlockChunksCaller: BlockChunksCaller{contract: contract}, BlockChunksTransactor: BlockChunksTransactor{contract: contract}, BlockChunksFilterer: BlockChunksFilterer{contract: contract}}, nil
}

// BlockChunks is an auto generated Go binding around an Ethereum contract.
type BlockChunks struct {
	BlockChunksCaller     // Read-only binding to the contract
	BlockChunksTransactor // Write-only binding to the contract
	BlockChunksFilterer   // Log filterer for contract events
}

// BlockChunksCaller is an auto generated read-only Go binding around an Ethereum contract.
type BlockChunksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BlockChunksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BlockChunksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BlockChunksSession struct {
	Contract     *BlockChunks      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BlockChunksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BlockChunksCallerSession struct {
	Contract *BlockChunksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BlockChunksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BlockChunksTransactorSession struct {
	Contract     *BlockChunksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BlockChunksRaw is an auto generated low-level Go binding around an Ethereum contract.
type BlockChunksRaw struct {
	Contract *BlockChunks // Generic contract binding to access the raw methods on
}

// BlockChunksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BlockChunksCallerRaw struct {
	Contract *BlockChunksCaller // Generic read-only contract binding to access the raw methods on
}

// BlockChunksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BlockChunksTransactorRaw struct {
	Contract *BlockChunksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBlockChunks creates a new instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunks(address common.Address, backend bind.ContractBackend) (*BlockChunks, error) {
	contract, err := bindBlockChunks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BlockChunks{BlockChunksCaller: BlockChunksCaller{contract: contract}, BlockChunksTransactor: BlockChunksTransactor{contract: contract}, BlockChunksFilterer: BlockChunksFilterer{contract: contract}}, nil
}

// NewBlockChunksCaller creates a new read-only instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksCaller(address common.Address, caller bind.ContractCaller) (*BlockChunksCaller, error) {
	contract, err := bindBlockChunks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BlockChunksCaller{contract: contract}, nil
}

// NewBlockChunksTransactor creates a new write-only instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksTransactor(address common.Address, transactor bind.ContractTransactor) (*BlockChunksTransactor, error) {
	contract, err := bindBlockChunks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BlockChunksTransactor{contract: contract}, nil
}

// NewBlockChunksFilterer creates a new log filterer instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksFilterer(address common.Address, filterer bind.ContractFilterer) (*BlockChunksFilterer, error) {
	contract, err := bindBlockChunks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BlockChunksFilterer{contract: contract}, nil
}

// bindBlockChunks binds a generic wrapper to an already deployed contract.
func bindBlockChunks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BlockChunksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlockChunks *BlockChunksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlockChunks.Contract.BlockChunksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlockChunks *BlockChunksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.Contract.BlockChunksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlockChunks *BlockChunksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlockChunks.Contract.BlockChunksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlockChunks *BlockChunksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlockChunks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlockChunks *BlockChunksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlockChunks *BlockChunksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlockChunks.Contract.contract.Transact(opts, method, params...)
}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) AnchorBlockProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "anchorBlockProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksSession) AnchorBlockProviders(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.AnchorBlockProviders(&_BlockChunks.CallOpts, arg0)
}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) AnchorBlockProviders(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.AnchorBlockProviders(&_BlockChunks.CallOpts, arg0)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksCaller) HistoricalRoots(opts *bind.CallOpts, chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "historicalRoots", chainId, startBlockNumber)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _BlockChunks.Contract.HistoricalRoots(&_BlockChunks.CallOpts, chainId, startBlockNumber)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksCallerSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _BlockChunks.Contract.HistoricalRoots(&_BlockChunks.CallOpts, chainId, startBlockNumber)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksCaller) IsBlockHashValid(opts *bind.CallOpts, witness IBlockChunksBlockHashWitness) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "isBlockHashValid", witness)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _BlockChunks.Contract.IsBlockHashValid(&_BlockChunks.CallOpts, witness)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _BlockChunks.Contract.IsBlockHashValid(&_BlockChunks.CallOpts, witness)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksSession) IsPauser(account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsPauser(&_BlockChunks.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsPauser(&_BlockChunks.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksSession) NumPausers() (*big.Int, error) {
	return _BlockChunks.Contract.NumPausers(&_BlockChunks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksCallerSession) NumPausers() (*big.Int, error) {
	return _BlockChunks.Contract.NumPausers(&_BlockChunks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksSession) NumProvers() (*big.Int, error) {
	return _BlockChunks.Contract.NumProvers(&_BlockChunks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksCallerSession) NumProvers() (*big.Int, error) {
	return _BlockChunks.Contract.NumProvers(&_BlockChunks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksSession) Owner() (common.Address, error) {
	return _BlockChunks.Contract.Owner(&_BlockChunks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksCallerSession) Owner() (common.Address, error) {
	return _BlockChunks.Contract.Owner(&_BlockChunks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksSession) Paused() (bool, error) {
	return _BlockChunks.Contract.Paused(&_BlockChunks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) Paused() (bool, error) {
	return _BlockChunks.Contract.Paused(&_BlockChunks.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.PauserList(&_BlockChunks.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.PauserList(&_BlockChunks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksSession) Pausers(arg0 common.Address) (bool, error) {
	return _BlockChunks.Contract.Pausers(&_BlockChunks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BlockChunks.Contract.Pausers(&_BlockChunks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BlockChunks.Contract.ProverStates(&_BlockChunks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BlockChunks.Contract.ProverStates(&_BlockChunks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.Provers(&_BlockChunks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.Provers(&_BlockChunks.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.VerifierAddresses(&_BlockChunks.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.VerifierAddresses(&_BlockChunks.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPauser(&_BlockChunks.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPauser(&_BlockChunks.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPausers(&_BlockChunks.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPausers(&_BlockChunks.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddProvers(&_BlockChunks.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddProvers(&_BlockChunks.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksSession) Pause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Pause(&_BlockChunks.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksTransactorSession) Pause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Pause(&_BlockChunks.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePauser(&_BlockChunks.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePauser(&_BlockChunks.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePausers(&_BlockChunks.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePausers(&_BlockChunks.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemoveProvers(&_BlockChunks.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemoveProvers(&_BlockChunks.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksSession) RenouncePauser() (*types.Transaction, error) {
	return _BlockChunks.Contract.RenouncePauser(&_BlockChunks.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BlockChunks.Contract.RenouncePauser(&_BlockChunks.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.TransferOwnership(&_BlockChunks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.TransferOwnership(&_BlockChunks.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksSession) Unpause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Unpause(&_BlockChunks.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksTransactorSession) Unpause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Unpause(&_BlockChunks.TransactOpts)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateAnchorBlockProvider(opts *bind.TransactOpts, _chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateAnchorBlockProvider", _chainId, _provider)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksSession) UpdateAnchorBlockProvider(_chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateAnchorBlockProvider(&_BlockChunks.TransactOpts, _chainId, _provider)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateAnchorBlockProvider(_chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateAnchorBlockProvider(&_BlockChunks.TransactOpts, _chainId, _provider)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateOld(opts *bind.TransactOpts, chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateOld", chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateOld(&_BlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateOld(&_BlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateRecent(opts *bind.TransactOpts, chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateRecent", chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateRecent(&_BlockChunks.TransactOpts, chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateRecent(&_BlockChunks.TransactOpts, chainId, proofData)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateVerifierAddress(&_BlockChunks.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateVerifierAddress(&_BlockChunks.TransactOpts, _chainId, _verifierAddress)
}

// BlockChunksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BlockChunks contract.
type BlockChunksOwnershipTransferredIterator struct {
	Event *BlockChunksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksOwnershipTransferred represents a OwnershipTransferred event raised by the BlockChunks contract.
type BlockChunksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BlockChunksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BlockChunksOwnershipTransferredIterator{contract: _BlockChunks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BlockChunksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksOwnershipTransferred)
				if err := _BlockChunks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) ParseOwnershipTransferred(log types.Log) (*BlockChunksOwnershipTransferred, error) {
	event := new(BlockChunksOwnershipTransferred)
	if err := _BlockChunks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BlockChunks contract.
type BlockChunksPausedIterator struct {
	Event *BlockChunksPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPaused represents a Paused event raised by the BlockChunks contract.
type BlockChunksPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPaused(opts *bind.FilterOpts) (*BlockChunksPausedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPausedIterator{contract: _BlockChunks.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BlockChunksPaused) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPaused)
				if err := _BlockChunks.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePaused(log types.Log) (*BlockChunksPaused, error) {
	event := new(BlockChunksPaused)
	if err := _BlockChunks.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BlockChunks contract.
type BlockChunksPauserAddedIterator struct {
	Event *BlockChunksPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPauserAdded represents a PauserAdded event raised by the BlockChunks contract.
type BlockChunksPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BlockChunksPauserAddedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPauserAddedIterator{contract: _BlockChunks.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BlockChunksPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPauserAdded)
				if err := _BlockChunks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePauserAdded(log types.Log) (*BlockChunksPauserAdded, error) {
	event := new(BlockChunksPauserAdded)
	if err := _BlockChunks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BlockChunks contract.
type BlockChunksPauserRemovedIterator struct {
	Event *BlockChunksPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPauserRemoved represents a PauserRemoved event raised by the BlockChunks contract.
type BlockChunksPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BlockChunksPauserRemovedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPauserRemovedIterator{contract: _BlockChunks.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BlockChunksPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPauserRemoved)
				if err := _BlockChunks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePauserRemoved(log types.Log) (*BlockChunksPauserRemoved, error) {
	event := new(BlockChunksPauserRemoved)
	if err := _BlockChunks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BlockChunks contract.
type BlockChunksProverAddedIterator struct {
	Event *BlockChunksProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksProverAdded represents a ProverAdded event raised by the BlockChunks contract.
type BlockChunksProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BlockChunksProverAddedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BlockChunksProverAddedIterator{contract: _BlockChunks.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BlockChunksProverAdded) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksProverAdded)
				if err := _BlockChunks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) ParseProverAdded(log types.Log) (*BlockChunksProverAdded, error) {
	event := new(BlockChunksProverAdded)
	if err := _BlockChunks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BlockChunks contract.
type BlockChunksProverRemovedIterator struct {
	Event *BlockChunksProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksProverRemoved represents a ProverRemoved event raised by the BlockChunks contract.
type BlockChunksProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BlockChunksProverRemovedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BlockChunksProverRemovedIterator{contract: _BlockChunks.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BlockChunksProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksProverRemoved)
				if err := _BlockChunks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) ParseProverRemoved(log types.Log) (*BlockChunksProverRemoved, error) {
	event := new(BlockChunksProverRemoved)
	if err := _BlockChunks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BlockChunks contract.
type BlockChunksUnpausedIterator struct {
	Event *BlockChunksUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUnpaused represents a Unpaused event raised by the BlockChunks contract.
type BlockChunksUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BlockChunksUnpausedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUnpausedIterator{contract: _BlockChunks.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BlockChunksUnpaused) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUnpaused)
				if err := _BlockChunks.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) ParseUnpaused(log types.Log) (*BlockChunksUnpaused, error) {
	event := new(BlockChunksUnpaused)
	if err := _BlockChunks.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateAnchorBlockProviderIterator is returned from FilterUpdateAnchorBlockProvider and is used to iterate over the raw logs and unpacked data for UpdateAnchorBlockProvider events raised by the BlockChunks contract.
type BlockChunksUpdateAnchorBlockProviderIterator struct {
	Event *BlockChunksUpdateAnchorBlockProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateAnchorBlockProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateAnchorBlockProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateAnchorBlockProvider represents a UpdateAnchorBlockProvider event raised by the BlockChunks contract.
type BlockChunksUpdateAnchorBlockProvider struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateAnchorBlockProvider is a free log retrieval operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateAnchorBlockProvider(opts *bind.FilterOpts) (*BlockChunksUpdateAnchorBlockProviderIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateAnchorBlockProvider")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateAnchorBlockProviderIterator{contract: _BlockChunks.contract, event: "UpdateAnchorBlockProvider", logs: logs, sub: sub}, nil
}

// WatchUpdateAnchorBlockProvider is a free log subscription operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateAnchorBlockProvider(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateAnchorBlockProvider) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateAnchorBlockProvider")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateAnchorBlockProvider)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateAnchorBlockProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateAnchorBlockProvider is a log parse operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateAnchorBlockProvider(log types.Log) (*BlockChunksUpdateAnchorBlockProvider, error) {
	event := new(BlockChunksUpdateAnchorBlockProvider)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateAnchorBlockProvider", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateEventIterator is returned from FilterUpdateEvent and is used to iterate over the raw logs and unpacked data for UpdateEvent events raised by the BlockChunks contract.
type BlockChunksUpdateEventIterator struct {
	Event *BlockChunksUpdateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateEvent represents a UpdateEvent event raised by the BlockChunks contract.
type BlockChunksUpdateEvent struct {
	ChainId          uint64
	StartBlockNumber uint32
	PrevHash         [32]byte
	Root             [32]byte
	NumFinal         uint32
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterUpdateEvent is a free log retrieval operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateEvent(opts *bind.FilterOpts) (*BlockChunksUpdateEventIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateEventIterator{contract: _BlockChunks.contract, event: "UpdateEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateEvent is a free log subscription operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateEvent(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateEvent) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateEvent)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateEvent is a log parse operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateEvent(log types.Log) (*BlockChunksUpdateEvent, error) {
	event := new(BlockChunksUpdateEvent)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the BlockChunks contract.
type BlockChunksUpdateVerifierAddressIterator struct {
	Event *BlockChunksUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the BlockChunks contract.
type BlockChunksUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*BlockChunksUpdateVerifierAddressIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateVerifierAddressIterator{contract: _BlockChunks.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateVerifierAddress)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateVerifierAddress(log types.Log) (*BlockChunksUpdateVerifierAddress, error) {
	event := new(BlockChunksUpdateVerifierAddress)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlsSigVerifierMetaData contains all meta data concerning the BlsSigVerifier contract.
var BlsSigVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[35]\",\"name\":\"input\",\"type\":\"uint256[35]\"}],\"name\":\"verifyBlsSigProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001657611bfb908161001b8239f35b5f80fdfe6040608081526004361015610012575f80fd5b5f803560e01c630cc2676914610026575f80fd5b346100c4576105a03660031901126100c45761004136610120565b9036606312156100c4576100536100db565b908160c4913683116100c457506044905b8282106100ab576100a786610096878761007d36610161565b6100863661019f565b916100903661021f565b93610651565b905190151581529081906020820190565b0390f35b602086916100b936856101df565b815201910190610064565b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906040820182811067ffffffffffffffff8211176100fb57604052565b6100c7565b604051906080820182811067ffffffffffffffff8211176100fb57604052565b806023121561015d576101316100db565b9081604491821161015d576004905b82821061014d5750505090565b8135815260209182019101610140565b5f80fd5b8060e3121561015d576101726100db565b908161010491821161015d5760c4905b82821061018f5750505090565b8135815260209182019101610182565b80610123121561015d576101b16100db565b908161014491821161015d57610104905b8282106101cf5750505090565b81358152602091820191016101c2565b9080601f8301121561015d576101f36100db565b80926040810192831161015d57905b82821061020f5750505090565b8135815260209182019101610202565b80610163121561015d5760405190610460820182811067ffffffffffffffff8211176100fb57604052816105a491821161015d57610144905b8282106102655750505090565b8135815260209182019101610258565b61027d610100565b906080368337565b604051906060820182811067ffffffffffffffff8211176100fb576040526060368337565b604051906020820182811067ffffffffffffffff8211176100fb576040526020368337565b6102d76100db565b906102e06100db565b604036823782526102ef6100db565b60403682376020830152565b610303610100565b9061030c6100db565b5f9081815281602082015283526103216102cf565b602084015261032e6100db565b81815281602082015260408401526103446100db565b9080825260208201526060830152565b634e487b7160e01b5f52603260045260245ffd5b1561036f57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b156103bb57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b1561040757565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561045357565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561049f57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104eb57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b1561053757565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561058357565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f1981146105ea5760010190565b6105c8565b9060238110156106005760051b0190565b610354565b1561060c57565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b949394929190926106606102fb565b81516020809301516106706100db565b9182528382015281526106816100db565b948051518652610692815160200190565b51838701526106b1836106a36100db565b920180515183525160200190565b51838201526106be6100db565b958652828601528181019485528183519301516106d96100db565b93845282840152604081019283528351938281019485516106f86100db565b91825284820152606083019081526107ac7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476107378186515110610368565b610746818787510151106103b4565b610754818a51515110610400565b61076481878b510151511061044c565b61077b816107748b515160200190565b5110610498565b6107948161078d888c51015160200190565b51106104e4565b6107a18188515110610530565b85875101511061057c565b5f5b602381106114e85750906114c197989392916107c8611570565b966107d16100db565b925f845261148884878101985f8a5281996107ea610275565b918a6104406107f7610285565b927f2065b90c648581703a4ef82833653ae713aaf62c2dc4ef26b0a9bbbdf254b48a6108216100db565b955f87525f858801527f0da0d09dcc32c2d20c9905307190ffb91538db928804c70e7ed77639f2cee0fe8952527f2fcf362c494439bcae24ab0ab7dd0bd40825ed18725c1d11d25eeb863f24194884527f184edce371c121d112278a4d1239f9d65421fb00e688d7612320bb5f66e7409d8385017f1a7a0f4ef55687795fa98c4585fc66e26ddea1f6e161a837ef4a4f1ae9c8808b8152825194604087019586526108ce8a8a8a8a6117fd565b7f159c9e6c6ad47c3114dd4bdc88dc34359cae49de8306c8f56c9ba9d56429755e87527f261a0e3bad2b8c7b4057a7708b68ddaa9684eaa9d458088e7a2fe7813e08d06082528301518552610925898989896117fd565b7f1243c2c01b1a238bd0937eed8a5eb5f962eae681000356540ae1cfb36e1e308b86527e816901d1be816971e5f7e84b32a92c58a9f8971ff921adc37884d47db225e281526040830151855261097d898989896117fd565b7f25ebb06beeca9f8b08c511a86423c8f8705f115fe942220b9f8e30d54b016e0686527f1a598b2d183a54a959959d562879ae4b48df2203151d223973543b7d9584c59e8152606083015185526109d6898989896117fd565b7f0ede030d344e453627bd0d2e849cd89947ed04b1825b0d4f7d6a8bf8b6ca5bae86527f01e7b010c4ab8cfc4791d0886bb39e1e8785b51a2a2165514d1fe026b8de24ad815260808301518552610a2f898989896117fd565b7f1f81ffd062f9644e01e392d39b8de8e030afd731c770e58f96050ed1d36d553286527f0ac85a9509ed9a6e21c1e933b10794303a4b77d9fd1fb036e966fef320cb4dad815260a08301518552610a88898989896117fd565b7f2d46add97dc6a65ee2f3dd3ea61060bf9fd510929a701e4cec0913f8ab1cafe386527f1e8e47b54e79299b14dfe604a3c8ce10ee4cb2d09be71e23628c13888c29a254815260c08301518552610ae1898989896117fd565b7f146a85b7d5644a318ee8d2a44d995f580695fb92ade1dc0bbfc84cb4010ac1c386527f1d3734ea6fc621a0710ba60b024e87e0442525b2c77aff46634f6c5c0035e073815260e08301518552610b3a898989896117fd565b7f12664f87a4a89be5df17d8f4cb797e102a083e505835ddfa68bfff968ded011f86527f062c4ef046ea89c77def686012d175292e6cca3adb8dc9e0234bbbe4384e6b1881526101008301518552610b94898989896117fd565b7f22ecd52df7b85f6392fa550619d401fedebde3332b7c8857f3b26caac17f4b7986527f25696ccea69b88905a95af209f6daa0d638426ae494b1b5800d1bb32aa271c3c81526101208301518552610bee898989896117fd565b7ee5e920eb2bd31bc7480c75e93c11a2a8f421af3e287f37a87453a96b4dd6c086527f2b82a4685f51b881675e3e4958242a11585b1aa2211bef1ba101ade59d484fcb81526101408301518552610c47898989896117fd565b7f1bb112783a4bd8e95decec6012a6b0c06d076f07806241e64d5bb279055ce2e386527f03aacbe5b76da6ffe5a38b5f74bb1defdf60afde8f7bed77c2103c7d6d285c4581526101608301518552610ca1898989896117fd565b7e89a49d6c462af5737f4f74e89ee3fd5fcda9b129a6885f4402b7191ce06ecc86527f03670d5e8e16d0f9e9351a53b707cddd87f0df01f7e71f8ef942b35a63c54d8081526101808301518552610cfa898989896117fd565b7f148203b1cf918d850c2e4eb482623111d69a0d149273d88bd472cc2dc667788886527f09e3685cddd844c117894cf1560ee45625a29890eb111e539598ac6c8510b26f81526101a08301518552610d54898989896117fd565b7f038bda99e81e5aee528c18e38ab4a8806508a531d1f22f6618919bffb81f59f686527f14ce622b4ba47284ea8c421b00498ea220fb6f88026998098cbb21d38d8e0b0a81526101c08301518552610dae898989896117fd565b7f0c1641e14f8c4509f0c675448654f877363c981ca8c18363b549cfb115737ea386527f0b8cc9ed761dfbad8b821e125c571ba83a857c405c10df3bdeb64fc9b3248e2a81526101e08301518552610e08898989896117fd565b7f14c11b03d9e6d4e5c71174b991b0b1b63f5a8539d4449e10a08275be0454646586527f014e6374d23fc81a10b61fd108e7b0e59003f8d3ed87edd40a722aafbc1c263581526102008301518552610e62898989896117fd565b7f2a195965e3a4ebe550289af22bb4c1118e21dc2c74be94ad6455e8f6eb70c8c486527f12024e0b3b82946c93024f8e1159da64dc1d3c72c49929836a5f2577d5a0ed6881526102208301518552610ebc898989896117fd565b7f1f679e8223e56ae364c7fe5b1eb44e3b3c66cbf45645c364d308c505539047c986527f2c32d125628fae7d840d3f28e83a7fa88112f60ee52f5f86fba53c08e474ff6981526102408301518552610f16898989896117fd565b7f1b73d0bdb2a03d112f31e25b60799a767fb82a9d6418db824c632ffba80be47d86527f21b9840d5d347552e43ea2e7bd19560353b633a278b602c6074025ddb9f63a2181526102608301518552610f70898989896117fd565b7f16b45c0468819f85893ab1c4877c4fe4f49c146b976419b48aa07a0f6cbfb2e286527f06b26b18879ce8c03298c0302e22e9be3407e4b50aa15e3153b0eea99ce0241481526102808301518552610fca898989896117fd565b7f1fe6017431f3e3861894f3e1871a3627f3fc61c832f3e951b3e55c86c4b9615886527f2236d30c0a8738dcac59bc76c975d2ac9c9f1347adfc85c977fc196f4a963f5e81526102a08301518552611024898989896117fd565b7f2fd10aed9958e2d8257e4a70a742fa4774402f36a25babac21c8e0b5f661c12886527f0f8a616d021292af83c9631904c885899f5fe78a5489c14462c97f8472ce5bbf81526102c0830151855261107e898989896117fd565b7f280a41e1efcd026c87f851e0180aad3ac57df1f93286a57f53c400268d8752c386527f1633532825ddc9c0da04246a44b706dcfd57ae2f4c1bb69738ff8433d5b2a8bb81526102e083015185526110d8898989896117fd565b7e027cbc9193ee97f7eec57e57cb0ff7347cc0b2586a1637f4ce954bea3ff97186527f1c897b0f8a07cbc7a4b69597227129b4a12ba68e1926ecc7a45a4ec4bdc5bf0781526103008301518552611131898989896117fd565b7f1b1da35eea8e3139d38e9db84386f59853a18040d1a2216b74679e08c191a01c86527f0bfab57806284de52685f6dda04330043efee9399c75b78e48b5b1d7cb80038e8152610320830151855261118b898989896117fd565b7f012154f85b76ea46de9dc3f61d7c053aa9a583e3e2e57d6a076db599b1326a2f86527f1d25427c48b7647c1efe27b5e7da3240ee333d288ebabeb8b45e30c113c6474e815261034083015185526111e5898989896117fd565b7f111fb275c27d543c507e0c685728727d2344f736a345419dd396d083296211ed86527f01c636dbb603223ca61aee282e75c2ee554f6639e813f990cc7e045128e9ba6e8152610360830151855261123f898989896117fd565b7f0e3ef51ec2992fd4fd4e08d2fc6c02cb6586ec574edec92b74583bd38cc15cae86527f0eeb3ece8b4b83ce8946832b6dd7f35204669e47ccd8b1fc31cba6c71808f68981526103808301518552611299898989896117fd565b7f0a7e2bd7bb8aeb9e84739db84898a9115aa023c279d2df4536366e445e618b1e86527f0141bc992ed56ad3af847ed62afe254e174e6df8efbc36cf3314adad1244b42381526103a083015185526112f3898989896117fd565b7f0f2ecde94b061c256edb823ac557ce52f907f612791c85a2e66fb888ce8a417b86527f1c09474255a3b4c33f9452b362e6352c65acb1406a454a1d4b212538d529ed9a81526103c0830151855261134d898989896117fd565b7f1a2a4a634641112a1b940ba3b089193dfde76611dc7a7c29538a0f93bbdaf83086527f1752d5a3839dedbad8cd819b7b86a82982d1c7663453d236c559353725c2901381526103e083015185526113a7898989896117fd565b7f2e9b2e2e4921cd57e24d3215d41cfa43545b0fa8907380f2b4eca856b242ace086527f192ca02d2e86b7636626a919c871396ba8108cc7f2358ded277a32ed4ba10d4b81526104008301518552611401898989896117fd565b7f1266b7cbb61c28d580a6aa8e4a6b3455bf5c925fe9321c0b0afd01596c4a950586527f0f945b9129e6749912477338802d286af2f6aca2e71cdf199f387d570acf5f108152610420830151855261145b898989896117fd565b7f1be6c06af2b7182fc509c0c72a3874173c0e9b8ef208c89a6ffcbe343f74440a865252015190526117fd565b5115908115916114dd575b506114c4575b50506114a5905161184e565b9451908451908501519160606040870151955196015196611a67565b90565b519193506114a5916114d591611921565b92905f611499565b90505115155f611493565b806115217f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161151a611526948e6105ef565b5110610605565b6105dc565b6107ae565b611533610100565b9061153c6100db565b5f81525f6020820152825261154f6102cf565b602083015261155c6102cf565b60408301526115696102cf565b6060830152565b61157861152b565b906115816100db565b7f3059a4f6581fbdcc0d5e847306a4862568fbf62d22d49958fc3902e4bc379ef381526020907f1dd7c04824ae7a26cbb4bb2e8e647030df4de01e51764344c9da30b1ac0317c88282015283526115d66100db565b7f0f98f7aa65c680ca7cd4b7f95afc5f6827e95398c599befdd9a9eca741e46b6181527f0a6f18525c7167edf6945aa57ecf8e0dde824c50912f1fe71574e86908579b68828201526116266100db565b7f1d1dacfe7971320b875aa2dbcdafb33d4141ca0b0435904e1e2ead83b600d26b81527f1e0cdae1aa15580307c121c8518d1b513fb8bfc62718065a60e88eee79d0288d838201526116766100db565b91825282820152818401526116896100db565b7f1887c867c4428fd8c7157ac7f5e81a19271ea37ac336aa87203e65bd77cdcad281527f10d21089c03935120870563d17d271a9165f3d541cf4b41a450b8c3741e84423828201526116d96100db565b7f105ceb8102cb4bd76c903c3f045988d7407aab02a26e2b0ac08c58af1edec5a481527f0b32e41ba74a1a65c885129ca2c3c87475d584c75ebc553cb79d4468de6483a8838201526117296100db565b91825282820152604084015261173d6100db565b907f04e9e06a4684b3f9cfea22a0b5d19239c957ba0b12a17f2d9dc9d1e63f9ae49482527f0ef0df2626365d3222024595b1cd400614d2db4a442bb59f5ab585b4717528f88183015261178e6100db565b907f239dd78f7b5dba6a6d81f994b3060a73e4d7602aeb8909fd9785a0f1e04367e382527f178fb89664e86e6758f974887c6d9d19cd52b518c16d799e75556a7ae9a25829818301526117df6100db565b9283528201526060830152565b9060048110156106005760051b0190565b90929160608460806107cf19946007865a01fa1561184c57600660c0926020606096865185528187015182860152805160408601520151868401525a01fa801561184c5761184a906118d5565b565bfe5b5f60206118596100db565b82815201528051908115806118c9575b156118845750506118786100db565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479081900681039081116105ea576118be6100db565b918252602082015290565b50602081015115611869565b156118dc57565b60405162461bcd60e51b815260206004820152601260248201527f70616972696e672d6164642d6661696c656400000000000000000000000000006044820152606490fd5b60609092919260c06119316100db565b915f83525f60208401526020839681611948610100565b936080368637805185520151828401528051604084015201518482015260066107cf195a01fa801561184c5761184a906118d5565b60405190610320820182811067ffffffffffffffff8211176100fb5760405260188252610300366020840137565b906006820291808304600614901517156105ea57565b90600182018092116105ea57565b90600282018092116105ea57565b90600382018092116105ea57565b90600482018092116105ea57565b90600582018092116105ea57565b80518210156106005760209160051b010190565b15611a2257565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b9491959692909396611a77610100565b95865260209788978888015260408701526060860152611a95610100565b9384528584015260408301526060820152611aae61197d565b915f5b60048110611ae957505050610300611ac76102aa565b9384920160086107cf195a01fa801561184c57611ae390611a1b565b51151590565b611bbb9192939450611afa816119ab565b611b0482856117ec565b5151611b108288611a07565b5286611b1c83866117ec565b510151611b31611b2b836119c1565b88611a07565b52611b3c82866117ec565b515151611b4b611b2b836119cf565b52611b61611b5983876117ec565b515160200190565b51611b6e611b2b836119dd565b5286611b7a83876117ec565b51015151611b8a611b2b836119eb565b52611bb5611baf611ba889611b9f868a6117ec565b51015160200190565b51926119f9565b87611a07565b526105dc565b9084939291611ab156fea2646970667358221220e833a0c088436d63f6d3aabad6596d0d3b45758163f05280c9ca8a164d05b11e64736f6c63430008140033",
}

// BlsSigVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use BlsSigVerifierMetaData.ABI instead.
var BlsSigVerifierABI = BlsSigVerifierMetaData.ABI

// BlsSigVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BlsSigVerifierMetaData.Bin instead.
var BlsSigVerifierBin = BlsSigVerifierMetaData.Bin

// DeployBlsSigVerifier deploys a new Ethereum contract, binding an instance of BlsSigVerifier to it.
func DeployBlsSigVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BlsSigVerifier, error) {
	parsed, err := BlsSigVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BlsSigVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BlsSigVerifier{BlsSigVerifierCaller: BlsSigVerifierCaller{contract: contract}, BlsSigVerifierTransactor: BlsSigVerifierTransactor{contract: contract}, BlsSigVerifierFilterer: BlsSigVerifierFilterer{contract: contract}}, nil
}

// BlsSigVerifier is an auto generated Go binding around an Ethereum contract.
type BlsSigVerifier struct {
	BlsSigVerifierCaller     // Read-only binding to the contract
	BlsSigVerifierTransactor // Write-only binding to the contract
	BlsSigVerifierFilterer   // Log filterer for contract events
}

// BlsSigVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type BlsSigVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BlsSigVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BlsSigVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BlsSigVerifierSession struct {
	Contract     *BlsSigVerifier   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BlsSigVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BlsSigVerifierCallerSession struct {
	Contract *BlsSigVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BlsSigVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BlsSigVerifierTransactorSession struct {
	Contract     *BlsSigVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BlsSigVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type BlsSigVerifierRaw struct {
	Contract *BlsSigVerifier // Generic contract binding to access the raw methods on
}

// BlsSigVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BlsSigVerifierCallerRaw struct {
	Contract *BlsSigVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// BlsSigVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BlsSigVerifierTransactorRaw struct {
	Contract *BlsSigVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBlsSigVerifier creates a new instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifier(address common.Address, backend bind.ContractBackend) (*BlsSigVerifier, error) {
	contract, err := bindBlsSigVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifier{BlsSigVerifierCaller: BlsSigVerifierCaller{contract: contract}, BlsSigVerifierTransactor: BlsSigVerifierTransactor{contract: contract}, BlsSigVerifierFilterer: BlsSigVerifierFilterer{contract: contract}}, nil
}

// NewBlsSigVerifierCaller creates a new read-only instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierCaller(address common.Address, caller bind.ContractCaller) (*BlsSigVerifierCaller, error) {
	contract, err := bindBlsSigVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierCaller{contract: contract}, nil
}

// NewBlsSigVerifierTransactor creates a new write-only instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*BlsSigVerifierTransactor, error) {
	contract, err := bindBlsSigVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierTransactor{contract: contract}, nil
}

// NewBlsSigVerifierFilterer creates a new log filterer instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*BlsSigVerifierFilterer, error) {
	contract, err := bindBlsSigVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierFilterer{contract: contract}, nil
}

// bindBlsSigVerifier binds a generic wrapper to an already deployed contract.
func bindBlsSigVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BlsSigVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlsSigVerifier *BlsSigVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlsSigVerifier.Contract.BlsSigVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlsSigVerifier *BlsSigVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.BlsSigVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlsSigVerifier *BlsSigVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.BlsSigVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlsSigVerifier *BlsSigVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlsSigVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlsSigVerifier *BlsSigVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlsSigVerifier *BlsSigVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierCaller) VerifyBlsSigProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	var out []interface{}
	err := _BlsSigVerifier.contract.Call(opts, &out, "verifyBlsSigProof", a, b, c, commit, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BlsSigVerifier.Contract.VerifyBlsSigProof(&_BlsSigVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierCallerSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BlsSigVerifier.Contract.VerifyBlsSigProof(&_BlsSigVerifier.CallOpts, a, b, c, commit, input)
}

// BrevisMetaData contains all meta data concerning the Brevis contract.
var BrevisMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220f6b091691cb1ed90ea0da339d13c153a01b4d06c770643a8c1f3528186f3e78a64736f6c63430008140033",
}

// BrevisABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisMetaData.ABI instead.
var BrevisABI = BrevisMetaData.ABI

// BrevisBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisMetaData.Bin instead.
var BrevisBin = BrevisMetaData.Bin

// DeployBrevis deploys a new Ethereum contract, binding an instance of Brevis to it.
func DeployBrevis(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Brevis, error) {
	parsed, err := BrevisMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Brevis{BrevisCaller: BrevisCaller{contract: contract}, BrevisTransactor: BrevisTransactor{contract: contract}, BrevisFilterer: BrevisFilterer{contract: contract}}, nil
}

// Brevis is an auto generated Go binding around an Ethereum contract.
type Brevis struct {
	BrevisCaller     // Read-only binding to the contract
	BrevisTransactor // Write-only binding to the contract
	BrevisFilterer   // Log filterer for contract events
}

// BrevisCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisSession struct {
	Contract     *Brevis           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisCallerSession struct {
	Contract *BrevisCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// BrevisTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisTransactorSession struct {
	Contract     *BrevisTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisRaw struct {
	Contract *Brevis // Generic contract binding to access the raw methods on
}

// BrevisCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisCallerRaw struct {
	Contract *BrevisCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisTransactorRaw struct {
	Contract *BrevisTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevis creates a new instance of Brevis, bound to a specific deployed contract.
func NewBrevis(address common.Address, backend bind.ContractBackend) (*Brevis, error) {
	contract, err := bindBrevis(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Brevis{BrevisCaller: BrevisCaller{contract: contract}, BrevisTransactor: BrevisTransactor{contract: contract}, BrevisFilterer: BrevisFilterer{contract: contract}}, nil
}

// NewBrevisCaller creates a new read-only instance of Brevis, bound to a specific deployed contract.
func NewBrevisCaller(address common.Address, caller bind.ContractCaller) (*BrevisCaller, error) {
	contract, err := bindBrevis(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisCaller{contract: contract}, nil
}

// NewBrevisTransactor creates a new write-only instance of Brevis, bound to a specific deployed contract.
func NewBrevisTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisTransactor, error) {
	contract, err := bindBrevis(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisTransactor{contract: contract}, nil
}

// NewBrevisFilterer creates a new log filterer instance of Brevis, bound to a specific deployed contract.
func NewBrevisFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisFilterer, error) {
	contract, err := bindBrevis(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisFilterer{contract: contract}, nil
}

// bindBrevis binds a generic wrapper to an already deployed contract.
func bindBrevis(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Brevis *BrevisRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Brevis.Contract.BrevisCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Brevis *BrevisRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Brevis.Contract.BrevisTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Brevis *BrevisRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Brevis.Contract.BrevisTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Brevis *BrevisCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Brevis.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Brevis *BrevisTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Brevis.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Brevis *BrevisTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Brevis.Contract.contract.Transact(opts, method, params...)
}

// BrevisAccessMetaData contains all meta data concerning the BrevisAccess contract.
var BrevisAccessMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// BrevisAccessABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAccessMetaData.ABI instead.
var BrevisAccessABI = BrevisAccessMetaData.ABI

// BrevisAccess is an auto generated Go binding around an Ethereum contract.
type BrevisAccess struct {
	BrevisAccessCaller     // Read-only binding to the contract
	BrevisAccessTransactor // Write-only binding to the contract
	BrevisAccessFilterer   // Log filterer for contract events
}

// BrevisAccessCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAccessCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAccessTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAccessFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAccessSession struct {
	Contract     *BrevisAccess     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAccessCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAccessCallerSession struct {
	Contract *BrevisAccessCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// BrevisAccessTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAccessTransactorSession struct {
	Contract     *BrevisAccessTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// BrevisAccessRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAccessRaw struct {
	Contract *BrevisAccess // Generic contract binding to access the raw methods on
}

// BrevisAccessCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAccessCallerRaw struct {
	Contract *BrevisAccessCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAccessTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAccessTransactorRaw struct {
	Contract *BrevisAccessTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisAccess creates a new instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccess(address common.Address, backend bind.ContractBackend) (*BrevisAccess, error) {
	contract, err := bindBrevisAccess(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisAccess{BrevisAccessCaller: BrevisAccessCaller{contract: contract}, BrevisAccessTransactor: BrevisAccessTransactor{contract: contract}, BrevisAccessFilterer: BrevisAccessFilterer{contract: contract}}, nil
}

// NewBrevisAccessCaller creates a new read-only instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessCaller(address common.Address, caller bind.ContractCaller) (*BrevisAccessCaller, error) {
	contract, err := bindBrevisAccess(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessCaller{contract: contract}, nil
}

// NewBrevisAccessTransactor creates a new write-only instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAccessTransactor, error) {
	contract, err := bindBrevisAccess(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessTransactor{contract: contract}, nil
}

// NewBrevisAccessFilterer creates a new log filterer instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAccessFilterer, error) {
	contract, err := bindBrevisAccess(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessFilterer{contract: contract}, nil
}

// bindBrevisAccess binds a generic wrapper to an already deployed contract.
func bindBrevisAccess(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAccessMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAccess *BrevisAccessRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAccess.Contract.BrevisAccessCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAccess *BrevisAccessRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.Contract.BrevisAccessTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAccess *BrevisAccessRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAccess.Contract.BrevisAccessTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAccess *BrevisAccessCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAccess.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAccess *BrevisAccessTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAccess *BrevisAccessTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAccess.Contract.contract.Transact(opts, method, params...)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsPauser(&_BrevisAccess.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsPauser(&_BrevisAccess.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessSession) NumPausers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumPausers(&_BrevisAccess.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumPausers(&_BrevisAccess.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessSession) NumProvers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumProvers(&_BrevisAccess.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumProvers(&_BrevisAccess.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessSession) Owner() (common.Address, error) {
	return _BrevisAccess.Contract.Owner(&_BrevisAccess.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) Owner() (common.Address, error) {
	return _BrevisAccess.Contract.Owner(&_BrevisAccess.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessSession) Paused() (bool, error) {
	return _BrevisAccess.Contract.Paused(&_BrevisAccess.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) Paused() (bool, error) {
	return _BrevisAccess.Contract.Paused(&_BrevisAccess.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.PauserList(&_BrevisAccess.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.PauserList(&_BrevisAccess.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAccess.Contract.Pausers(&_BrevisAccess.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAccess.Contract.Pausers(&_BrevisAccess.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAccess.Contract.ProverStates(&_BrevisAccess.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAccess.Contract.ProverStates(&_BrevisAccess.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.Provers(&_BrevisAccess.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.Provers(&_BrevisAccess.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPauser(&_BrevisAccess.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPauser(&_BrevisAccess.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPausers(&_BrevisAccess.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPausers(&_BrevisAccess.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessSession) Pause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Pause(&_BrevisAccess.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Pause(&_BrevisAccess.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePauser(&_BrevisAccess.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePauser(&_BrevisAccess.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePausers(&_BrevisAccess.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePausers(&_BrevisAccess.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemoveProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemoveProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAccess.Contract.RenouncePauser(&_BrevisAccess.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAccess.Contract.RenouncePauser(&_BrevisAccess.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.TransferOwnership(&_BrevisAccess.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.TransferOwnership(&_BrevisAccess.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessSession) Unpause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Unpause(&_BrevisAccess.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Unpause(&_BrevisAccess.TransactOpts)
}

// BrevisAccessOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisAccess contract.
type BrevisAccessOwnershipTransferredIterator struct {
	Event *BrevisAccessOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisAccess contract.
type BrevisAccessOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisAccessOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessOwnershipTransferredIterator{contract: _BrevisAccess.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisAccessOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessOwnershipTransferred)
				if err := _BrevisAccess.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisAccessOwnershipTransferred, error) {
	event := new(BrevisAccessOwnershipTransferred)
	if err := _BrevisAccess.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisAccess contract.
type BrevisAccessPausedIterator struct {
	Event *BrevisAccessPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPaused represents a Paused event raised by the BrevisAccess contract.
type BrevisAccessPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisAccessPausedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPausedIterator{contract: _BrevisAccess.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisAccessPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPaused)
				if err := _BrevisAccess.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePaused(log types.Log) (*BrevisAccessPaused, error) {
	event := new(BrevisAccessPaused)
	if err := _BrevisAccess.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisAccess contract.
type BrevisAccessPauserAddedIterator struct {
	Event *BrevisAccessPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPauserAdded represents a PauserAdded event raised by the BrevisAccess contract.
type BrevisAccessPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisAccessPauserAddedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPauserAddedIterator{contract: _BrevisAccess.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisAccessPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPauserAdded)
				if err := _BrevisAccess.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePauserAdded(log types.Log) (*BrevisAccessPauserAdded, error) {
	event := new(BrevisAccessPauserAdded)
	if err := _BrevisAccess.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisAccess contract.
type BrevisAccessPauserRemovedIterator struct {
	Event *BrevisAccessPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPauserRemoved represents a PauserRemoved event raised by the BrevisAccess contract.
type BrevisAccessPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisAccessPauserRemovedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPauserRemovedIterator{contract: _BrevisAccess.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAccessPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPauserRemoved)
				if err := _BrevisAccess.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePauserRemoved(log types.Log) (*BrevisAccessPauserRemoved, error) {
	event := new(BrevisAccessPauserRemoved)
	if err := _BrevisAccess.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisAccess contract.
type BrevisAccessProverAddedIterator struct {
	Event *BrevisAccessProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessProverAdded represents a ProverAdded event raised by the BrevisAccess contract.
type BrevisAccessProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisAccessProverAddedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessProverAddedIterator{contract: _BrevisAccess.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisAccessProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessProverAdded)
				if err := _BrevisAccess.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseProverAdded(log types.Log) (*BrevisAccessProverAdded, error) {
	event := new(BrevisAccessProverAdded)
	if err := _BrevisAccess.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisAccess contract.
type BrevisAccessProverRemovedIterator struct {
	Event *BrevisAccessProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessProverRemoved represents a ProverRemoved event raised by the BrevisAccess contract.
type BrevisAccessProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisAccessProverRemovedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessProverRemovedIterator{contract: _BrevisAccess.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAccessProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessProverRemoved)
				if err := _BrevisAccess.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseProverRemoved(log types.Log) (*BrevisAccessProverRemoved, error) {
	event := new(BrevisAccessProverRemoved)
	if err := _BrevisAccess.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisAccess contract.
type BrevisAccessUnpausedIterator struct {
	Event *BrevisAccessUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessUnpaused represents a Unpaused event raised by the BrevisAccess contract.
type BrevisAccessUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisAccessUnpausedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessUnpausedIterator{contract: _BrevisAccess.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisAccessUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessUnpaused)
				if err := _BrevisAccess.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseUnpaused(log types.Log) (*BrevisAccessUnpaused, error) {
	event := new(BrevisAccessUnpaused)
	if err := _BrevisAccess.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofMetaData contains all meta data concerning the BrevisAggProof contract.
var BrevisAggProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"AggProofVerifierAddressesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"SmtContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"aggProofVerifierAddress\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateAggProofVerifierAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346101ac57601f62001f0a38819003918201601f1916830192916001600160401b038411838510176101b057808392604095865283396020928391810103126101ac57516001600160a01b038082169290918390036101ac575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff1661016c5750600254680100000000000000008110156101585760018101806002558110156101445790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a1600554161760055551611d459081620001c58239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c80631396511e1461148a578063158535ff146114585780633221aec6146114305780633bda38a3146110c05780633f4ba83a14610fbf57806346fbf68e146109555780634f4fef1814610fa257806358a16b4414610f835780635c975abb14610f5e578063677625f214610e005780636b2c0f5514610dc95780636ef8d66d14610daf5780637b1cc45014610b815780637dbafb111461099157806380f51c121461095557806382dc1ec41461091b5780638456cb59146108025780638da5cb5b146107dc578063a036e7991461078c578063b4f7a727146103ec578063ceae3390146103ab578063e6c6fcec1461035b578063e79b7a5114610302578063f2fde38b14610218578063fabc74f5146101ba578063fd1190ea146101765763fe5a537714610147575f80fd5b34610172576020366003190112610172578160209360ff923581526006855220541690519015158152f35b8280fd5b5091346101b75760203660031901126101b757823592548310156101b757506001600160a01b036101a8602093611552565b92905490519260031b1c168152f35b80fd5b50919034610214576020366003190112610214576001600160a01b036101de6115a2565b168252600360205260ff8183205416905191600382101561020157602083838152f35b634e487b7160e01b815260218452602490fd5b5080fd5b5034610172576020366003190112610172576102326115a2565b908354906001600160a01b038083169361024d3386146117ed565b1693841561029957505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b83346101b7576103113661160a565b906001600160a01b03916103298383541633146117ed565b815b8151811015610357578061034d856103466103529486611838565b5116611a6e565b6116e4565b61032b565b8280f35b83346101b75761036a3661160a565b906001600160a01b03916103828383541633146117ed565b815b8151811015610357578061034d8561039f6103a69486611838565b5116611898565b610384565b505034610214576020366003190112610214576001600160a01b038160209367ffffffffffffffff6103db611587565b168152600785522054169051908152f35b50903461017257606036600319011261017257610407611587565b9160249067ffffffffffffffff82358181116107885761042a903690840161169b565b906044948535948486116106765736602387011215610676578581013585811161067a573683828901011161067a57338b526020976003895260ff8a8d2054169a60038c1015610776576001809c036107355787168c52600789526001600160a01b038a8d20541680156106f557898986928f868f519586946322bb937360e11b8652868b87015282828701520187850137858784010152818581601f19601f8a011681010301915afa9081156106eb578d916106be575b501561067e5750806101a01161067a576101c011610676578751926102009081850185811088821117610664578a52813686378b5b8681106106455750506010948581106105f5575b50885194888601948c908c8b885b8585106105e0575050505050508452610220840194848610908611176105cf5750508286526101c484013590825190200361058b5750506101a401358452600690528220805460ff1916909117905580f35b907f70726f6f66496473206e6f7420726967687400000000000000000000000000006102646064938662461bcd60e51b855261022482015260126102448201520152fd5b634e487b7160e01b8a526041905288fd5b819084518152019201920191908b8e91610539565b805b868110610604575061052b565b5f198201828111610633579061061d61062e9288611716565b516106288289611716565b526116e4565b6105f7565b634e487b7160e01b8e5260118552858efd5b8061065461065f928985611706565b356106288289611716565b610517565b634e487b7160e01b8d5260418452848dfd5b8980fd5b8a80fd5b7f70726f6f66206e6f742076616c696400000000000000000000000000000000009150600f6064948a8c519562461bcd60e51b8752860152840152820152fd5b6106de91508a3d8c116106e4575b6106d681836115e8565b8101906116cc565b5f6104e2565b503d6106cc565b8b513d8f823e3d90fd5b507f636861696e206167672070726f6f66207665726966696572206e6f7420736574915088606494818c519562461bcd60e51b8752860152840152820152fd5b507f6e6f7420696e76616c69642070726f7665720000000000000000000000000000915060126064948a8c519562461bcd60e51b8752860152840152820152fd5b634e487b7160e01b8d5260218452848dfd5b8680fd5b83346101b75761079b3661160a565b906001600160a01b03916107b38383541633146117ed565b815b8151811015610357578061034d856107d06107d79486611838565b5116611b53565b6107b5565b5050346102145781600319360112610214576001600160a01b0360209254169051908152f35b50903461017257826003193601126101725733835260019160209083825261082f60ff848720541661184c565b845460ff8160a01c166108d95760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b610890578580f35b81548110156108d557806001600160a01b036108ae6108cf93611552565b919054600392831b1c1688528452848720600260ff198254161790556116e4565b84610888565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b83346101b75760203660031901126101b7576109526109386115a2565b61094d6001600160a01b0384541633146117ed565b611a6e565b80f35b5050346102145760203660031901126102145760ff816020936001600160a01b0361097e6115a2565b1681526001855220541690519015158152f35b5091903461021457806003193601126102145767ffffffffffffffff928035848111610b7d576109c4903690830161169b565b91602435868111610b79576109dc903690830161169b565b9390966001600160a01b03926109f68489541633146117ed565b858303610b3657509086949392945b818110610ac25750808651968088019088525260608601929187905b828210610a995750505050602081858293038287015283815201959285905b838210610a7157867f4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e878a0388a180f35b90919293968735828116809103610a95578152830196830193929160010190610a40565b8780fd5b909192949593853582811680910361067657815293959460209485019401929160010190610a21565b610ad481868b98969798959495611706565b35848116809103610b3257610aea828588611706565b358381168091036106765789526007602052878920805473ffffffffffffffffffffffffffffffffffffffff19169091179055610b26906116e4565b94939294919091610a05565b8880fd5b606490602088519162461bcd60e51b8352820152601060248201527f6c656e677468206e6f74206d61746368000000000000000000000000000000006044820152fd5b8580fd5b8380fd5b509190346102145761012036600319011261021457610b9e611587565b9160a03660231901126101b75760c4359360e43567ffffffffffffffff811161017257610bce903690830161169b565b9095610104359660ff95868916809903610b795782865260209160068352610bfa8883892054166117a1565b600554825163080cdb0b60e11b815267ffffffffffffffff909a168a880190815260a435602082018190529a91859183916001600160a01b0316908290819060400103915afa908115610da55790610c59918991610d88575b50611737565b815160248035858301908152602081019b909b5260443560408c015260643560608c015260843560808c01529990610c9e8160a084015b03601f1981018352826115e8565b5190209387945b89861688811015610d39578a91908d811c600116610d0a57610cc8908986611706565b3585519087820192835286820152858152610ce2816115b8565b519020955b16898114610cf85760010194610ca5565b634e487b7160e01b8952601188528a89fd5b610d15908986611706565b359085519087820192835286820152858152610d30816115b8565b51902095610ce7565b89898d8888868803610d49578480f35b5162461bcd60e51b815292830152600c908201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b610d9f9150853d87116106e4576106d681836115e8565b5f610c53565b83513d8a823e3d90fd5b83346101b757806003193601126101b75761095233611b53565b83346101b75760203660031901126101b757610952610de66115a2565b610dfb6001600160a01b0384541633146117ed565b611b53565b5091346101b757610e103661160a565b916001600160a01b03610e278184541633146117ed565b825b8451811015610f5a5781610e3d8287611838565b511680855260039060209180835260ff868820541681811015610f4757610f0457885468010000000000000000811015610ef1579189610eec959492610ecf83610eaf7fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684976001958682019055611552565b90919082549060031b916001600160a01b03809116831b921b1916179055565b828a5283528789209060ff198254161790558651908152a16116e4565b610e29565b634e487b7160e01b885260418a52602488fd5b855162461bcd60e51b8152808a01849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b885260218a52602488fd5b8380f35b50503461021457816003193601126102145760ff6020925460a01c1690519015158152f35b5050346102145781600319360112610214576020906002549051908152f35b503461017257826003193601126101725760209250549051908152f35b509190346102145781600319360112610214573382526001906020828152610fec60ff838620541661184c565b83549460ff8660a01c161561107f5760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b61103a578580f35b80548410156108d557611079846001600160a01b036110598897611552565b919054600392831b1c16895284528488208660ff198254161790556116e4565b93611032565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b50346101725781600319360112610172576110d9611587565b90602480359167ffffffffffffffff938484116107885736602385011215610788578382013590858211610a95578385019484369160a08502010111610a95576010948583116113ee578751966103e090818901908111898210176113dc5789939293523688376005546001600160a01b03169089805b8581106112c5575050505050838110611278575b5085835b611189578661095260ff886103c089015184526006602052832054166117a1565b919486949193965b5f19880188811161126657811015611249576111b66111b08286611794565b84611783565b516111c18286611794565b9060019182810180911161123757611218916111e06112129288611783565b5186519060208201928352878201528681526111fb816115b8565b519020928461120a8d8a611794565b911c90611794565b85611783565b52600281018091111561119157634e487b7160e01b8652601185528686fd5b634e487b7160e01b8952601188528989fd5b5094918661125b919794929597611794565b9260011c9283611168565b634e487b7160e01b8752601186528787fd5b5f19810190808211905b858110611290575050611164565b816112b3576112ae906112a38489611783565b51610628828a611783565b611282565b634e487b7160e01b8952601184528489fd5b60808b61130e858a846112d9878d8d611727565b013584518094819263080cdb0b60e11b8352602095869584016020909392919367ffffffffffffffff60408201951681520152565b03818b5afa9586156113d1576113b3966113a69361133192916113ba5750611737565b610c9061133f868c8c611727565b359461134c878d8d611727565b0135938a8c606061137a8a87611363828688611727565b01359386611372838389611727565b013595611727565b0135925196879586019889939160a0959391855260208501526040840152606083015260808201520190565b519020610628828c611783565b8a90611150565b610d9f9150833d85116106e4576106d681836115e8565b8351903d90823e3d90fd5b634e487b7160e01b8b5260418652868bfd5b875162461bcd60e51b8152602081860152600c818701527f73697a65206578636565647300000000000000000000000000000000000000006044820152606490fd5b5050346102145781600319360112610214576020906001600160a01b03600554169051908152f35b50346101725760203660031901126101725735916002548310156101b757506001600160a01b036101a8602093611509565b503461017257602036600319011261017257356001600160a01b0390818116809103610b7d577f674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f926114e260209386541633146117ed565b8173ffffffffffffffffffffffffffffffffffffffff19600554161760055551908152a180f35b60025481101561153e5760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b60045481101561153e5760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff8216820361159e57565b5f80fd5b600435906001600160a01b038216820361159e57565b6060810190811067ffffffffffffffff8211176115d457604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176115d457604052565b60208060031983011261159e5767ffffffffffffffff9160043583811161159e578160238201121561159e5780600401359384116115d4578360051b9060405194611657858401876115e8565b855260248486019282010192831161159e57602401905b82821061167c575050505090565b81356001600160a01b038116810361159e57815290830190830161166e565b9181601f8401121561159e5782359167ffffffffffffffff831161159e576020808501948460051b01011161159e57565b9081602091031261159e5751801515810361159e5790565b5f1981146116f25760010190565b634e487b7160e01b5f52601160045260245ffd5b919081101561153e5760051b0190565b90601081101561153e5760051b0190565b919081101561153e5760a0020190565b1561173e57565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c696420736d7420726f6f74000000000000000000000000000000006044820152606490fd5b90601f81101561153e5760051b0190565b919082018092116116f257565b156117a857565b60405162461bcd60e51b815260206004820152601660248201527f6d65726b6c6520726f6f74206e6f7420657869737473000000000000000000006044820152606490fd5b156117f457565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b805182101561153e5760209160051b010190565b1561185357565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611a5a5715611a16576004968754965f1990818901988911611a0357835b8a548110156119c05786826118f183611552565b905490871b1c161461190b57611906906116e4565b6118dd565b90919293949596979880821061199b575b505050875480156119885797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859899019061197261195d83611552565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b6119b8926119ab610eaf92611552565b905490871b1c1691611552565b5f808061191c565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611b0e5760025468010000000000000000811015611afa57602092611ade7f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89593610eaf84600160409601600255611509565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611ccb576002805490915f1991828101908111611cb757908695949392918a975b611be2575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611cae578185611bfa8c611509565b929054600393841b1c1614611c235750611c1a8798999a979596976116e4565b97969594611b99565b9293949796959991818310611c89575b5050505081548015611c7557918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e989993019061197261195d83611509565b634e487b7160e01b89526031600452602489fd5b611ca593611c99610eaf93611509565b9054911b1c1691611509565b5f808080611c33565b87989950611b9e565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea26469706673582212202e84ecd3ec0cc596428ddde9cdb5a1135e339266ba53b85677afb8a97acbc3e464736f6c63430008140033",
}

// BrevisAggProofABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAggProofMetaData.ABI instead.
var BrevisAggProofABI = BrevisAggProofMetaData.ABI

// BrevisAggProofBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisAggProofMetaData.Bin instead.
var BrevisAggProofBin = BrevisAggProofMetaData.Bin

// DeployBrevisAggProof deploys a new Ethereum contract, binding an instance of BrevisAggProof to it.
func DeployBrevisAggProof(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *BrevisAggProof, error) {
	parsed, err := BrevisAggProofMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisAggProofBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisAggProof{BrevisAggProofCaller: BrevisAggProofCaller{contract: contract}, BrevisAggProofTransactor: BrevisAggProofTransactor{contract: contract}, BrevisAggProofFilterer: BrevisAggProofFilterer{contract: contract}}, nil
}

// BrevisAggProof is an auto generated Go binding around an Ethereum contract.
type BrevisAggProof struct {
	BrevisAggProofCaller     // Read-only binding to the contract
	BrevisAggProofTransactor // Write-only binding to the contract
	BrevisAggProofFilterer   // Log filterer for contract events
}

// BrevisAggProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAggProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAggProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAggProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAggProofSession struct {
	Contract     *BrevisAggProof   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAggProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAggProofCallerSession struct {
	Contract *BrevisAggProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BrevisAggProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAggProofTransactorSession struct {
	Contract     *BrevisAggProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BrevisAggProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAggProofRaw struct {
	Contract *BrevisAggProof // Generic contract binding to access the raw methods on
}

// BrevisAggProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAggProofCallerRaw struct {
	Contract *BrevisAggProofCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAggProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAggProofTransactorRaw struct {
	Contract *BrevisAggProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisAggProof creates a new instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProof(address common.Address, backend bind.ContractBackend) (*BrevisAggProof, error) {
	contract, err := bindBrevisAggProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProof{BrevisAggProofCaller: BrevisAggProofCaller{contract: contract}, BrevisAggProofTransactor: BrevisAggProofTransactor{contract: contract}, BrevisAggProofFilterer: BrevisAggProofFilterer{contract: contract}}, nil
}

// NewBrevisAggProofCaller creates a new read-only instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofCaller(address common.Address, caller bind.ContractCaller) (*BrevisAggProofCaller, error) {
	contract, err := bindBrevisAggProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofCaller{contract: contract}, nil
}

// NewBrevisAggProofTransactor creates a new write-only instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAggProofTransactor, error) {
	contract, err := bindBrevisAggProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofTransactor{contract: contract}, nil
}

// NewBrevisAggProofFilterer creates a new log filterer instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAggProofFilterer, error) {
	contract, err := bindBrevisAggProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofFilterer{contract: contract}, nil
}

// bindBrevisAggProof binds a generic wrapper to an already deployed contract.
func bindBrevisAggProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAggProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAggProof *BrevisAggProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAggProof.Contract.BrevisAggProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAggProof *BrevisAggProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.BrevisAggProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAggProof *BrevisAggProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.BrevisAggProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAggProof *BrevisAggProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAggProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAggProof *BrevisAggProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAggProof *BrevisAggProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.contract.Transact(opts, method, params...)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) AggProofVerifierAddress(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "aggProofVerifierAddress", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisAggProof.Contract.AggProofVerifierAddress(&_BrevisAggProof.CallOpts, arg0)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisAggProof.Contract.AggProofVerifierAddress(&_BrevisAggProof.CallOpts, arg0)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsPauser(&_BrevisAggProof.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsPauser(&_BrevisAggProof.CallOpts, account)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) MerkleRoots(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "merkleRoots", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisAggProof.Contract.MerkleRoots(&_BrevisAggProof.CallOpts, arg0)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisAggProof.Contract.MerkleRoots(&_BrevisAggProof.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofSession) NumPausers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumPausers(&_BrevisAggProof.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumPausers(&_BrevisAggProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofSession) NumProvers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumProvers(&_BrevisAggProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumProvers(&_BrevisAggProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) Owner() (common.Address, error) {
	return _BrevisAggProof.Contract.Owner(&_BrevisAggProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) Owner() (common.Address, error) {
	return _BrevisAggProof.Contract.Owner(&_BrevisAggProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) Paused() (bool, error) {
	return _BrevisAggProof.Contract.Paused(&_BrevisAggProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) Paused() (bool, error) {
	return _BrevisAggProof.Contract.Paused(&_BrevisAggProof.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.PauserList(&_BrevisAggProof.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.PauserList(&_BrevisAggProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAggProof.Contract.Pausers(&_BrevisAggProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAggProof.Contract.Pausers(&_BrevisAggProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAggProof.Contract.ProverStates(&_BrevisAggProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAggProof.Contract.ProverStates(&_BrevisAggProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.Provers(&_BrevisAggProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.Provers(&_BrevisAggProof.CallOpts, arg0)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) SmtContract() (common.Address, error) {
	return _BrevisAggProof.Contract.SmtContract(&_BrevisAggProof.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) SmtContract() (common.Address, error) {
	return _BrevisAggProof.Contract.SmtContract(&_BrevisAggProof.CallOpts)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisAggProof.Contract.ValidateAggProofData(&_BrevisAggProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisAggProof.Contract.ValidateAggProofData(&_BrevisAggProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisAggProof.Contract.ValidateAggProofData0(&_BrevisAggProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisAggProof.Contract.ValidateAggProofData0(&_BrevisAggProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPauser(&_BrevisAggProof.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPauser(&_BrevisAggProof.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPausers(&_BrevisAggProof.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPausers(&_BrevisAggProof.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofSession) Pause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Pause(&_BrevisAggProof.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Pause(&_BrevisAggProof.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePauser(&_BrevisAggProof.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePauser(&_BrevisAggProof.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePausers(&_BrevisAggProof.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePausers(&_BrevisAggProof.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemoveProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemoveProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RenouncePauser(&_BrevisAggProof.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RenouncePauser(&_BrevisAggProof.TransactOpts)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "submitAggProof", _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.SubmitAggProof(&_BrevisAggProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.SubmitAggProof(&_BrevisAggProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.TransferOwnership(&_BrevisAggProof.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.TransferOwnership(&_BrevisAggProof.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofSession) Unpause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Unpause(&_BrevisAggProof.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Unpause(&_BrevisAggProof.TransactOpts)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) UpdateAggProofVerifierAddresses(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "updateAggProofVerifierAddresses", _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisAggProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisAggProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateSmtContract(&_BrevisAggProof.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateSmtContract(&_BrevisAggProof.TransactOpts, _smtContract)
}

// BrevisAggProofAggProofVerifierAddressesUpdatedIterator is returned from FilterAggProofVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for AggProofVerifierAddressesUpdated events raised by the BrevisAggProof contract.
type BrevisAggProofAggProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisAggProofAggProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofAggProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofAggProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofAggProofVerifierAddressesUpdated represents a AggProofVerifierAddressesUpdated event raised by the BrevisAggProof contract.
type BrevisAggProofAggProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAggProofVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterAggProofVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisAggProofAggProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofAggProofVerifierAddressesUpdatedIterator{contract: _BrevisAggProof.contract, event: "AggProofVerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchAggProofVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchAggProofVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisAggProofAggProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofAggProofVerifierAddressesUpdated)
				if err := _BrevisAggProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAggProofVerifierAddressesUpdated is a log parse operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseAggProofVerifierAddressesUpdated(log types.Log) (*BrevisAggProofAggProofVerifierAddressesUpdated, error) {
	event := new(BrevisAggProofAggProofVerifierAddressesUpdated)
	if err := _BrevisAggProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisAggProof contract.
type BrevisAggProofOwnershipTransferredIterator struct {
	Event *BrevisAggProofOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisAggProof contract.
type BrevisAggProofOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisAggProofOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofOwnershipTransferredIterator{contract: _BrevisAggProof.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisAggProofOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofOwnershipTransferred)
				if err := _BrevisAggProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisAggProofOwnershipTransferred, error) {
	event := new(BrevisAggProofOwnershipTransferred)
	if err := _BrevisAggProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisAggProof contract.
type BrevisAggProofPausedIterator struct {
	Event *BrevisAggProofPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPaused represents a Paused event raised by the BrevisAggProof contract.
type BrevisAggProofPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisAggProofPausedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPausedIterator{contract: _BrevisAggProof.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPaused)
				if err := _BrevisAggProof.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePaused(log types.Log) (*BrevisAggProofPaused, error) {
	event := new(BrevisAggProofPaused)
	if err := _BrevisAggProof.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisAggProof contract.
type BrevisAggProofPauserAddedIterator struct {
	Event *BrevisAggProofPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPauserAdded represents a PauserAdded event raised by the BrevisAggProof contract.
type BrevisAggProofPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisAggProofPauserAddedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPauserAddedIterator{contract: _BrevisAggProof.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPauserAdded)
				if err := _BrevisAggProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePauserAdded(log types.Log) (*BrevisAggProofPauserAdded, error) {
	event := new(BrevisAggProofPauserAdded)
	if err := _BrevisAggProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisAggProof contract.
type BrevisAggProofPauserRemovedIterator struct {
	Event *BrevisAggProofPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPauserRemoved represents a PauserRemoved event raised by the BrevisAggProof contract.
type BrevisAggProofPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisAggProofPauserRemovedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPauserRemovedIterator{contract: _BrevisAggProof.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPauserRemoved)
				if err := _BrevisAggProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePauserRemoved(log types.Log) (*BrevisAggProofPauserRemoved, error) {
	event := new(BrevisAggProofPauserRemoved)
	if err := _BrevisAggProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisAggProof contract.
type BrevisAggProofProverAddedIterator struct {
	Event *BrevisAggProofProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofProverAdded represents a ProverAdded event raised by the BrevisAggProof contract.
type BrevisAggProofProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisAggProofProverAddedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofProverAddedIterator{contract: _BrevisAggProof.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisAggProofProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofProverAdded)
				if err := _BrevisAggProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseProverAdded(log types.Log) (*BrevisAggProofProverAdded, error) {
	event := new(BrevisAggProofProverAdded)
	if err := _BrevisAggProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisAggProof contract.
type BrevisAggProofProverRemovedIterator struct {
	Event *BrevisAggProofProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofProverRemoved represents a ProverRemoved event raised by the BrevisAggProof contract.
type BrevisAggProofProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisAggProofProverRemovedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofProverRemovedIterator{contract: _BrevisAggProof.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAggProofProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofProverRemoved)
				if err := _BrevisAggProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseProverRemoved(log types.Log) (*BrevisAggProofProverRemoved, error) {
	event := new(BrevisAggProofProverRemoved)
	if err := _BrevisAggProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofSmtContractUpdatedIterator is returned from FilterSmtContractUpdated and is used to iterate over the raw logs and unpacked data for SmtContractUpdated events raised by the BrevisAggProof contract.
type BrevisAggProofSmtContractUpdatedIterator struct {
	Event *BrevisAggProofSmtContractUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofSmtContractUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofSmtContractUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofSmtContractUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofSmtContractUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofSmtContractUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofSmtContractUpdated represents a SmtContractUpdated event raised by the BrevisAggProof contract.
type BrevisAggProofSmtContractUpdated struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtContractUpdated is a free log retrieval operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterSmtContractUpdated(opts *bind.FilterOpts) (*BrevisAggProofSmtContractUpdatedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofSmtContractUpdatedIterator{contract: _BrevisAggProof.contract, event: "SmtContractUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtContractUpdated is a free log subscription operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchSmtContractUpdated(opts *bind.WatchOpts, sink chan<- *BrevisAggProofSmtContractUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofSmtContractUpdated)
				if err := _BrevisAggProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtContractUpdated is a log parse operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseSmtContractUpdated(log types.Log) (*BrevisAggProofSmtContractUpdated, error) {
	event := new(BrevisAggProofSmtContractUpdated)
	if err := _BrevisAggProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisAggProof contract.
type BrevisAggProofUnpausedIterator struct {
	Event *BrevisAggProofUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofUnpaused represents a Unpaused event raised by the BrevisAggProof contract.
type BrevisAggProofUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisAggProofUnpausedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofUnpausedIterator{contract: _BrevisAggProof.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisAggProofUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofUnpaused)
				if err := _BrevisAggProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseUnpaused(log types.Log) (*BrevisAggProofUnpaused, error) {
	event := new(BrevisAggProofUnpaused)
	if err := _BrevisAggProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAppMetaData contains all meta data concerning the BrevisApp contract.
var BrevisAppMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"applyBrevisOpResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"applyBrevisOpResults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opChallengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisRequest\",\"type\":\"address\"}],\"name\":\"setBrevisRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_challangeWindow\",\"type\":\"uint256\"}],\"name\":\"setOpChallengeWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// BrevisAppABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAppMetaData.ABI instead.
var BrevisAppABI = BrevisAppMetaData.ABI

// BrevisApp is an auto generated Go binding around an Ethereum contract.
type BrevisApp struct {
	BrevisAppCaller     // Read-only binding to the contract
	BrevisAppTransactor // Write-only binding to the contract
	BrevisAppFilterer   // Log filterer for contract events
}

// BrevisAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAppSession struct {
	Contract     *BrevisApp        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAppCallerSession struct {
	Contract *BrevisAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// BrevisAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAppTransactorSession struct {
	Contract     *BrevisAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BrevisAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAppRaw struct {
	Contract *BrevisApp // Generic contract binding to access the raw methods on
}

// BrevisAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAppCallerRaw struct {
	Contract *BrevisAppCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAppTransactorRaw struct {
	Contract *BrevisAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisApp creates a new instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisApp(address common.Address, backend bind.ContractBackend) (*BrevisApp, error) {
	contract, err := bindBrevisApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisApp{BrevisAppCaller: BrevisAppCaller{contract: contract}, BrevisAppTransactor: BrevisAppTransactor{contract: contract}, BrevisAppFilterer: BrevisAppFilterer{contract: contract}}, nil
}

// NewBrevisAppCaller creates a new read-only instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppCaller(address common.Address, caller bind.ContractCaller) (*BrevisAppCaller, error) {
	contract, err := bindBrevisApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAppCaller{contract: contract}, nil
}

// NewBrevisAppTransactor creates a new write-only instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAppTransactor, error) {
	contract, err := bindBrevisApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAppTransactor{contract: contract}, nil
}

// NewBrevisAppFilterer creates a new log filterer instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAppFilterer, error) {
	contract, err := bindBrevisApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAppFilterer{contract: contract}, nil
}

// bindBrevisApp binds a generic wrapper to an already deployed contract.
func bindBrevisApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisApp *BrevisAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisApp.Contract.BrevisAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisApp *BrevisAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisApp *BrevisAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisApp *BrevisAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisApp *BrevisAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisApp *BrevisAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppCaller) BrevisRequest(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisApp.contract.Call(opts, &out, "brevisRequest")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppSession) BrevisRequest() (common.Address, error) {
	return _BrevisApp.Contract.BrevisRequest(&_BrevisApp.CallOpts)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppCallerSession) BrevisRequest() (common.Address, error) {
	return _BrevisApp.Contract.BrevisRequest(&_BrevisApp.CallOpts)
}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_BrevisApp *BrevisAppCaller) OpChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisApp.contract.Call(opts, &out, "opChallengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_BrevisApp *BrevisAppSession) OpChallengeWindow() (*big.Int, error) {
	return _BrevisApp.Contract.OpChallengeWindow(&_BrevisApp.CallOpts)
}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_BrevisApp *BrevisAppCallerSession) OpChallengeWindow() (*big.Int, error) {
	return _BrevisApp.Contract.OpChallengeWindow(&_BrevisApp.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisApp *BrevisAppCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisApp.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisApp *BrevisAppSession) Owner() (common.Address, error) {
	return _BrevisApp.Contract.Owner(&_BrevisApp.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisApp *BrevisAppCallerSession) Owner() (common.Address, error) {
	return _BrevisApp.Contract.Owner(&_BrevisApp.CallOpts)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactor) ApplyBrevisOpResult(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "applyBrevisOpResult", _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResult(&_BrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactorSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResult(&_BrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactor) ApplyBrevisOpResults(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "applyBrevisOpResults", _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResults(&_BrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactorSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResults(&_BrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisBatchCallback(&_BrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactorSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisBatchCallback(&_BrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisCallback(&_BrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisCallback(&_BrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BrevisApp *BrevisAppTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BrevisApp *BrevisAppSession) RenounceOwnership() (*types.Transaction, error) {
	return _BrevisApp.Contract.RenounceOwnership(&_BrevisApp.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BrevisApp *BrevisAppTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BrevisApp.Contract.RenounceOwnership(&_BrevisApp.TransactOpts)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_BrevisApp *BrevisAppTransactor) SetBrevisRequest(opts *bind.TransactOpts, _brevisRequest common.Address) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "setBrevisRequest", _brevisRequest)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_BrevisApp *BrevisAppSession) SetBrevisRequest(_brevisRequest common.Address) (*types.Transaction, error) {
	return _BrevisApp.Contract.SetBrevisRequest(&_BrevisApp.TransactOpts, _brevisRequest)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_BrevisApp *BrevisAppTransactorSession) SetBrevisRequest(_brevisRequest common.Address) (*types.Transaction, error) {
	return _BrevisApp.Contract.SetBrevisRequest(&_BrevisApp.TransactOpts, _brevisRequest)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_BrevisApp *BrevisAppTransactor) SetOpChallengeWindow(opts *bind.TransactOpts, _challangeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "setOpChallengeWindow", _challangeWindow)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_BrevisApp *BrevisAppSession) SetOpChallengeWindow(_challangeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisApp.Contract.SetOpChallengeWindow(&_BrevisApp.TransactOpts, _challangeWindow)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_BrevisApp *BrevisAppTransactorSession) SetOpChallengeWindow(_challangeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisApp.Contract.SetOpChallengeWindow(&_BrevisApp.TransactOpts, _challangeWindow)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisApp *BrevisAppTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisApp *BrevisAppSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisApp.Contract.TransferOwnership(&_BrevisApp.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisApp *BrevisAppTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisApp.Contract.TransferOwnership(&_BrevisApp.TransactOpts, newOwner)
}

// BrevisAppOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisApp contract.
type BrevisAppOwnershipTransferredIterator struct {
	Event *BrevisAppOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAppOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAppOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAppOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAppOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAppOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAppOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisApp contract.
type BrevisAppOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisApp *BrevisAppFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisAppOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisApp.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisAppOwnershipTransferredIterator{contract: _BrevisApp.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisApp *BrevisAppFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisAppOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisApp.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAppOwnershipTransferred)
				if err := _BrevisApp.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisApp *BrevisAppFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisAppOwnershipTransferred, error) {
	event := new(BrevisAppOwnershipTransferred)
	if err := _BrevisApp.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofMetaData contains all meta data concerning the BrevisProof contract.
var BrevisProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"AggProofVerifierAddressesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"SmtContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"VerifierAddressesUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"aggProofVerifierAddress\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proofs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateAggProofVerifierAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"}],\"name\":\"validateProofAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608034620001b357601f6200243c38819003918201601f1916830192916001600160401b03841183851017620001b75780839260409586528339602092839181010312620001b357516001600160a01b03808216929091839003620001b3575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff16620001735750600254680100000000000000008110156200015f5760018101806002558110156200014b5790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a16005541617600555516122709081620001cc8239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c80631396511e146116e8578063158535ff146116b65780633221aec61461168e5780633bda38a31461131a5780633f4ba83a14611219578063444d95b0146111f257806346fbf68e14610c2b5780634f4fef18146111d557806350d410631461111557806358a16b44146110f65780635c975abb146110d1578063677625f214610f735780636b2c0f5514610f3c5780636ef8d66d14610f225780637b1cc45014610d375780637dbafb1114610c6757806380f51c1214610c2b57806382dc1ec414610bf15780638456cb5914610ad85780638da5cb5b14610ab25780639017837014610a61578063a036e79914610a11578063b4f7a72714610730578063ceae3390146106ef578063e044095314610416578063e6c6fcec146103c6578063e79b7a511461036d578063f2fde38b14610290578063f5cec6af1461024f578063fabc74f5146101f1578063fd1190ea146101ad5763fe5a53771461017e575f80fd5b346101a95760203660031901126101a9578160209360ff923581526006855220541690519015158152f35b8280fd5b5091346101ee5760203660031901126101ee57823592548310156101ee57506001600160a01b036101df6020936117a7565b92905490519260031b1c168152f35b80fd5b5091903461024b57602036600319011261024b576001600160a01b036102156117f7565b168252600360205260ff8183205416905191600382101561023857602083838152f35b634e487b7160e01b815260218452602490fd5b5080fd5b50503461024b57602036600319011261024b576001600160a01b038160209367ffffffffffffffff61027f6117dc565b168152600885522054169051908152f35b50346101a95760203660031901126101a9576102aa6117f7565b908354906001600160a01b03808316936102c5338614611bc6565b169384156103045750506001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b83346101ee5761037c366118db565b906001600160a01b0391610394838354163314611bc6565b815b81518110156103c257806103b8856103b16103bd9486611d63565b5116611f99565b611a71565b610396565b8280f35b83346101ee576103d5366118db565b906001600160a01b03916103ed838354163314611bc6565b815b81518110156103c257806103b88561040a6104119486611d63565b5116611dc3565b6103ef565b5090346101a957806003193601126101a9576104306117dc565b906024359267ffffffffffffffff938481116106eb57610453903690830161196c565b90913387526020916003835260ff858920541660038110156106d857600161047b911461199a565b8686168852600883526001600160a01b039384868a20541680156106955784875180926322bb937360e11b825281806104b788888b84016119fe565b03915afa90811561068b57906104d4918b9161066e575b50611a25565b85519760a089019081118982101761065b57865288885288848901528588019489865260608901978a895260808a01918b835261051a6105148686611d21565b90611d47565b809b5261052a6105148686611d34565b80935261020094808611610657576101e0850135809952610220116106535761058a9487940135809a526005541690885180958194829363080cdb0b60e11b84528984016020909392919367ffffffffffffffff60408201951681520152565b03915afa90811561064957889161061c575b50156105db57506060958380518381019085825287838201528281526105c181611889565b519020918781526009845220558251948552840152820152f35b60649184519162461bcd60e51b8352820152601260248201527f736d7420726f6f74206e6f742076616c696400000000000000000000000000006044820152fd5b61063c9150833d8511610642575b61063481836118b9565b8101906119e6565b5f61059c565b503d61062a565b85513d8a823e3d90fd5b8b80fd5b8c80fd5b634e487b7160e01b8a526041845260248afd5b6106859150863d88116106425761063481836118b9565b5f6104ce565b87513d8c823e3d90fd5b865162461bcd60e51b8152808501869052601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b634e487b7160e01b895260218352602489fd5b8580fd5b50503461024b57602036600319011261024b576001600160a01b038160209367ffffffffffffffff61071f6117dc565b168152600785522054169051908152f35b5090346101a95760603660031901126101a95761074b6117dc565b91602467ffffffffffffffff8135818111610a0d5761076d903690850161180d565b9093604435838111610a0957610786903690830161196c565b959094338a526020966003885260ff898c2054169960038b10156109f75786906107b36001809d1461199a565b168b52600788526001600160a01b03898c20541680156109b75789516322bb937360e11b8152908990829081806107ed878e8c84016119fe565b03915afa908c82156109ac5761051492610824949261081192916109955750611a25565b61081e610514828b611d21565b98611d34565b928851926102009081850185811089821117610983578b52813686378c5b878110610964575050601095868110610914575b50895195898701948d908d8c885b8585106108ff575050505050508552610220850195858710908711176108ee57505083875282519020036108aa5750508452600690528220805460ff1916909117905580f35b907f70726f6f66496473206e6f7420726967687400000000000000000000000000006102646064938662461bcd60e51b855261022482015260126102448201520152fd5b634e487b7160e01b8b526041905289fd5b819084518152019201920191908c8f91610864565b805b8781106109235750610856565b5f198201828111610952579061093c61094d9288611aa3565b516109478289611aa3565b52611a71565b610916565b634e487b7160e01b8f5260118552858ffd5b8061097361097e928a85611a93565b356109478289611aa3565b610842565b634e487b7160e01b8e5260418452848efd5b61068591508c8d3d106106425761063481836118b9565b8b51903d90823e3d90fd5b6064858a85818e519362461bcd60e51b85528401528201527f636861696e206167672070726f6f66207665726966696572206e6f74207365746044820152fd5b634e487b7160e01b8c5260218552828cfd5b8880fd5b8680fd5b83346101ee57610a20366118db565b906001600160a01b0391610a38838354163314611bc6565b815b81518110156103c257806103b885610a55610a5c9486611d63565b511661207e565b610a3a565b50346101a95760603660031901126101a95781602093610aab92358152600985522054825184810190602435825260443585820152848152610aa281611889565b51902014611b7a565b5160018152f35b50503461024b578160031936011261024b576001600160a01b0360209254169051908152f35b5090346101a957826003193601126101a957338352600191602090838252610b0560ff8487205416611d77565b845460ff8160a01c16610baf5760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b610b66578580f35b8154811015610bab57806001600160a01b03610b84610ba5936117a7565b919054600392831b1c1688528452848720600260ff19825416179055611a71565b84610b5e565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b83346101ee5760203660031901126101ee57610c28610c0e6117f7565b610c236001600160a01b038454163314611bc6565b611f99565b80f35b50503461024b57602036600319011261024b5760ff816020936001600160a01b03610c546117f7565b1681526001855220541690519015158152f35b50503461024b57610c773661183e565b91936001600160a01b03610c8f818854163314611bc6565b610c9a848714611c11565b865b868110610cdd57877f4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e8888610cd78989895194859485611c86565b0390a180f35b80610cf4610cef610d32938888611a93565b611c5d565b67ffffffffffffffff610d10610d0b848c8c611a93565b611c71565b168a52600760205283858b2091166001600160a01b0319825416179055611a71565b610c9c565b5091903461024b5761012036600319011261024b57610d546117dc565b9160a03660231901126101ee5760c4359360e43567ffffffffffffffff81116101a957610d84903690830161180d565b9095610104359660ff958689168099036106eb5782865260209160068352610db0888389205416611b2e565b600554825163080cdb0b60e11b815267ffffffffffffffff909a168a880190815260a435602082018190529a91859183916001600160a01b0316908290819060400103915afa908115610f185790610e0f918991610efb575b50611ac4565b815160248035858301908152602081019b909b5260443560408c015260643560608c015260843560808c01529990610e548160a084015b03601f1981018352826118b9565b5190209387945b89861688811015610eef578a91908d811c600116610ec057610e7e908986611a93565b3585519087820192835286820152858152610e9881611889565b519020955b16898114610eae5760010194610e5b565b634e487b7160e01b8952601188528a89fd5b610ecb908986611a93565b359085519087820192835286820152858152610ee681611889565b51902095610e9d565b89610c28838514611b7a565b610f129150853d87116106425761063481836118b9565b5f610e09565b83513d8a823e3d90fd5b83346101ee57806003193601126101ee57610c283361207e565b83346101ee5760203660031901126101ee57610c28610f596117f7565b610f6e6001600160a01b038454163314611bc6565b61207e565b5091346101ee57610f83366118db565b916001600160a01b03610f9a818454163314611bc6565b825b84518110156110cd5781610fb08287611d63565b511680855260039060209180835260ff8688205416818110156110ba576110775788546801000000000000000081101561106457918961105f959492611042836110227fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849760019586820190556117a7565b90919082549060031b916001600160a01b03809116831b921b1916179055565b828a5283528789209060ff198254161790558651908152a1611a71565b610f9c565b634e487b7160e01b885260418a52602488fd5b855162461bcd60e51b8152808a01849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b885260218a52602488fd5b8380f35b50503461024b578160031936011261024b5760ff6020925460a01c1690519015158152f35b50503461024b578160031936011261024b576020906002549051908152f35b50503461024b576111253661183e565b91936001600160a01b0361113d818854163314611bc6565b611148848714611c11565b865b86811061118557877f10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b42238888610cd78989895194859485611c86565b80611197610cef6111d0938888611a93565b67ffffffffffffffff6111ae610d0b848c8c611a93565b168a52600860205283858b2091166001600160a01b0319825416179055611a71565b61114a565b50346101a957826003193601126101a95760209250549051908152f35b50346101a95760203660031901126101a95760209282913581526009845220549051908152f35b5091903461024b578160031936011261024b57338252600190602082815261124660ff8386205416611d77565b83549460ff8660a01c16156112d95760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b611294578580f35b8054841015610bab576112d3846001600160a01b036112b388976117a7565b919054600392831b1c16895284528488208660ff19825416179055611a71565b9361128c565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b50346101a957816003193601126101a9576113336117dc565b90602480359167ffffffffffffffff93848411610a0d5736602385011215610a0d57838201359085821161168a578385019484369160a0850201011161168a57601094858311611648578751966103e090818901908111898210176116365789939293523688376005546001600160a01b03169089805b85811061151f5750505050508381106114d2575b5085835b6113e35786610c2860ff886103c08901518452600660205283205416611b2e565b919486949193965b5f1988018881116114c0578110156114a35761141061140a8286611b21565b84611b10565b5161141b8286611b21565b90600191828101809111611491576114729161143a61146c9288611b10565b51865190602082019283528782015286815261145581611889565b51902092846114648d8a611b21565b911c90611b21565b85611b10565b5260028101809111156113eb57634e487b7160e01b8652601185528686fd5b634e487b7160e01b8952601188528989fd5b509491866114b5919794929597611b21565b9260011c92836113c2565b634e487b7160e01b8752601186528787fd5b5f19810190808211905b8581106114ea5750506113be565b8161150d57611508906114fd8489611b10565b51610947828a611b10565b6114dc565b634e487b7160e01b8952601184528489fd5b60808b611568858a84611533878d8d611ab4565b013584518094819263080cdb0b60e11b8352602095869584016020909392919367ffffffffffffffff60408201951681520152565b03818b5afa95861561162b5761160d966116009361158b92916116145750611ac4565b610e46611599868c8c611ab4565b35946115a6878d8d611ab4565b0135938a8c60606115d48a876115bd828688611ab4565b013593866115cc838389611ab4565b013595611ab4565b0135925196879586019889939160a0959391855260208501526040840152606083015260808201520190565b519020610947828c611b10565b8a906113aa565b610f129150833d85116106425761063481836118b9565b8351903d90823e3d90fd5b634e487b7160e01b8b5260418652868bfd5b875162461bcd60e51b8152602081860152600c818701527f73697a65206578636565647300000000000000000000000000000000000000006044820152606490fd5b8780fd5b50503461024b578160031936011261024b576020906001600160a01b03600554169051908152f35b50346101a95760203660031901126101a95735916002548310156101ee57506001600160a01b036101df60209361175e565b50346101a95760203660031901126101a957356001600160a01b039081811680910361175a577f674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f926117406020938654163314611bc6565b816001600160a01b0319600554161760055551908152a180f35b8380fd5b6002548110156117935760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156117935760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff821682036117f357565b5f80fd5b600435906001600160a01b03821682036117f357565b9181601f840112156117f35782359167ffffffffffffffff83116117f3576020808501948460051b0101116117f357565b60406003198201126117f35767ffffffffffffffff916004358381116117f3578261186b9160040161180d565b939093926024359182116117f3576118859160040161180d565b9091565b6060810190811067ffffffffffffffff8211176118a557604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176118a557604052565b6020806003198301126117f35767ffffffffffffffff916004358381116117f357816023820112156117f35780600401359384116118a5578360051b9060405194611928858401876118b9565b85526024848601928201019283116117f357602401905b82821061194d575050505090565b81356001600160a01b03811681036117f357815290830190830161193f565b9181601f840112156117f35782359167ffffffffffffffff83116117f357602083818601950101116117f357565b156119a157565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b908160209103126117f3575180151581036117f35790565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b15611a2c57565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b5f198114611a7f5760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156117935760051b0190565b9060108110156117935760051b0190565b91908110156117935760a0020190565b15611acb57565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c696420736d7420726f6f74000000000000000000000000000000006044820152606490fd5b90601f8110156117935760051b0190565b91908201809211611a7f57565b15611b3557565b60405162461bcd60e51b815260206004820152601660248201527f6d65726b6c6520726f6f74206e6f7420657869737473000000000000000000006044820152606490fd5b15611b8157565b60405162461bcd60e51b815260206004820152600c60248201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b15611bcd57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b15611c1857565b60405162461bcd60e51b815260206004820152601060248201527f6c656e677468206e6f74206d61746368000000000000000000000000000000006044820152606490fd5b356001600160a01b03811681036117f35790565b3567ffffffffffffffff811681036117f35790565b90929391806040830160408452526060820193905f905b808210611cf35750505080830360209182015281835291820192915f5b828110611cc8575050505090565b909192938435906001600160a01b0382168092036117f3579081528201938201929190600101611cba565b9091939484359067ffffffffffffffff82168092036117f35790815260209081019594019160010190611c9d565b906101a0116117f3576101800190602090565b906101c0116117f3576101a00190602090565b359060208110611d55575090565b5f199060200360031b1b1690565b80518210156117935760209160051b010190565b15611d7e57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611f855715611f41576004968754965f1990818901988911611f2e57835b8a54811015611eeb578682611e1c836117a7565b905490871b1c1614611e3657611e3190611a71565b611e08565b909192939495969798808210611ec6575b50505087548015611eb35797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611e9d611e88836117a7565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611ee392611ed6611022926117a7565b905490871b1c16916117a7565b5f8080611e47565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff6040832054166120395760025468010000000000000000811015612025576020926120097f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936110228460016040960160025561175e565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff8588205416156121f6576002805490915f19918281019081116121e257908695949392918a975b61210d575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a10156121d95781856121258c61175e565b929054600393841b1c161461214e57506121458798999a97959697611a71565b979695946120c4565b92939497969599918183106121b4575b50505050815480156121a057918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611e9d611e888361175e565b634e487b7160e01b89526031600452602489fd5b6121d0936121c46110229361175e565b9054911b1c169161175e565b5f80808061215e565b879899506120c9565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220647abdc45e4ba18c999529e57dd024956f8ca5203b58dceabe0574991ebb56bd64736f6c63430008140033",
}

// BrevisProofABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisProofMetaData.ABI instead.
var BrevisProofABI = BrevisProofMetaData.ABI

// BrevisProofBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisProofMetaData.Bin instead.
var BrevisProofBin = BrevisProofMetaData.Bin

// DeployBrevisProof deploys a new Ethereum contract, binding an instance of BrevisProof to it.
func DeployBrevisProof(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *BrevisProof, error) {
	parsed, err := BrevisProofMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisProofBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisProof{BrevisProofCaller: BrevisProofCaller{contract: contract}, BrevisProofTransactor: BrevisProofTransactor{contract: contract}, BrevisProofFilterer: BrevisProofFilterer{contract: contract}}, nil
}

// BrevisProof is an auto generated Go binding around an Ethereum contract.
type BrevisProof struct {
	BrevisProofCaller     // Read-only binding to the contract
	BrevisProofTransactor // Write-only binding to the contract
	BrevisProofFilterer   // Log filterer for contract events
}

// BrevisProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisProofSession struct {
	Contract     *BrevisProof      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisProofCallerSession struct {
	Contract *BrevisProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BrevisProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisProofTransactorSession struct {
	Contract     *BrevisProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BrevisProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisProofRaw struct {
	Contract *BrevisProof // Generic contract binding to access the raw methods on
}

// BrevisProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisProofCallerRaw struct {
	Contract *BrevisProofCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisProofTransactorRaw struct {
	Contract *BrevisProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisProof creates a new instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProof(address common.Address, backend bind.ContractBackend) (*BrevisProof, error) {
	contract, err := bindBrevisProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisProof{BrevisProofCaller: BrevisProofCaller{contract: contract}, BrevisProofTransactor: BrevisProofTransactor{contract: contract}, BrevisProofFilterer: BrevisProofFilterer{contract: contract}}, nil
}

// NewBrevisProofCaller creates a new read-only instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofCaller(address common.Address, caller bind.ContractCaller) (*BrevisProofCaller, error) {
	contract, err := bindBrevisProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisProofCaller{contract: contract}, nil
}

// NewBrevisProofTransactor creates a new write-only instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisProofTransactor, error) {
	contract, err := bindBrevisProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisProofTransactor{contract: contract}, nil
}

// NewBrevisProofFilterer creates a new log filterer instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisProofFilterer, error) {
	contract, err := bindBrevisProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisProofFilterer{contract: contract}, nil
}

// bindBrevisProof binds a generic wrapper to an already deployed contract.
func bindBrevisProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisProof *BrevisProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisProof.Contract.BrevisProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisProof *BrevisProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.Contract.BrevisProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisProof *BrevisProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisProof.Contract.BrevisProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisProof *BrevisProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisProof *BrevisProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisProof *BrevisProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisProof.Contract.contract.Transact(opts, method, params...)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) AggProofVerifierAddress(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "aggProofVerifierAddress", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.AggProofVerifierAddress(&_BrevisProof.CallOpts, arg0)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.AggProofVerifierAddress(&_BrevisProof.CallOpts, arg0)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsPauser(&_BrevisProof.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsPauser(&_BrevisProof.CallOpts, account)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofCaller) MerkleRoots(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "merkleRoots", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisProof.Contract.MerkleRoots(&_BrevisProof.CallOpts, arg0)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisProof.Contract.MerkleRoots(&_BrevisProof.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofSession) NumPausers() (*big.Int, error) {
	return _BrevisProof.Contract.NumPausers(&_BrevisProof.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisProof.Contract.NumPausers(&_BrevisProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofSession) NumProvers() (*big.Int, error) {
	return _BrevisProof.Contract.NumProvers(&_BrevisProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisProof.Contract.NumProvers(&_BrevisProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofSession) Owner() (common.Address, error) {
	return _BrevisProof.Contract.Owner(&_BrevisProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofCallerSession) Owner() (common.Address, error) {
	return _BrevisProof.Contract.Owner(&_BrevisProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofSession) Paused() (bool, error) {
	return _BrevisProof.Contract.Paused(&_BrevisProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) Paused() (bool, error) {
	return _BrevisProof.Contract.Paused(&_BrevisProof.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.PauserList(&_BrevisProof.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.PauserList(&_BrevisProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisProof.Contract.Pausers(&_BrevisProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisProof.Contract.Pausers(&_BrevisProof.CallOpts, arg0)
}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofCaller) Proofs(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "proofs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofSession) Proofs(arg0 [32]byte) ([32]byte, error) {
	return _BrevisProof.Contract.Proofs(&_BrevisProof.CallOpts, arg0)
}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofCallerSession) Proofs(arg0 [32]byte) ([32]byte, error) {
	return _BrevisProof.Contract.Proofs(&_BrevisProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisProof.Contract.ProverStates(&_BrevisProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisProof.Contract.ProverStates(&_BrevisProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.Provers(&_BrevisProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.Provers(&_BrevisProof.CallOpts, arg0)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofSession) SmtContract() (common.Address, error) {
	return _BrevisProof.Contract.SmtContract(&_BrevisProof.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofCallerSession) SmtContract() (common.Address, error) {
	return _BrevisProof.Contract.SmtContract(&_BrevisProof.CallOpts)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisProof.Contract.ValidateAggProofData(&_BrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisProof.Contract.ValidateAggProofData(&_BrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisProof.Contract.ValidateAggProofData0(&_BrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisProof.Contract.ValidateAggProofData0(&_BrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofCaller) ValidateProofAppData(opts *bind.CallOpts, _proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateProofAppData", _proofId, _appCommitHash, _appVkHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofSession) ValidateProofAppData(_proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisProof.Contract.ValidateProofAppData(&_BrevisProof.CallOpts, _proofId, _appCommitHash, _appVkHash)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) ValidateProofAppData(_proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisProof.Contract.ValidateProofAppData(&_BrevisProof.CallOpts, _proofId, _appCommitHash, _appVkHash)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.VerifierAddresses(&_BrevisProof.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.VerifierAddresses(&_BrevisProof.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPauser(&_BrevisProof.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPauser(&_BrevisProof.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPausers(&_BrevisProof.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPausers(&_BrevisProof.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddProvers(&_BrevisProof.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddProvers(&_BrevisProof.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofSession) Pause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Pause(&_BrevisProof.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Pause(&_BrevisProof.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePauser(&_BrevisProof.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePauser(&_BrevisProof.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePausers(&_BrevisProof.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePausers(&_BrevisProof.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemoveProvers(&_BrevisProof.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemoveProvers(&_BrevisProof.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisProof.Contract.RenouncePauser(&_BrevisProof.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisProof.Contract.RenouncePauser(&_BrevisProof.TransactOpts)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "submitAggProof", _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitAggProof(&_BrevisProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofTransactorSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitAggProof(&_BrevisProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofTransactor) SubmitProof(opts *bind.TransactOpts, _chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "submitProof", _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitProof(&_BrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofTransactorSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitProof(&_BrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.TransferOwnership(&_BrevisProof.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.TransferOwnership(&_BrevisProof.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofSession) Unpause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Unpause(&_BrevisProof.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Unpause(&_BrevisProof.TransactOpts)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateAggProofVerifierAddresses(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateAggProofVerifierAddresses", _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateSmtContract(&_BrevisProof.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateSmtContract(&_BrevisProof.TransactOpts, _smtContract)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateVerifierAddress", _chainIds, _verifierAddresses)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofSession) UpdateVerifierAddress(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateVerifierAddress(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateVerifierAddress(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateVerifierAddress(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// BrevisProofAggProofVerifierAddressesUpdatedIterator is returned from FilterAggProofVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for AggProofVerifierAddressesUpdated events raised by the BrevisProof contract.
type BrevisProofAggProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisProofAggProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofAggProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofAggProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofAggProofVerifierAddressesUpdated represents a AggProofVerifierAddressesUpdated event raised by the BrevisProof contract.
type BrevisProofAggProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAggProofVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) FilterAggProofVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisProofAggProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofAggProofVerifierAddressesUpdatedIterator{contract: _BrevisProof.contract, event: "AggProofVerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchAggProofVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) WatchAggProofVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofAggProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofAggProofVerifierAddressesUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAggProofVerifierAddressesUpdated is a log parse operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) ParseAggProofVerifierAddressesUpdated(log types.Log) (*BrevisProofAggProofVerifierAddressesUpdated, error) {
	event := new(BrevisProofAggProofVerifierAddressesUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisProof contract.
type BrevisProofOwnershipTransferredIterator struct {
	Event *BrevisProofOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisProof contract.
type BrevisProofOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisProofOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisProofOwnershipTransferredIterator{contract: _BrevisProof.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisProofOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofOwnershipTransferred)
				if err := _BrevisProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisProofOwnershipTransferred, error) {
	event := new(BrevisProofOwnershipTransferred)
	if err := _BrevisProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisProof contract.
type BrevisProofPausedIterator struct {
	Event *BrevisProofPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPaused represents a Paused event raised by the BrevisProof contract.
type BrevisProofPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisProofPausedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPausedIterator{contract: _BrevisProof.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisProofPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPaused)
				if err := _BrevisProof.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePaused(log types.Log) (*BrevisProofPaused, error) {
	event := new(BrevisProofPaused)
	if err := _BrevisProof.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisProof contract.
type BrevisProofPauserAddedIterator struct {
	Event *BrevisProofPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPauserAdded represents a PauserAdded event raised by the BrevisProof contract.
type BrevisProofPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisProofPauserAddedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPauserAddedIterator{contract: _BrevisProof.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisProofPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPauserAdded)
				if err := _BrevisProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePauserAdded(log types.Log) (*BrevisProofPauserAdded, error) {
	event := new(BrevisProofPauserAdded)
	if err := _BrevisProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisProof contract.
type BrevisProofPauserRemovedIterator struct {
	Event *BrevisProofPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPauserRemoved represents a PauserRemoved event raised by the BrevisProof contract.
type BrevisProofPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisProofPauserRemovedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPauserRemovedIterator{contract: _BrevisProof.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisProofPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPauserRemoved)
				if err := _BrevisProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePauserRemoved(log types.Log) (*BrevisProofPauserRemoved, error) {
	event := new(BrevisProofPauserRemoved)
	if err := _BrevisProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisProof contract.
type BrevisProofProverAddedIterator struct {
	Event *BrevisProofProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofProverAdded represents a ProverAdded event raised by the BrevisProof contract.
type BrevisProofProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisProofProverAddedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisProofProverAddedIterator{contract: _BrevisProof.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisProofProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofProverAdded)
				if err := _BrevisProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) ParseProverAdded(log types.Log) (*BrevisProofProverAdded, error) {
	event := new(BrevisProofProverAdded)
	if err := _BrevisProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisProof contract.
type BrevisProofProverRemovedIterator struct {
	Event *BrevisProofProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofProverRemoved represents a ProverRemoved event raised by the BrevisProof contract.
type BrevisProofProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisProofProverRemovedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisProofProverRemovedIterator{contract: _BrevisProof.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisProofProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofProverRemoved)
				if err := _BrevisProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) ParseProverRemoved(log types.Log) (*BrevisProofProverRemoved, error) {
	event := new(BrevisProofProverRemoved)
	if err := _BrevisProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofSmtContractUpdatedIterator is returned from FilterSmtContractUpdated and is used to iterate over the raw logs and unpacked data for SmtContractUpdated events raised by the BrevisProof contract.
type BrevisProofSmtContractUpdatedIterator struct {
	Event *BrevisProofSmtContractUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofSmtContractUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofSmtContractUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofSmtContractUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofSmtContractUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofSmtContractUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofSmtContractUpdated represents a SmtContractUpdated event raised by the BrevisProof contract.
type BrevisProofSmtContractUpdated struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtContractUpdated is a free log retrieval operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) FilterSmtContractUpdated(opts *bind.FilterOpts) (*BrevisProofSmtContractUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofSmtContractUpdatedIterator{contract: _BrevisProof.contract, event: "SmtContractUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtContractUpdated is a free log subscription operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) WatchSmtContractUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofSmtContractUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofSmtContractUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtContractUpdated is a log parse operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) ParseSmtContractUpdated(log types.Log) (*BrevisProofSmtContractUpdated, error) {
	event := new(BrevisProofSmtContractUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisProof contract.
type BrevisProofUnpausedIterator struct {
	Event *BrevisProofUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofUnpaused represents a Unpaused event raised by the BrevisProof contract.
type BrevisProofUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisProofUnpausedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisProofUnpausedIterator{contract: _BrevisProof.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisProofUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofUnpaused)
				if err := _BrevisProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) ParseUnpaused(log types.Log) (*BrevisProofUnpaused, error) {
	event := new(BrevisProofUnpaused)
	if err := _BrevisProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofVerifierAddressesUpdatedIterator is returned from FilterVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for VerifierAddressesUpdated events raised by the BrevisProof contract.
type BrevisProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofVerifierAddressesUpdated represents a VerifierAddressesUpdated event raised by the BrevisProof contract.
type BrevisProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) FilterVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "VerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofVerifierAddressesUpdatedIterator{contract: _BrevisProof.contract, event: "VerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) WatchVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "VerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofVerifierAddressesUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "VerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierAddressesUpdated is a log parse operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) ParseVerifierAddressesUpdated(log types.Log) (*BrevisProofVerifierAddressesUpdated, error) {
	event := new(BrevisProofVerifierAddressesUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "VerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestMetaData contains all meta data concerning the BrevisRequest contract.
var BrevisRequestMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"contractIBrevisProof\",\"name\":\"_brevisProof\",\"type\":\"address\"},{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enumIBrevisRequest.DisputeStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AskFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"from\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"}],\"name\":\"BaseDataUrlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BrevisProofUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChallengeWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataAvailabilityProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataValidityProofProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForData\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForProof\",\"type\":\"uint256\"}],\"name\":\"DisputeDepositsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"appCommitHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"appVkHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OpRequestsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestCallbackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"RequestDataPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"RequestFeeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structIBrevisRequest.Callback\",\"name\":\"callback\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enumIBrevisRequest.RequestOption\",\"name\":\"option\",\"type\":\"uint8\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RequestTimeoutUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"}],\"name\":\"RequestsCallbackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"}],\"name\":\"RequestsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ResponseTimeoutUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"applyBrevisAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_callbackTargets\",\"type\":\"address[]\"}],\"name\":\"applyBrevisAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"applyBrevisProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataValidityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForRequestData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseDataURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisProof\",\"outputs\":[{\"internalType\":\"contractIBrevisProof\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"}],\"name\":\"dataURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAskForData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAskForProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputes\",\"outputs\":[{\"internalType\":\"enumIBrevisRequest.DisputeStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"structIBrevisRequest.RequestDataHash\",\"name\":\"requestDataHash\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"responseDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"fulfillOpRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"fulfillRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_callbackTargets\",\"type\":\"address[]\"}],\"name\":\"fulfillRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProofContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_addGas\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_currentFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"}],\"name\":\"increaseGasFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"onchainRequests\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"feeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"internalType\":\"structIBrevisRequest.Callback\",\"name\":\"callback\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"opdata\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"postDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"postDataValidityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_done\",\"type\":\"bool\"}],\"name\":\"postRequestData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"queryRequestStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisRequest.RequestStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_appChallengeWindow\",\"type\":\"uint256\"}],\"name\":\"queryRequestStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisRequest.RequestStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"queryRequestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"enumIBrevisRequest.RequestStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"responseTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"internalType\":\"structIBrevisRequest.Callback\",\"name\":\"_callback\",\"type\":\"tuple\"},{\"internalType\":\"enumIBrevisRequest.RequestOption\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"sendRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setBaseDataURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisProof\",\"type\":\"address\"}],\"name\":\"setBrevisProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_challengeWindow\",\"type\":\"uint256\"}],\"name\":\"setChallengeWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amtAskForData\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amtAskForProof\",\"type\":\"uint256\"}],\"name\":\"setDisputeDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"setRequestTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_responseTimeout\",\"type\":\"uint256\"}],\"name\":\"setResponseTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_appChallengeWindow\",\"type\":\"uint256\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a034620001eb57601f6200571938819003918201601f191683019291906001600160401b03841183851017620001ef578160609284926040968752833981010312620001eb5780516001600160a01b03919082811690819003620001eb5760208083015192848416809403620001eb57850151938085168503620001eb575f9081549360018060a01b031994338682161784558851923391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08580a3600180546001600160a81b031916919091179055338252600283528682205460ff16620001a957506003546801000000000000000081101562000195576001810180600355811015620001815781879160037f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89594528382200133868254161790553381526002835220600160ff198254161790558551338152a1600654161760065560805251615515908162000204823960805181818161276e0152613f480152f35b634e487b7160e01b82526032600452602482fd5b634e487b7160e01b82526041600452602482fd5b62461bcd60e51b815260048101839052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c806301c1aa0d146103ef5780630dbeefaf146103ea57806311be1997146103e5578063158535ff146103e0578063191fa9b6146103db57806325cda16d146103d65780632b256c68146103d157806334fc1d2b146103cc5780633f20b4c9146103c75780633f4ba83a146103c257806346fbf68e146103815780634f4fef18146103bd57806358a16b44146103b85780635c975abb146103b3578063622b6af4146103ae57806365a58753146103a9578063666d1651146103a4578063677625f21461039f57806369dc19031461039a5780636b2c0f55146103955780636ef8d66d146103905780637a784a1c1461038b5780637ff7b0d21461038657806380f51c121461038157806382dc1ec41461037c5780638456cb59146103775780638522feab14610372578063861a14121461036d57806387c2f360146103685780638cd2ed66146103635780638da5cb5b1461035e57806395b40861146103595780639bdf0469146103545780639d8669851461034f578063a036e7991461034a578063a17ed96c14610345578063a42dce8014610340578063a65b3c061461033b578063a66f791714610336578063ac225f5414610331578063b33e1a391461032c578063bc7c205014610327578063c2eaa93114610322578063c33529ae1461031d578063c415b95c14610318578063c49af0fa14610313578063c5d129141461030e578063c772c87f14610309578063c7f5aaa014610304578063c8c8a05a14610304578063ccf2683b146102ff578063cd978249146102fa578063d3c22a3a146102f5578063e6c6fcec146102f0578063e79b7a51146102eb578063eab8d3a7146102e6578063f2fde38b146102e1578063f4a5b35d146102dc578063fabc74f5146102d7578063fb22b7a8146102d2578063fc0cfccc146102cd5763fd1190ea0361000e576130ad565b612f0e565b612e4b565b612e03565b612ddc565b612cfb565b612bc7565b612b79565b612b2b565b6129ec565b612792565b61274f565b612729565b612698565b61242b565b6123d3565b61237f565b61214d565b612123565b611f1a565b611ebc565b611da6565b611d70565b611d33565b611ca2565b611c85565b611c37565b611bf3565b611b6a565b61198f565b611960565b6118d5565b611801565b6117b4565b611742565b61167d565b611643565b610faf565b61157a565b6113e8565b61137e565b611344565b6112d7565b6111ba565b6110fc565b6110bc565b61104f565b61102a565b61100d565b610ff0565b610e8a565b610e6d565b610e50565b610cb3565b610c84565b6108e6565b61086f565b610734565b6104b3565b34610461576020366003190112610461577fedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a76004356104396001600160a01b035f54163314614773565b600a5481600a5561045c6040519283928360209093929193604081019481520152565b0390a1005b5f80fd5b9181601f84011215610461578235916001600160401b038311610461576020838186019501011161046157565b6001600160a01b0381160361046157565b61014435906104b182610492565b565b346104615760a0366003190112610461576044356024356064356001600160401b038111610461576104e9903690600401610465565b9091608435906104f882610492565b61051961050d6006546001600160a01b031690565b6001600160a01b031690565b604051630901783760e41b8152600480359082015260248101879052604481018390529590602090879060649082905afa9384156105f7576105af5f966105808897946100189a89966105c9575b506105733686856113b2565b60208151910120146133b7565b6105a16040519384926020840197633ceb5b5160e11b8952602485016145b2565b03601f19810183528261065e565b51925af16105c36105be613cce565b61502e565b906145c9565b6105e99060203d81116105f0575b6105e1818361065e565b81019061459d565b505f610567565b503d6105d7565b613360565b634e487b7160e01b5f52604160045260245ffd5b604081019081106001600160401b0382111761062b57604052565b6105fc565b6001600160401b03811161062b57604052565b602081019081106001600160401b0382111761062b57604052565b90601f801991011681019081106001600160401b0382111761062b57604052565b604051906104b182610610565b634e487b7160e01b5f52602160045260245ffd5b600711156106aa57565b61068c565b9060078210156106aa5752565b929594939190836106cc916106af565b602060a08185015260e0840191805192604060a087015283518091528261010087019401905f5b81811061072057505050015160c084015260408301959095526001600160a01b0316606082015260800152565b8251865294840194918401916001016106f3565b3461046157602080600319360112610461576004355f526010815260405f209060ff825416600192838101926040519361076d85610610565b60405180968383549283815201925f52835f20915f5b8181106107d95788886107d589898e61079e818c038261065e565b855260028201549085015260038101549060056107c560048301546001600160a01b031690565b91015491604051958695866106bc565b0390f35b8354855293850193928201928201610783565b634e487b7160e01b5f52603260045260245ffd5b6005548110156108355760055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001905f90565b6107ec565b6003548110156108355760035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01905f90565b3461046157602036600319011261046157600435600354811015610461576001600160a01b0360209160035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015416604051908152f35b6001600160401b0381160361046157565b604435906104b1826108c8565b60c036600319011261046157602435600435610901826108c8565b6044359161090e83610492565b60403660631901126104615760a435906002821015610461578391604051936020850185610955858484906028926001600160c01b031991835260c01b1660208201520190565b0395610969601f199788810183528261065e565b519020610988610981825f52600860205260405f2090565b5460ff1690565b61099181611bdc565b61099b8115613106565b6109a484613152565b83610ab3577fa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad97610a18826109e06001600160a01b0394611bdc565b6109f26109eb61067f565b918261315c565b426001600160401b03166020820152610a13855f52600860205260405f2090565b613168565b1615610aab575b610a9d90610a9861045c959697604051610a6d602082019282610a618d3487909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b0390810183528261065e565b51902091610a7961067f565b928352610a85366131aa565b60208401525f52600960205260405f2090565b6131e5565b604051948594349286613252565b339450610a1f565b50610abd83613152565b60018303610af9576001600160a01b037fa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad97610a1860036109e0565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964206f7074696f6e0000000000000000000000000000000000006044820152606490fd5b0390fd5b5f91031261046157565b90600182811c92168015610b7a575b6020831014610b6657565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610b5b565b604051905f82600e5491610b9783610b4c565b80835292600190818116908115610c1c5750600114610bbe575b506104b19250038361065e565b600e5f90815291507fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fd5b848310610c0157506104b193505081016020015f610bb1565b81935090816020925483858a01015201910190918592610be8565b9050602092506104b194915060ff191682840152151560051b8201015f610bb1565b5f5b838110610c4f5750505f910152565b8181015183820152602001610c40565b90602091610c7881518092818552858086019101610c3e565b601f01601f1916010190565b34610461575f366003190112610461576107d5610c9f610b84565b604051918291602083526020830190610c5f565b6040366003190112610461576004357f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6610e0c602435610cf2816108c8565b610cff600d54341161425e565b6040516020810190610d2e816105a1858986906028926001600160c01b031991835260c01b1660208201520190565b519020610dad610d58610d49835f52600860205260405f2090565b925f52601060205260405f2090565b91610da0610d99825460ff8116610d6e81611bdc565b60048114908115610e11575b50610d84906144b9565b6001600160401b03600a549160081c16613db7565b42106142f6565b805460ff19166005179055565b805460ff19166005178155610dc4600b5442613db7565b60038201556004810180546001600160a01b0319163317905534600591820155604080516001600160401b039093168352602083019190915233908201529081906060820190565b0390a2005b60059150610e1e81611bdc565b1480610e2d575b610d84610d7a565b50610d846005610e3e885460ff1690565b610e47816106a0565b14159050610e25565b34610461575f366003190112610461576020600c54604051908152f35b34610461575f366003190112610461576020600754604051908152f35b34610461575f80600319360112610fac573381526002602052610eb360ff604083205416614cf5565b6001805460ff8160a01c1615610f675760ff60a01b191681557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a181815b610f01578280f35b600554811015610f635780610f58610f4b610f34610f21610f5d95610800565b90546001600160a01b039160031b1c1690565b6001600160a01b03165f52600460205260405f2090565b805460ff19166001179055565b613a43565b81610ef9565b8280f35b60405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b80fd5b34610461576020366003190112610461576001600160a01b03600435610fd481610492565b165f526002602052602060ff60405f2054166040519015158152f35b34610461575f366003190112610461576020600554604051908152f35b34610461575f366003190112610461576020600354604051908152f35b34610461575f36600319011261046157602060ff60015460a01c166040519015158152f35b34610461576020366003190112610461577f87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a636004356110996001600160a01b035f54163314614773565b6007548160075561045c6040519283928360209093929193604081019481520152565b346104615760803660031901126104615760206110f26024356110de816108c8565b600a54906064359060443590600435614c01565b6040519015158152f35b34610461576020366003190112610461576107d5610c9f600435614920565b6001600160401b03811161062b5760051b60200190565b60208060031983011261046157600435916001600160401b038311610461578060238401121561046157826004013561116a8161111b565b93611178604051958661065e565b81855260248486019260051b82010192831161046157602401905b8282106111a1575050505090565b83809183356111af81610492565b815201910190611193565b34610461576111c836611132565b6001600160a01b03905f916111e1818454163314614773565b825b82518110156112d357816111f78285613bea565b5116808552600460209080825260409160ff838920541660038110156106aa57611293575050611286827fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849261125061128e9695614d41565b61126e610f4b836001600160a01b03165f52600460205260405f2090565b516001600160a01b0390911681529081906020820190565b0390a1613a43565b6111e3565b606492519162461bcd60e51b8352820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b8380f35b34610461576020366003190112610461577f86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f2222706004356113216001600160a01b035f54163314614773565b600b5481600b5561045c6040519283928360209093929193604081019481520152565b346104615760203660031901126104615761001860043561136481610492565b6113796001600160a01b035f54163314614773565b6153b8565b34610461575f36600319011261046157610018336153b8565b6001600160401b03811161062b57601f01601f191660200190565b9291926113be82611397565b916113cc604051938461065e565b829481845281830111610461578281602093845f960137010152565b3461046157602080600319360112610461576001600160401b039060043582811161046157366023820112156104615761142c9036906024816004013591016113b2565b5f916114436001600160a01b038454163314614773565b61144b610b84565b90825194851161062b5761146985611464600e54610b4c565b6147be565b80601f86116001146114d65750938084957fe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f95916114cb575b508160011b915f199060031b1c191617600e555b6114c56040519283928361482e565b0390a180f35b90508301515f6114a2565b600e5f5290601f1986167fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fd9286905b8282106115625750509186917fe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f96976001941061154a575b5050811b01600e556114b6565b8501515f1960f88460031b161c191690555f8061153d565b80600185968294968a01518155019501930190611505565b346104615760403660031901126104615760243560043561159a82610492565b6001600160a01b03806001541633036115fe577ff10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186916040915f946115ef86808080878661c350f16115e9613cce565b50613e62565b8351928352166020820152a180f35b60405162461bcd60e51b815260206004820152601160248201527f6e6f742066656520636f6c6c6563746f720000000000000000000000000000006044820152606490fd5b346104615760203660031901126104615761001860043561166381610492565b6116786001600160a01b035f54163314614773565b615264565b34610461575f80600319360112610fac5733815260026020526116a660ff604083205416614cf5565b60017401000000000000000000000000000000000000000060ff60a01b1982546116d660ff8260a01c1615613ddf565b161781557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a181815b61170f578280f35b600554811015610f635780610f5861172f610f34610f2161173c95610800565b805460ff19166002179055565b81611707565b346104615760403660031901126104615760243561175f816108c8565b60405161178f816105a1602082019460043586906028926001600160c01b031991835260c01b1660208201520190565b5190205f52600860205260206001600160401b0360405f205460081c16604051908152f35b34610461575f366003190112610461576020600a54604051908152f35b9181601f84011215610461578235916001600160401b038311610461576020808501948460051b01011161046157565b346104615760e03660031901126104615760046001600160401b0381358181116104615761183290369084016117d1565b916024358181116104615761184a90369086016117d1565b6044929192358281116104615761186490369088016117d1565b6064929192358481116104615761187e9036908a016117d1565b91608435868111610461576118969036908c016117d1565b95909460a435888111610461578c6118b0913691016117d1565b99909860c435908111610461576100189d6118cd913691016117d1565b9c909b613eae565b3461046157610160366003190112610461576004356118f3816108c8565b60a0366023190112610461576001600160401b039060e435828111610461576119209036906004016117d1565b906101043560ff8116810361046157610124359485116104615761194b610018953690600401610465565b9390926119566104a3565b9560c435906146bc565b34610461575f3660031901126104615760206001600160a01b035f5416604051908152f35b8015150361046157565b346104615760a0366003190112610461576024356004356119af826108c8565b6044356001600160401b038111610461576119ce9036906004016117d1565b926084356064356119de82611985565b335f5260206004815260ff60405f20541660038110156106aa576001611a0491146132b6565b60405181810187815260c086901b6001600160c01b031916602082015281602882010391611a3a601f199384810183528261065e565b519020611a4f815f52600860205260405f2090565b611a806005611a71611a69855f52601060205260405f2090565b935460ff1690565b611a7a81611bdc565b14614342565b611a9f6001611a90835460ff1690565b611a99816106a0565b1461438e565b6001810193611ab0868654146143da565b5f5b8b8110611b3c5750917f635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874999a939187969593610e0c98611afe575b505050505060405195869586614485565b611b3294610a61611b1e61172f9660029460405193849182018096614452565b5190209101555f52601060205260405f2090565b5f80808080611aed565b80610f58611b59611b528f94611b65958f613a7f565b36916113b2565b84815191012088614426565b611ab2565b34610461576040366003190112610461577f56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af260043560243590611bb86001600160a01b035f54163314614773565b80600c5581600d5561045c6040519283928360209093929193604081019481520152565b600911156106aa57565b9060098210156106aa5752565b34610461576020366003190112610461576004355f5260086020526040805f20546001600160401b03825191611c2c8360ff8316611be6565b60081c166020820152f35b3461046157611c4536611132565b6001600160a01b0390611c5c825f54163314614773565b5f5b81518110156100185780610f5884611c79611c809486613bea565b51166153b8565b611c5e565b34610461575f366003190112610461576020600b54604051908152f35b34610461576020366003190112610461577f5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38600435611ce081610492565b6001600160a01b0390611cf7825f54163314614773565b600180548284166001600160a01b031982161790915560408051939091166001600160a01b03908116845290911660208301528190810161045c565b34610461576040366003190112610461576020611d61602435611d55816108c8565b600a5490600435614ac1565b611d6e6040518092611be6565bf35b346104615760a03660031901126104615760206110f2602435611d92816108c8565b608435906064359060443590600435614c01565b6040366003190112610461576004357f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6610e0c602435611de5816108c8565b611df2600c54341161425e565b6040516020810190611e21816105a1858986906028926001600160c01b031991835260c01b1660208201520190565b519020611e5d611e3c610d49835f52600860205260405f2090565b91610da0610d998254610d84600460ff8316611e5781611bdc565b146142aa565b805460ff19166001178155611e74600b5442613db7565b60038201556004810180546001600160a01b031916331790553460059190910155604080516001600160401b0390921682526001602083015233908201529081906060820190565b34610461576060366003190112610461576020611d61602435611ede816108c8565b60443590600435614ac1565b9181601f84011215610461578235916001600160401b0383116104615760208085019460a0850201011161046157565b3461046157608036600319011261046157600435611f37816108c8565b60246001600160401b03813581811161046157611f58903690600401611eea565b909260443583811161046157611f729036906004016117d1565b909360643590811161046157611f8c9036906004016117d1565b919094611fa461050d6006546001600160a01b031690565b96873b15610461576040978851998a8092633bda38a360e01b8252815f9d8e948c886004840192611fd49361396f565b03915afa80156105f75761210a575b50885b868110611ff1578980f35b89868a868a8c8a898961201061050d61200b8c8688613a6f565b613aca565b61202c575b50505050505050505061202790613a43565b611fe6565b9289899896938693828a612044828e9b819e9b613a56565b01359661205092613a7f565b369061205b926113b2565b9485516020809701201461206e906133b7565b61207792613a6f565b61208090613aca565b9561208b918b613a56565b6060013561209a898d8d613a7f565b909351938493840196633ceb5b5160e11b88528401926120b9936145b2565b03601f19810182526120cb908261065e565b51925af16120d7613cce565b6120e08361513b565b906120ea9061502e565b6120f39161460c565b6120fc916145c9565b89868a868a8c8a8989612015565b8061211761211d92610630565b80610b42565b5f611fe3565b34610461576020366003190112610461576004355f52600f602052602060405f2054604051908152f35b60a0366003190112610461577f26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6602435600435612189826108c8565b61045c604435612198816108c8565b6122f06001606435608435936121ad85610492565b6122cf6121e76122c461229561223e8b8d604051958691602083019384906028926001600160c01b031991835260c01b1660208201520190565b03946121fb601f199687810183528261065e565b519020612230612216610981835f52600860205260405f2090565b61221f81611bdc565b8a811490811561236b575b50613106565b5f52600960205260405f2090565b9561228e87548b6040516122858161227960208201948886909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b0389810183528261065e565b51902014613d6b565b3490613db7565b976040519182918a60208401909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b03918201815261065e565b6001600160401b038116612320575b50015460a01c6001600160401b031690565b604051948594859094939291606092608083019683526001600160401b0380921660208401521660408201520152565b81830180546123659261233e9160a01c6001600160401b0316613dc4565b67ffffffffffffffff60a01b1967ffffffffffffffff60a01b83549260a01b169116179055565b5f6122de565b6003915061237881611bdc565b145f61222a565b34610461575f3660031901126104615760206001600160a01b0360015416604051908152f35b906040516123b281610610565b91546001600160a01b038116835260a01c6001600160401b03166020830152565b34610461576020366003190112610461576004355f526009602052606060405f206001600160401b03602061240c6001845494016123a5565b6040519384526001600160a01b03815116828501520151166040820152f35b346104615760803660031901126104615760243560043561244b826108c8565b604435612457816108c8565b6064356001600160401b03811161046157612476903690600401610465565b9190935f94338652600460205260ff6040872054169060038210156106aa576124a4600161256993146132b6565b604051606060208201826124d1878b84906028926001600160c01b031991835260c01b1660208201520190565b03926124e5601f199485810183528261065e565b519020966124fb885f52600860205260405f2090565b9661250e895f52601060205260405f2090565b94600561251c8a5460ff1690565b61252581611bdc565b1480612676575b612535906144b9565b8b61254b61050d6006546001600160a01b031690565b926040519889958694859363e044095360e01b85526004850161333d565b03925af19485156105f75761172f612623968a6125fc947f8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc69a612609988d84918596612629575b506125f3926125c7610a6195936125d59314614505565b5f52600f60205260405f2090565b54946040519384916020830196879091604092825260208201520190565b51902014614551565b805460ff19166006179055565b6040516001600160401b0390911681529081906020820190565b0390a280f35b6125d59196506125c79550610a619492509261265e6125f39460603d811161266f575b612656818361065e565b810190613302565b9791909798935093955050926125b0565b503d61264c565b506125356005612687885460ff1690565b612690816106a0565b14905061252c565b34610461576020366003190112610461577fddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec186004356126d681610492565b6001600160a01b03906126ed825f54163314614773565b600680548284166001600160a01b031982161790915560408051939091166001600160a01b03908116845290911660208301528190810161045c565b34610461575f3660031901126104615760206001600160a01b0360065416604051908152f35b34610461575f3660031901126104615760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b346104615760c0366003190112610461576004356024356127b2816108c8565b604435906127bf826108c8565b6001600160401b0392606435848111610461576127e0903690600401610465565b94608435908111610461576127f9903690600401610465565b94909160a4359161280983610492565b5f97338952600460205260ff60408a2054169160038310156106aa5761286b936128376001606095146132b6565b8a61284d61050d6006546001600160a01b031690565b926040519687958694859363e044095360e01b85526004850161333d565b03925af19182156105f7577fc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f9661293894612934948a8b958c926129c3575b506128b690891461336b565b60405160208101906128e5816105a18d8d86906028926001600160c01b031991835260c01b1660208201520190565b519020936128fb855f52600860205260405f2090565b9561292861290a885460ff1690565b9761291489611bdc565b6001891480156129b2575b61172f90613106565b8461299d575b506149d1565b1590565b61295e575b604080519182526001600160401b03909216602082015290819081016114c5565b604080518281526001600160401b03841660208201527f65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a9190a161293d565b6129ac906105733687876113b2565b5f61292e565b506129bc89611bdc565b881561291f565b90506128b695506129e2915060603d811161266f57612656818361065e565b95909591906128aa565b6040366003190112610461576004357f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6610e0c602435612a2b816108c8565b612a38600d54341161425e565b6040516020810190612a67816105a1858986906028926001600160c01b031991835260c01b1660208201520190565b519020612aaa612a82610d49835f52600860205260405f2090565b91610da0610d998254600560ff8216612a9a81611bdc565b1480612b09575b610d84906144b9565b805460ff19166003178155612ac1600b5442613db7565b60038201556004810180546001600160a01b031916331790553460059190910155604080516001600160401b0390921682526003602083015233908201529081906060820190565b50610d846002612b1a885460ff1690565b612b23816106a0565b149050612aa1565b3461046157612b3936611132565b6001600160a01b0390612b50825f54163314614773565b5f5b81518110156100185780610f5884612b6d612b749486613bea565b5116614eb8565b612b52565b3461046157612b8736611132565b6001600160a01b0390612b9e825f54163314614773565b5f5b81518110156100185780610f5884612bbb612bc29486613bea565b5116615264565b612ba0565b3461046157606036600319011261046157602435600435612be7826108c8565b6044356001600160401b03811161046157612c06903690600401610465565b50505f91338352600460205260ff60408420541660038110156106aa577fa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e91612c54600161262393146132b6565b612609612cd66040516020810190612c89816105a1878b86906028926001600160c01b031991835260c01b1660208201520190565b5190208088526008602052612cc86040892060106020526005612cb160408c20925460ff1690565b612cba81611bdc565b149081612ce3575b506144b9565b5f52601060205260405f2090565b805460ff19166004179055565b546003915060ff16612cf4816106a0565b145f612cc2565b3461046157602036600319011261046157600435612d1881610492565b5f908154906001600160a01b0380831691612d34338414614773565b16918215612d71576001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b34610461575f366003190112610461576020600d54604051908152f35b600311156106aa57565b34610461576020366003190112610461576001600160a01b03600435612e2881610492565b165f52600460205260ff60405f20541660405160038210156106aa576020918152f35b346104615760e03660031901126104615760046001600160401b03813581811161046157612e7c90369084016117d1565b9160243581811161046157612e9490369086016117d1565b612e9f9291926108d9565b9060643583811161046157612eb79036908901610465565b9060843585811161046157612ecf9036908b01611eea565b94909360a43587811161046157612ee99036908d016117d1565b98909760c435908111610461576100189c612f06913691016117d1565b9b909a613403565b34610461576080366003190112610461576004357f6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f602435612f4f816108c8565b6044359261293d6130a0606435612f6581610492565b612f7760ff60015460a01c1615613ddf565b6130926040519161307f6020840184612fa98a8a84906028926001600160c01b031991835260c01b1660208201520190565b0394612fbd601f199687810183528261065e565b5190209361303561302e61301c6020612fe6612fe18a5f52600860205260405f2090565b613e2b565b61300e8151612ff481611bdc565b612ffd81611bdc565b6001811490811561236b5750613106565b01516001600160401b031690565b6001600160401b036007549116613db7565b4211613e5b565b8a613048865f52600960205260405f2090565b54916122856040519182610a6188602083019687909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b5f8080809b819461c350f16115e9613cce565b5f52600860205260405f2090565b805460ff19166008179055565b3461046157602036600319011261046157600435600554811015610461576001600160a01b0360209160055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0015416604051908152f35b1561310d57565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964207374617475730000000000000000000000000000000000006044820152606490fd5b600211156106aa57565b60098210156106aa5752565b9080519060098210156106aa5768ffffffffffffffff00602060ff85549416928360ff198616178655015160081b169168ffffffffffffffffff191617179055565b604090606319011261046157604051906131c382610610565b816064356131d081610492565b81526020608435916131e1836108c8565b0152565b906001600160401b0360208060016104b19585518155019301516132296001600160a01b0382511685906001600160a01b03166001600160a01b0319825416179055565b0151825467ffffffffffffffff60a01b1916911660a01b67ffffffffffffffff60a01b16179055565b929095949360e084019684526001600160401b0380931660208501526001600160a01b038092166040850152606084015260643561328f81610492565b1660808301526084356132a1816108c8565b1660a082015260028210156106aa5760c00152565b156132bd57565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b90816060910312610461578051916040602083015192015190565b908060209392818452848401375f828201840152601f01601f1916010190565b6040906001600160401b0361335d9593168152816020820152019161331d565b90565b6040513d5f823e3d90fd5b1561337257565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c69642070726f6f66496400000000000000000000000000000000006044820152606490fd5b156133be57565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c69642063697263756974206f7574707574000000000000000000006044820152606490fd5b99929893919c9b95909a9694335f52600460205260ff60405f20541660038110156106aa57600161343491146132b6565b61344961050d6006546001600160a01b031690565b90813b15610461575f918d838e6134776040519788968795869463b4f7a72760e01b86528c6004870161393a565b03925af180156105f757613903575b5061349c61050d6006546001600160a01b031690565b803b1561046157875f91866134c89460405195869485938493633bda38a360e01b85526004850161396f565b03915afa80156105f7576138f0575b50600184148080156138e7575b8785888f8c908f8f6134f68a986139e3565b8c5f978c5f985b858a10613664575050505050505050505061351a91501515613b6c565b61355d575b505050505050613558907f5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0949560405194859485613d44565b0390a1565b61356f869b9398959a97949996613bb8565b985f5b8a518110156135a657808b61359b8f9360606135938f6135a1978491613a56565b013592613bea565b52613a43565b613572565b50613558979b505f94969991859496995061360b6135e961200b87947f5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f09f613a66565b946105a16040519384926020840197630ef280bf60e21b895260248501613c80565b51925af1613617613cce565b501561362a575b959481925f808061351f565b7ff97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e766040518061365c85858a8a85613d44565b0390a161361e565b8b876105a16136ff61371e9f6136d18f8e6136ca828f8f6136c58f8f908f866136d69c60406136bd8386866136b88c6136b18f86906136aa826105739f611b529f613a56565b3593613a6f565b351461336b565b613a56565b013594613a7f565b613a6f565b3596613a6f565b613ac0565b604051928391602083019586906028926001600160c01b031991835260c01b1660208201520190565b51902093613715855f52600860205260405f2090565b9d8e5460ff1690565b9561372887611bdc565b600187149b8c80156138d6575b613764575b50505050505050505050505050613752919250613a43565b908391888f8c908f8f8c8f8c8e6134fd565b8d98999a9b9c9f6137529f610f5861378392600260ff19825416179055565b9f600183111561384157506137c097959360606136bd8b6129349a98966137b261200b836137b8998199613a6f565b97613a56565b9290916149d1565b6137e3575b50505050505b82918f8c908f8f5f8f8f8f8f908f928f91859161373a565b7f65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a946138168261381d956136d195613a6f565b3594613a6f565b604080519283526001600160401b0391909116602083015290a18a8f8e8e846137c5565b99509b5099505050505093506138579150611bdc565b613864575b5050506137cb565b60206001600160401b039261300e6138ce956001600160a01b036138bf61050d61200b6138a760016138a16138c79b5f52600960205260405f2090565b016123a5565b966138b988516001600160a01b031690565b95613a66565b911614613ad4565b1615613b20565b88885f61385c565b506138e088611bdc565b8715613735565b50848a146134e4565b806121176138fd92610630565b5f6134d7565b8061211761391092610630565b5f613486565b90918281526001600160fb1b0383116104615760209260051b809284830137010190565b939161335d95936001600160401b0361396193168652606060208701526060860191613916565b92604081850391015261331d565b9192906040926001600160401b038482019216815282602092858484015252606080910194935f925b8484106139a85750505050505090565b853587528581013587820152858201358783015285830135878401526080808701359088015260a09687019690950194600190930192613998565b156139ea57565b60405162461bcd60e51b815260206004820152601760248201527f696e76616c69642063616c6c6261636b206c656e6774680000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f198114613a515760010190565b613a2f565b91908110156108355760a0020190565b90156108355790565b91908110156108355760051b0190565b91908110156108355760051b81013590601e19813603018212156104615701908135916001600160401b038311610461576020018236038113610461579190565b3561335d816108c8565b3561335d81610492565b15613adb57565b60405162461bcd60e51b815260206004820152601160248201527f63616c6c6261636b206d69736d617463680000000000000000000000000000006044820152606490fd5b15613b2757565b60405162461bcd60e51b815260206004820152601e60248201527f696e76616c69642067617320666f722062617463682063616c6c6261636b00006044820152606490fd5b15613b7357565b60405162461bcd60e51b815260206004820152601560248201527f6e6f2066756c66696c6c656420726571756573747300000000000000000000006044820152606490fd5b90613bc28261111b565b613bcf604051918261065e565b8281528092613be0601f199161111b565b0190602036910137565b80518210156108355760209160051b010190565b90808352602080930192838260051b850194845f925b858410613c25575050505050505090565b9091929394959681810384528735601e19843603018112156104615783018681019190356001600160401b03811161046157803603831361046157613c6f8892839260019561331d565b990194019401929594939190613c14565b9193929093604083019260408152855180945260608101936020809701905f5b818110613cba5750505061335d9495818503910152613bfe565b825187529588019591880191600101613ca0565b3d15613cf8573d90613cdf82611397565b91613ced604051938461065e565b82523d5f602084013e565b606090565b9190808252602080920192915f5b828110613d19575050505090565b9091929382806001926001600160401b038835613d35816108c8565b16815201950193929101613d0b565b9290613d5d9061335d9593604086526040860191613916565b926020818503910152613cfd565b15613d7257565b60405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e707574000000000000000000000000000000000000006044820152606490fd5b91908201809211613a5157565b9190916001600160401b0380809416911601918211613a5157565b15613de657565b60405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b90604051613e3881610610565b60206001600160401b03829454613e5260ff82168561315c565b60081c16910152565b1561046157565b15613e6957565b60405162461bcd60e51b815260206004820152601260248201527f73656e64206e6174697665206661696c656400000000000000000000000000006044820152606490fd5b809b889f9e613f86849f979b9495613f788b9f9a9e989c8f9c8f9d8f9e859f613edf60ff60015460a01c1615613ddf565b604080514660208201523060601b6bffffffffffffffffffffffff1916918101919091527f46756c66696c6c526571756573747300000000000000000000000000000000006054820152613f3681606381016105a1565b60208151910120966001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169d6040519c8d9960208b01614125565b03601f19810185528461065e565b843b15610461575f96613fb092604051998a9889978897633416de1160e11b89526004890161418d565b03915afa80156105f7576140f7575b506001600160401b0342165f5b88811061400c575050917f599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea697989391613558959360405198899889614212565b80610a136140da896105a18f6140ad8f978f926140a68f8f908f918f8f6140e09f916105a161404f6136d66136d18c6140c89f9a6136ca826136c59a819e613a6f565b5190209d8e61408661406c610981835f52600860205260405f2090565b61407581611bdc565b600381149081156140e55750613106565b61309261409161067f565b60048152936001600160401b03166020850152565b3595613a6f565b60408051602081019586529135908201529182906060820190565b519020915f52600f60205260405f2090565b55613a43565b613fcc565b90506140f081611bdc565b155f61222a565b8061211761410492610630565b5f613fbf565b91906001600160fb1b0381116104615760051b809282370190565b9399989695949261413e9291855260208095019161410a565b97915f5b82811061416257505050509461415c9161335d959661410a565b9161410a565b9091929882806001926001600160401b038d3561417e816108c8565b168152019a0193929101614142565b9297969491906141ab6141bc91979597608086526080860190610c5f565b6020998a9386830385880152613bfe565b83810360408501528281520194905f5b8181106141e95750505061335d9495506060818503910152613916565b90919588806001926001600160a01b038a3561420481610492565b1681520197019291016141cc565b969492614250946142346142429361335d9b999560808c5260808c0191613916565b9189830360208b0152613cfd565b918683036040880152613916565b926060818503910152613916565b1561426557565b60405162461bcd60e51b815260206004820152601460248201527f696e73756666696369656e74206465706f7369740000000000000000000000006044820152606490fd5b156142b157565b60405162461bcd60e51b815260206004820152601a60248201527f6e6f7420696e20612064697370757461626c65207374617475730000000000006044820152606490fd5b156142fd57565b60405162461bcd60e51b815260206004820152601560248201527f70617373206368616c6c656e67652077696e646f7700000000000000000000006044820152606490fd5b1561434957565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c6964207265717565737420737461747573000000000000000000006044820152606490fd5b1561439557565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c6964206469737075746520737461747573000000000000000000006044820152606490fd5b156143e157565b60405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e646578000000000000000000000000000000000000006044820152606490fd5b8054906801000000000000000082101561062b5760018201808255821015610835575f5260205f200155565b80545f918252602080832092905b82821061446e575050505090565b835485529384019360019384019390910190614460565b939594916060936001600160401b036144ac93168652608060208701526080860191613bfe565b9460408401521515910152565b156144c057565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964207374617465730000000000000000000000000000000000006044820152606490fd5b1561450c57565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c69642070726f6f663a2070726f6f664964000000000000000000006044820152606490fd5b1561455857565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c69642070726f6f663a2061707048617368000000000000000000006044820152606490fd5b90816020910312610461575161335d81611985565b60409061335d94928152816020820152019161331d565b156145d15750565b60405162461bcd60e51b815260206004820152908190610b3e906024830190610c5f565b9061460860209282815194859201610c3e565b0190565b60216104b191939293604051948161462e879351809260208087019101610c3e565b8201601d60f91b602082015261464d8251809360208785019101610c3e565b0103600181018552018361065e565b93926101009360ff936001600160401b036146b594999899168752602435602088015260443560408801526064356060880152608435608088015260a43560a088015260c08701526101208060e0880152860191613916565b9416910152565b9096939295966146d761050d6006546001600160a01b031690565b91823b15610461576147015f95604051998a96879586956307b1cc4560e41b87526004870161465c565b03915afa9182156105f7575f6105a16105af6104b19783978497614760575b5061473f61472f3683886113b2565b60208151910120606435146133b7565b6040519283916020830196633ceb5b5160e11b8852608435602485016145b2565b8061211761476d92610630565b5f614720565b1561477a57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b601f81116147ca575050565b5f90600e82527fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fd906020601f850160051c83019410614824575b601f0160051c01915b82811061481957505050565b81815560010161480d565b9092508290614804565b909161484561335d93604084526040840190610c5f565b916020818403910152610c5f565b9060405191825f600e5461486681610b4c565b906001908181169081156148f8575060011461489a575b505061488c906104b1936145f5565b03601f19810184528361065e565b600e5f9081529192507fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fd5b8383106148dd5750505081016020018261488c61487d565b80546020848a018101919091528895509092019181016148c5565b61488c9450602092506104b19693915060ff191682860152801515028401019181945061487d565b61492b600e54610b4c565b156149be576149386150e2565b9060306149448361510d565b5360786149508361511a565b5360415b6001811161497057509061496b61335d9215615219565b614853565b90600f8116906010821015610835577f30313233343536373839616263646566000000000000000000000000000000006149b9921a6149af848661512a565b5360041c9161520d565b614954565b506040516149cb81610643565b5f815290565b9491929360015f936149e281611bdc565b14614a65575b506001600160a01b038516614a02575b5050505050600190565b5f9485948315614a54575b614a35869394956105a16040519384926020840198633ceb5b5160e11b8a52602485016145b2565b5193f1614a40613cce565b5015614a50575f808080806149f8565b5f90565b85929350614a355a94935050614a0d565b614aba9192506020614a8760016138a1614aae945f52600960205260405f2090565b61300e614a9b82516001600160a01b031690565b6001600160a01b03808b16911614613ad4565b6001600160401b031690565b905f6149e8565b604080516020810192835260c09390931b6001600160c01b0319169083015290614aee81604881016105a1565b51902090614b07612fe1835f52600860205260405f2090565b9160048351614b1581611bdc565b614b1e81611bdc565b03614b5b5750614b4490614b3f614aae60208501516001600160401b031690565b613db7565b4211614b55575b5161335d81611bdc565b50600790565b60058351614b6881611bdc565b614b7181611bdc565b14614b7e575b5050614b4b565b614b90905f52601060205260405f2090565b805460ff16614b9e816106a0565b60028114908115614bed575b5015614bda5750614bcc90614b3f614aae60208501516001600160401b031690565b4211614b55575b5f80614b77565b600391500154421115614bd35750600690565b60049150614bfa816106a0565b145f614baa565b93929091610a61614c766040516020810181614c36888b84906028926001600160c01b031991835260c01b1660208201520190565b0391614c4a601f199384810183528261065e565b5190205f52600f60205260405f2054946040519384916020830196879091604092825260208201520190565b51902003614cb057614c8792614ac1565b614c9081611bdc565b60078114908115614c9f575090565b60029150614cac81611bdc565b1490565b60405162461bcd60e51b815260206004820152600c60248201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b15614cfc57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b600554906801000000000000000082101561062b576001820180600555821015610835576104b19160055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001906001600160a01b03166001600160a01b0319825416179055565b15614db157565b60405162461bcd60e51b815260206004820152601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b5f19810191908211613a5157565b6005548015614e54575f1981019080821015610835577f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3daf9060055f52016001600160a01b03198154169055600555565b634e487b7160e01b5f52603160045260245ffd5b6003548015614e54575f1981019080821015610835577fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85a9060035f52016001600160a01b03198154169055600355565b614ee9614ed9610981836001600160a01b03165f52600460205260405f2090565b614ee281612df9565b1515614daa565b600590614ef68254614df6565b5f5b8354811015614fe957614f0d610f2182610800565b6001600160a01b03808516911614614f2d57614f2890613a43565b614ef8565b7fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859350908181613558949310614faa575b5050614f68614e04565b614f90614f86826001600160a01b03165f52600460205260405f2090565b805460ff19169055565b6040516001600160a01b0390911681529081906020820190565b614fc2614fbc610f21614fe294610800565b91610800565b90919082549060031b916001600160a01b03809116831b921b1916179055565b5f80614f5e565b60405162461bcd60e51b815260206004820152601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b60448151106150a857600481015181019060208160248401930312610461576024810151906001600160401b03821161046157018160438201121561046157602481015161507b81611397565b92615089604051948561065e565b818452604482840101116104615761335d916044602085019101610c3e565b506040516150b581610610565b601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b60405190608082018281106001600160401b0382111761062b57604052604282526060366020840137565b8051156108355760200190565b8051600110156108355760210190565b908151811015610835570160200190565b80156151ef57805f908282935b6151db575061515683611397565b92615164604051948561065e565b80845281601f1961517483611397565b013660208701375b6151865750505090565b61518f90614df6565b90600a9060308282068101809111613a515760f81b7fff0000000000000000000000000000000000000000000000000000000000000016841a6151d2848761512a565b5304908161517c565b926151e7600a91613a43565b930480615148565b506040516151fc81610610565b60018152600360fc1b602082015290565b8015613a51575f190190565b1561522057565b606460405162461bcd60e51b815260206004820152602060248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b6001600160a01b0381165f52600260205260ff60405f205416615327576003546801000000000000000081101561062b5760018101806003558110156108355760035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b0180546001600160a01b0319166001600160a01b0383161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89061355890614f90610f4b826001600160a01b03165f52600260205260405f2090565b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b1561537357565b60405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fd5b6153de6153d9610981836001600160a01b03165f52600260205260405f2090565b61536c565b6003906153eb8254614df6565b5f5b835481101561549a57615402610f218261083a565b6001600160a01b038085169116146154225761541d90613a43565b6153ed565b7fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e935090818161355894931061547b575b505061545d614e68565b614f90614f86826001600160a01b03165f52600260205260405f2090565b614fc261548d610f216154939461083a565b9161083a565b5f80615453565b60405162461bcd60e51b815260206004820152601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fdfea2646970667358221220e04893717af640f130b006cddded29788351f088ef2cbcb691b3bdfcebadf74464736f6c63430008140033",
}

// BrevisRequestABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisRequestMetaData.ABI instead.
var BrevisRequestABI = BrevisRequestMetaData.ABI

// BrevisRequestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisRequestMetaData.Bin instead.
var BrevisRequestBin = BrevisRequestMetaData.Bin

// DeployBrevisRequest deploys a new Ethereum contract, binding an instance of BrevisRequest to it.
func DeployBrevisRequest(auth *bind.TransactOpts, backend bind.ContractBackend, _feeCollector common.Address, _brevisProof common.Address, _sigsVerifier common.Address) (common.Address, *types.Transaction, *BrevisRequest, error) {
	parsed, err := BrevisRequestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisRequestBin), backend, _feeCollector, _brevisProof, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisRequest{BrevisRequestCaller: BrevisRequestCaller{contract: contract}, BrevisRequestTransactor: BrevisRequestTransactor{contract: contract}, BrevisRequestFilterer: BrevisRequestFilterer{contract: contract}}, nil
}

// BrevisRequest is an auto generated Go binding around an Ethereum contract.
type BrevisRequest struct {
	BrevisRequestCaller     // Read-only binding to the contract
	BrevisRequestTransactor // Write-only binding to the contract
	BrevisRequestFilterer   // Log filterer for contract events
}

// BrevisRequestCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisRequestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisRequestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisRequestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisRequestSession struct {
	Contract     *BrevisRequest    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisRequestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisRequestCallerSession struct {
	Contract *BrevisRequestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// BrevisRequestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisRequestTransactorSession struct {
	Contract     *BrevisRequestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// BrevisRequestRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisRequestRaw struct {
	Contract *BrevisRequest // Generic contract binding to access the raw methods on
}

// BrevisRequestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisRequestCallerRaw struct {
	Contract *BrevisRequestCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisRequestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisRequestTransactorRaw struct {
	Contract *BrevisRequestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisRequest creates a new instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequest(address common.Address, backend bind.ContractBackend) (*BrevisRequest, error) {
	contract, err := bindBrevisRequest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisRequest{BrevisRequestCaller: BrevisRequestCaller{contract: contract}, BrevisRequestTransactor: BrevisRequestTransactor{contract: contract}, BrevisRequestFilterer: BrevisRequestFilterer{contract: contract}}, nil
}

// NewBrevisRequestCaller creates a new read-only instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestCaller(address common.Address, caller bind.ContractCaller) (*BrevisRequestCaller, error) {
	contract, err := bindBrevisRequest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestCaller{contract: contract}, nil
}

// NewBrevisRequestTransactor creates a new write-only instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisRequestTransactor, error) {
	contract, err := bindBrevisRequest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestTransactor{contract: contract}, nil
}

// NewBrevisRequestFilterer creates a new log filterer instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisRequestFilterer, error) {
	contract, err := bindBrevisRequest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFilterer{contract: contract}, nil
}

// bindBrevisRequest binds a generic wrapper to an already deployed contract.
func bindBrevisRequest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisRequestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisRequest *BrevisRequestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisRequest.Contract.BrevisRequestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisRequest *BrevisRequestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.Contract.BrevisRequestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisRequest *BrevisRequestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisRequest.Contract.BrevisRequestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisRequest *BrevisRequestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisRequest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisRequest *BrevisRequestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisRequest *BrevisRequestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisRequest.Contract.contract.Transact(opts, method, params...)
}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestCaller) BaseDataURL(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "baseDataURL")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestSession) BaseDataURL() (string, error) {
	return _BrevisRequest.Contract.BaseDataURL(&_BrevisRequest.CallOpts)
}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestCallerSession) BaseDataURL() (string, error) {
	return _BrevisRequest.Contract.BaseDataURL(&_BrevisRequest.CallOpts)
}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) BrevisProof(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "brevisProof")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestSession) BrevisProof() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisProof(&_BrevisRequest.CallOpts)
}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) BrevisProof() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisProof(&_BrevisRequest.CallOpts)
}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) ChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "challengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) ChallengeWindow() (*big.Int, error) {
	return _BrevisRequest.Contract.ChallengeWindow(&_BrevisRequest.CallOpts)
}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) ChallengeWindow() (*big.Int, error) {
	return _BrevisRequest.Contract.ChallengeWindow(&_BrevisRequest.CallOpts)
}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestCaller) DataURL(opts *bind.CallOpts, _proofId [32]byte) (string, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "dataURL", _proofId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestSession) DataURL(_proofId [32]byte) (string, error) {
	return _BrevisRequest.Contract.DataURL(&_BrevisRequest.CallOpts, _proofId)
}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestCallerSession) DataURL(_proofId [32]byte) (string, error) {
	return _BrevisRequest.Contract.DataURL(&_BrevisRequest.CallOpts, _proofId)
}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) DepositAskForData(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "depositAskForData")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) DepositAskForData() (*big.Int, error) {
	return _BrevisRequest.Contract.DepositAskForData(&_BrevisRequest.CallOpts)
}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) DepositAskForData() (*big.Int, error) {
	return _BrevisRequest.Contract.DepositAskForData(&_BrevisRequest.CallOpts)
}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) DepositAskForProof(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "depositAskForProof")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) DepositAskForProof() (*big.Int, error) {
	return _BrevisRequest.Contract.DepositAskForProof(&_BrevisRequest.CallOpts)
}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) DepositAskForProof() (*big.Int, error) {
	return _BrevisRequest.Contract.DepositAskForProof(&_BrevisRequest.CallOpts)
}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, address challenger, uint256 deposit)
func (_BrevisRequest *BrevisRequestCaller) Disputes(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Status           uint8
	RequestDataHash  IBrevisRequestRequestDataHash
	ResponseDeadline *big.Int
	Challenger       common.Address
	Deposit          *big.Int
}, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "disputes", arg0)

	outstruct := new(struct {
		Status           uint8
		RequestDataHash  IBrevisRequestRequestDataHash
		ResponseDeadline *big.Int
		Challenger       common.Address
		Deposit          *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Status = *abi.ConvertType(out[0], new(uint8)).(*uint8)
	outstruct.RequestDataHash = *abi.ConvertType(out[1], new(IBrevisRequestRequestDataHash)).(*IBrevisRequestRequestDataHash)
	outstruct.ResponseDeadline = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Challenger = *abi.ConvertType(out[3], new(common.Address)).(*common.Address)
	outstruct.Deposit = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, address challenger, uint256 deposit)
func (_BrevisRequest *BrevisRequestSession) Disputes(arg0 [32]byte) (struct {
	Status           uint8
	RequestDataHash  IBrevisRequestRequestDataHash
	ResponseDeadline *big.Int
	Challenger       common.Address
	Deposit          *big.Int
}, error) {
	return _BrevisRequest.Contract.Disputes(&_BrevisRequest.CallOpts, arg0)
}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, address challenger, uint256 deposit)
func (_BrevisRequest *BrevisRequestCallerSession) Disputes(arg0 [32]byte) (struct {
	Status           uint8
	RequestDataHash  IBrevisRequestRequestDataHash
	ResponseDeadline *big.Int
	Challenger       common.Address
	Deposit          *big.Int
}, error) {
	return _BrevisRequest.Contract.Disputes(&_BrevisRequest.CallOpts, arg0)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) FeeCollector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "feeCollector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestSession) FeeCollector() (common.Address, error) {
	return _BrevisRequest.Contract.FeeCollector(&_BrevisRequest.CallOpts)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) FeeCollector() (common.Address, error) {
	return _BrevisRequest.Contract.FeeCollector(&_BrevisRequest.CallOpts)
}

// GetProofContract is a free data retrieval call binding the contract method 0xc8c8a05a.
//
// Solidity: function getProofContract() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) GetProofContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "getProofContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProofContract is a free data retrieval call binding the contract method 0xc8c8a05a.
//
// Solidity: function getProofContract() view returns(address)
func (_BrevisRequest *BrevisRequestSession) GetProofContract() (common.Address, error) {
	return _BrevisRequest.Contract.GetProofContract(&_BrevisRequest.CallOpts)
}

// GetProofContract is a free data retrieval call binding the contract method 0xc8c8a05a.
//
// Solidity: function getProofContract() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) GetProofContract() (common.Address, error) {
	return _BrevisRequest.Contract.GetProofContract(&_BrevisRequest.CallOpts)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsPauser(&_BrevisRequest.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsPauser(&_BrevisRequest.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) NumPausers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumPausers(&_BrevisRequest.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumPausers(&_BrevisRequest.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) NumProvers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumProvers(&_BrevisRequest.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumProvers(&_BrevisRequest.CallOpts)
}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestCaller) OnchainRequests(opts *bind.CallOpts, arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisRequestCallback
}, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "onchainRequests", arg0)

	outstruct := new(struct {
		FeeHash  [32]byte
		Callback IBrevisRequestCallback
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.FeeHash = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Callback = *abi.ConvertType(out[1], new(IBrevisRequestCallback)).(*IBrevisRequestCallback)

	return *outstruct, err

}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestSession) OnchainRequests(arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisRequestCallback
}, error) {
	return _BrevisRequest.Contract.OnchainRequests(&_BrevisRequest.CallOpts, arg0)
}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestCallerSession) OnchainRequests(arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisRequestCallback
}, error) {
	return _BrevisRequest.Contract.OnchainRequests(&_BrevisRequest.CallOpts, arg0)
}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestCaller) Opdata(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "opdata", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestSession) Opdata(arg0 [32]byte) ([32]byte, error) {
	return _BrevisRequest.Contract.Opdata(&_BrevisRequest.CallOpts, arg0)
}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestCallerSession) Opdata(arg0 [32]byte) ([32]byte, error) {
	return _BrevisRequest.Contract.Opdata(&_BrevisRequest.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestSession) Owner() (common.Address, error) {
	return _BrevisRequest.Contract.Owner(&_BrevisRequest.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) Owner() (common.Address, error) {
	return _BrevisRequest.Contract.Owner(&_BrevisRequest.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestSession) Paused() (bool, error) {
	return _BrevisRequest.Contract.Paused(&_BrevisRequest.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) Paused() (bool, error) {
	return _BrevisRequest.Contract.Paused(&_BrevisRequest.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.PauserList(&_BrevisRequest.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.PauserList(&_BrevisRequest.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisRequest.Contract.Pausers(&_BrevisRequest.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisRequest.Contract.Pausers(&_BrevisRequest.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisRequest.Contract.ProverStates(&_BrevisRequest.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisRequest.Contract.ProverStates(&_BrevisRequest.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.Provers(&_BrevisRequest.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.Provers(&_BrevisRequest.CallOpts, arg0)
}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8)
func (_BrevisRequest *BrevisRequestCaller) QueryRequestStatus(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64) (uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "queryRequestStatus", _proofId, _nonce)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8)
func (_BrevisRequest *BrevisRequestSession) QueryRequestStatus(_proofId [32]byte, _nonce uint64) (uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8)
func (_BrevisRequest *BrevisRequestCallerSession) QueryRequestStatus(_proofId [32]byte, _nonce uint64) (uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _appChallengeWindow) view returns(uint8)
func (_BrevisRequest *BrevisRequestCaller) QueryRequestStatus0(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appChallengeWindow *big.Int) (uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "queryRequestStatus0", _proofId, _nonce, _appChallengeWindow)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _appChallengeWindow) view returns(uint8)
func (_BrevisRequest *BrevisRequestSession) QueryRequestStatus0(_proofId [32]byte, _nonce uint64, _appChallengeWindow *big.Int) (uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appChallengeWindow)
}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _appChallengeWindow) view returns(uint8)
func (_BrevisRequest *BrevisRequestCallerSession) QueryRequestStatus0(_proofId [32]byte, _nonce uint64, _appChallengeWindow *big.Int) (uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appChallengeWindow)
}

// QueryRequestTimestamp is a free data retrieval call binding the contract method 0x8522feab.
//
// Solidity: function queryRequestTimestamp(bytes32 _proofId, uint64 _nonce) view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) QueryRequestTimestamp(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "queryRequestTimestamp", _proofId, _nonce)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// QueryRequestTimestamp is a free data retrieval call binding the contract method 0x8522feab.
//
// Solidity: function queryRequestTimestamp(bytes32 _proofId, uint64 _nonce) view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) QueryRequestTimestamp(_proofId [32]byte, _nonce uint64) (*big.Int, error) {
	return _BrevisRequest.Contract.QueryRequestTimestamp(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// QueryRequestTimestamp is a free data retrieval call binding the contract method 0x8522feab.
//
// Solidity: function queryRequestTimestamp(bytes32 _proofId, uint64 _nonce) view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) QueryRequestTimestamp(_proofId [32]byte, _nonce uint64) (*big.Int, error) {
	return _BrevisRequest.Contract.QueryRequestTimestamp(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) RequestTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "requestTimeout")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) RequestTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.RequestTimeout(&_BrevisRequest.CallOpts)
}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) RequestTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.RequestTimeout(&_BrevisRequest.CallOpts)
}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp)
func (_BrevisRequest *BrevisRequestCaller) Requests(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
}, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "requests", arg0)

	outstruct := new(struct {
		Status    uint8
		Timestamp uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Status = *abi.ConvertType(out[0], new(uint8)).(*uint8)
	outstruct.Timestamp = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp)
func (_BrevisRequest *BrevisRequestSession) Requests(arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
}, error) {
	return _BrevisRequest.Contract.Requests(&_BrevisRequest.CallOpts, arg0)
}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp)
func (_BrevisRequest *BrevisRequestCallerSession) Requests(arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
}, error) {
	return _BrevisRequest.Contract.Requests(&_BrevisRequest.CallOpts, arg0)
}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) ResponseTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "responseTimeout")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) ResponseTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.ResponseTimeout(&_BrevisRequest.CallOpts)
}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) ResponseTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.ResponseTimeout(&_BrevisRequest.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestSession) SigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.SigsVerifier(&_BrevisRequest.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) SigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.SigsVerifier(&_BrevisRequest.CallOpts)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x65a58753.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) ValidateOpAppData(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "validateOpAppData", _proofId, _nonce, _appCommitHash, _appVkHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x65a58753.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x65a58753.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) ValidateOpAppData0(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "validateOpAppData0", _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) ValidateOpAppData0(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) ValidateOpAppData0(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPauser(&_BrevisRequest.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPauser(&_BrevisRequest.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPausers(&_BrevisRequest.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPausers(&_BrevisRequest.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisAggProof(opts *bind.TransactOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisAggProof", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisAggProof(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof(&_BrevisRequest.TransactOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisAggProof(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof(&_BrevisRequest.TransactOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisAggProof0(opts *bind.TransactOpts, _chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisAggProof0", _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisAggProof0(_chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof0(&_BrevisRequest.TransactOpts, _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisAggProof0(_chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof0(&_BrevisRequest.TransactOpts, _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisProof(opts *bind.TransactOpts, _proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisProof", _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisProof(_proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisProof(&_BrevisRequest.TransactOpts, _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisProof(_proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisProof(&_BrevisRequest.TransactOpts, _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) AskForDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "askForDataAvailabilityProof", _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForDataAvailabilityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForDataAvailabilityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) AskForDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "askForDataValidityProof", _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForDataValidityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForDataValidityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) AskForRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "askForRequestData", _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForRequestData(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AskForRequestData(&_BrevisRequest.TransactOpts, _proofId, _nonce)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestTransactor) CollectFee(opts *bind.TransactOpts, _amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "collectFee", _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.CollectFee(&_BrevisRequest.TransactOpts, _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.CollectFee(&_BrevisRequest.TransactOpts, _amount, _to)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x87c2f360.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillOpRequests(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillOpRequests", _proofIds, _nonces, _appCommitHashes, _appVkHashes, _sigs, _signers, _powers)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x87c2f360.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillOpRequests(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillOpRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _sigs, _signers, _powers)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x87c2f360.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillOpRequests(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillOpRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _sigs, _signers, _powers)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillRequest(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillRequest", _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillRequest(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillRequest(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillRequests(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillRequests", _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillRequests(_proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillRequests(_proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) IncreaseGasFee(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "increaseGasFee", _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestSession) IncreaseGasFee(_proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.IncreaseGasFee(&_BrevisRequest.TransactOpts, _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) IncreaseGasFee(_proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.IncreaseGasFee(&_BrevisRequest.TransactOpts, _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestSession) Pause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Pause(&_BrevisRequest.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Pause(&_BrevisRequest.TransactOpts)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisRequest *BrevisRequestTransactor) PostDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "postDataAvailabilityProof", _proofId, _nonce, arg2)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisRequest *BrevisRequestSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostDataAvailabilityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce, arg2)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostDataAvailabilityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce, arg2)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisRequest *BrevisRequestTransactor) PostDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "postDataValidityProof", _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisRequest *BrevisRequestSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostDataValidityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostDataValidityProof(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisRequest *BrevisRequestTransactor) PostRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "postRequestData", _proofId, _nonce, _data, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisRequest *BrevisRequestSession) PostRequestData(_proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostRequestData(&_BrevisRequest.TransactOpts, _proofId, _nonce, _data, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) PostRequestData(_proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisRequest.Contract.PostRequestData(&_BrevisRequest.TransactOpts, _proofId, _nonce, _data, _index, _done)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestTransactor) Refund(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "refund", _proofId, _nonce, _amount, _refundee)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestSession) Refund(_proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.Refund(&_BrevisRequest.TransactOpts, _proofId, _nonce, _amount, _refundee)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Refund(_proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.Refund(&_BrevisRequest.TransactOpts, _proofId, _nonce, _amount, _refundee)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePauser(&_BrevisRequest.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePauser(&_BrevisRequest.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePausers(&_BrevisRequest.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePausers(&_BrevisRequest.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemoveProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemoveProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisRequest.Contract.RenouncePauser(&_BrevisRequest.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisRequest.Contract.RenouncePauser(&_BrevisRequest.TransactOpts)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) SendRequest(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisRequestCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "sendRequest", _proofId, _nonce, _refundee, _callback, _option)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestSession) SendRequest(_proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisRequestCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SendRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _refundee, _callback, _option)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SendRequest(_proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisRequestCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SendRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _refundee, _callback, _option)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBaseDataURL(opts *bind.TransactOpts, _url string) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBaseDataURL", _url)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestSession) SetBaseDataURL(_url string) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBaseDataURL(&_BrevisRequest.TransactOpts, _url)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBaseDataURL(_url string) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBaseDataURL(&_BrevisRequest.TransactOpts, _url)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBrevisProof(opts *bind.TransactOpts, _brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBrevisProof", _brevisProof)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestSession) SetBrevisProof(_brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisProof(&_BrevisRequest.TransactOpts, _brevisProof)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBrevisProof(_brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisProof(&_BrevisRequest.TransactOpts, _brevisProof)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetChallengeWindow(opts *bind.TransactOpts, _challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setChallengeWindow", _challengeWindow)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisRequest *BrevisRequestSession) SetChallengeWindow(_challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetChallengeWindow(&_BrevisRequest.TransactOpts, _challengeWindow)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetChallengeWindow(_challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetChallengeWindow(&_BrevisRequest.TransactOpts, _challengeWindow)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetDisputeDeposits(opts *bind.TransactOpts, _amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setDisputeDeposits", _amtAskForData, _amtAskForProof)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisRequest *BrevisRequestSession) SetDisputeDeposits(_amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetDisputeDeposits(&_BrevisRequest.TransactOpts, _amtAskForData, _amtAskForProof)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetDisputeDeposits(_amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetDisputeDeposits(&_BrevisRequest.TransactOpts, _amtAskForData, _amtAskForProof)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetFeeCollector(opts *bind.TransactOpts, _feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setFeeCollector", _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetFeeCollector(&_BrevisRequest.TransactOpts, _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetFeeCollector(&_BrevisRequest.TransactOpts, _feeCollector)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetRequestTimeout(opts *bind.TransactOpts, _timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setRequestTimeout", _timeout)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestSession) SetRequestTimeout(_timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestTimeout(&_BrevisRequest.TransactOpts, _timeout)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetRequestTimeout(_timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestTimeout(&_BrevisRequest.TransactOpts, _timeout)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetResponseTimeout(opts *bind.TransactOpts, _responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setResponseTimeout", _responseTimeout)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisRequest *BrevisRequestSession) SetResponseTimeout(_responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetResponseTimeout(&_BrevisRequest.TransactOpts, _responseTimeout)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetResponseTimeout(_responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetResponseTimeout(&_BrevisRequest.TransactOpts, _responseTimeout)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.TransferOwnership(&_BrevisRequest.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.TransferOwnership(&_BrevisRequest.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestSession) Unpause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Unpause(&_BrevisRequest.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Unpause(&_BrevisRequest.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestSession) Receive() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Receive(&_BrevisRequest.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Receive() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Receive(&_BrevisRequest.TransactOpts)
}

// BrevisRequestAskForIterator is returned from FilterAskFor and is used to iterate over the raw logs and unpacked data for AskFor events raised by the BrevisRequest contract.
type BrevisRequestAskForIterator struct {
	Event *BrevisRequestAskFor // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestAskForIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestAskFor)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestAskFor)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestAskForIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestAskForIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestAskFor represents a AskFor event raised by the BrevisRequest contract.
type BrevisRequestAskFor struct {
	ProofId [32]byte
	Nonce   uint64
	Status  uint8
	From    common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterAskFor is a free log retrieval operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisRequest *BrevisRequestFilterer) FilterAskFor(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisRequestAskForIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestAskForIterator{contract: _BrevisRequest.contract, event: "AskFor", logs: logs, sub: sub}, nil
}

// WatchAskFor is a free log subscription operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisRequest *BrevisRequestFilterer) WatchAskFor(opts *bind.WatchOpts, sink chan<- *BrevisRequestAskFor, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestAskFor)
				if err := _BrevisRequest.contract.UnpackLog(event, "AskFor", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAskFor is a log parse operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisRequest *BrevisRequestFilterer) ParseAskFor(log types.Log) (*BrevisRequestAskFor, error) {
	event := new(BrevisRequestAskFor)
	if err := _BrevisRequest.contract.UnpackLog(event, "AskFor", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBaseDataUrlUpdatedIterator is returned from FilterBaseDataUrlUpdated and is used to iterate over the raw logs and unpacked data for BaseDataUrlUpdated events raised by the BrevisRequest contract.
type BrevisRequestBaseDataUrlUpdatedIterator struct {
	Event *BrevisRequestBaseDataUrlUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBaseDataUrlUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBaseDataUrlUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBaseDataUrlUpdated represents a BaseDataUrlUpdated event raised by the BrevisRequest contract.
type BrevisRequestBaseDataUrlUpdated struct {
	From string
	To   string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBaseDataUrlUpdated is a free log retrieval operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBaseDataUrlUpdated(opts *bind.FilterOpts) (*BrevisRequestBaseDataUrlUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BaseDataUrlUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBaseDataUrlUpdatedIterator{contract: _BrevisRequest.contract, event: "BaseDataUrlUpdated", logs: logs, sub: sub}, nil
}

// WatchBaseDataUrlUpdated is a free log subscription operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBaseDataUrlUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBaseDataUrlUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BaseDataUrlUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBaseDataUrlUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BaseDataUrlUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseDataUrlUpdated is a log parse operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBaseDataUrlUpdated(log types.Log) (*BrevisRequestBaseDataUrlUpdated, error) {
	event := new(BrevisRequestBaseDataUrlUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BaseDataUrlUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBrevisProofUpdatedIterator is returned from FilterBrevisProofUpdated and is used to iterate over the raw logs and unpacked data for BrevisProofUpdated events raised by the BrevisRequest contract.
type BrevisRequestBrevisProofUpdatedIterator struct {
	Event *BrevisRequestBrevisProofUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBrevisProofUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBrevisProofUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBrevisProofUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBrevisProofUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBrevisProofUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBrevisProofUpdated represents a BrevisProofUpdated event raised by the BrevisRequest contract.
type BrevisRequestBrevisProofUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBrevisProofUpdated is a free log retrieval operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBrevisProofUpdated(opts *bind.FilterOpts) (*BrevisRequestBrevisProofUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BrevisProofUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBrevisProofUpdatedIterator{contract: _BrevisRequest.contract, event: "BrevisProofUpdated", logs: logs, sub: sub}, nil
}

// WatchBrevisProofUpdated is a free log subscription operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBrevisProofUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBrevisProofUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BrevisProofUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBrevisProofUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BrevisProofUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBrevisProofUpdated is a log parse operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBrevisProofUpdated(log types.Log) (*BrevisRequestBrevisProofUpdated, error) {
	event := new(BrevisRequestBrevisProofUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BrevisProofUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestChallengeWindowUpdatedIterator is returned from FilterChallengeWindowUpdated and is used to iterate over the raw logs and unpacked data for ChallengeWindowUpdated events raised by the BrevisRequest contract.
type BrevisRequestChallengeWindowUpdatedIterator struct {
	Event *BrevisRequestChallengeWindowUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestChallengeWindowUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestChallengeWindowUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestChallengeWindowUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestChallengeWindowUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestChallengeWindowUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestChallengeWindowUpdated represents a ChallengeWindowUpdated event raised by the BrevisRequest contract.
type BrevisRequestChallengeWindowUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterChallengeWindowUpdated is a free log retrieval operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) FilterChallengeWindowUpdated(opts *bind.FilterOpts) (*BrevisRequestChallengeWindowUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestChallengeWindowUpdatedIterator{contract: _BrevisRequest.contract, event: "ChallengeWindowUpdated", logs: logs, sub: sub}, nil
}

// WatchChallengeWindowUpdated is a free log subscription operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) WatchChallengeWindowUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestChallengeWindowUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestChallengeWindowUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChallengeWindowUpdated is a log parse operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) ParseChallengeWindowUpdated(log types.Log) (*BrevisRequestChallengeWindowUpdated, error) {
	event := new(BrevisRequestChallengeWindowUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestDataAvailabilityProofPostedIterator is returned from FilterDataAvailabilityProofPosted and is used to iterate over the raw logs and unpacked data for DataAvailabilityProofPosted events raised by the BrevisRequest contract.
type BrevisRequestDataAvailabilityProofPostedIterator struct {
	Event *BrevisRequestDataAvailabilityProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestDataAvailabilityProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestDataAvailabilityProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestDataAvailabilityProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestDataAvailabilityProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestDataAvailabilityProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestDataAvailabilityProofPosted represents a DataAvailabilityProofPosted event raised by the BrevisRequest contract.
type BrevisRequestDataAvailabilityProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataAvailabilityProofPosted is a free log retrieval operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterDataAvailabilityProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisRequestDataAvailabilityProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestDataAvailabilityProofPostedIterator{contract: _BrevisRequest.contract, event: "DataAvailabilityProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataAvailabilityProofPosted is a free log subscription operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchDataAvailabilityProofPosted(opts *bind.WatchOpts, sink chan<- *BrevisRequestDataAvailabilityProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestDataAvailabilityProofPosted)
				if err := _BrevisRequest.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataAvailabilityProofPosted is a log parse operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseDataAvailabilityProofPosted(log types.Log) (*BrevisRequestDataAvailabilityProofPosted, error) {
	event := new(BrevisRequestDataAvailabilityProofPosted)
	if err := _BrevisRequest.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestDataValidityProofProofPostedIterator is returned from FilterDataValidityProofProofPosted and is used to iterate over the raw logs and unpacked data for DataValidityProofProofPosted events raised by the BrevisRequest contract.
type BrevisRequestDataValidityProofProofPostedIterator struct {
	Event *BrevisRequestDataValidityProofProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestDataValidityProofProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestDataValidityProofProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestDataValidityProofProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestDataValidityProofProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestDataValidityProofProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestDataValidityProofProofPosted represents a DataValidityProofProofPosted event raised by the BrevisRequest contract.
type BrevisRequestDataValidityProofProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataValidityProofProofPosted is a free log retrieval operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterDataValidityProofProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisRequestDataValidityProofProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestDataValidityProofProofPostedIterator{contract: _BrevisRequest.contract, event: "DataValidityProofProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataValidityProofProofPosted is a free log subscription operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchDataValidityProofProofPosted(opts *bind.WatchOpts, sink chan<- *BrevisRequestDataValidityProofProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestDataValidityProofProofPosted)
				if err := _BrevisRequest.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataValidityProofProofPosted is a log parse operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseDataValidityProofProofPosted(log types.Log) (*BrevisRequestDataValidityProofProofPosted, error) {
	event := new(BrevisRequestDataValidityProofProofPosted)
	if err := _BrevisRequest.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestDisputeDepositsUpdatedIterator is returned from FilterDisputeDepositsUpdated and is used to iterate over the raw logs and unpacked data for DisputeDepositsUpdated events raised by the BrevisRequest contract.
type BrevisRequestDisputeDepositsUpdatedIterator struct {
	Event *BrevisRequestDisputeDepositsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestDisputeDepositsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestDisputeDepositsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestDisputeDepositsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestDisputeDepositsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestDisputeDepositsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestDisputeDepositsUpdated represents a DisputeDepositsUpdated event raised by the BrevisRequest contract.
type BrevisRequestDisputeDepositsUpdated struct {
	AmtAskForData  *big.Int
	AmtAskForProof *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterDisputeDepositsUpdated is a free log retrieval operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisRequest *BrevisRequestFilterer) FilterDisputeDepositsUpdated(opts *bind.FilterOpts) (*BrevisRequestDisputeDepositsUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestDisputeDepositsUpdatedIterator{contract: _BrevisRequest.contract, event: "DisputeDepositsUpdated", logs: logs, sub: sub}, nil
}

// WatchDisputeDepositsUpdated is a free log subscription operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisRequest *BrevisRequestFilterer) WatchDisputeDepositsUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestDisputeDepositsUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestDisputeDepositsUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeDepositsUpdated is a log parse operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisRequest *BrevisRequestFilterer) ParseDisputeDepositsUpdated(log types.Log) (*BrevisRequestDisputeDepositsUpdated, error) {
	event := new(BrevisRequestDisputeDepositsUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestFeeCollectedIterator is returned from FilterFeeCollected and is used to iterate over the raw logs and unpacked data for FeeCollected events raised by the BrevisRequest contract.
type BrevisRequestFeeCollectedIterator struct {
	Event *BrevisRequestFeeCollected // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestFeeCollectedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestFeeCollected)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestFeeCollected)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestFeeCollectedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestFeeCollectedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestFeeCollected represents a FeeCollected event raised by the BrevisRequest contract.
type BrevisRequestFeeCollected struct {
	Amount   *big.Int
	Receiver common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFeeCollected is a free log retrieval operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) FilterFeeCollected(opts *bind.FilterOpts) (*BrevisRequestFeeCollectedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFeeCollectedIterator{contract: _BrevisRequest.contract, event: "FeeCollected", logs: logs, sub: sub}, nil
}

// WatchFeeCollected is a free log subscription operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) WatchFeeCollected(opts *bind.WatchOpts, sink chan<- *BrevisRequestFeeCollected) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestFeeCollected)
				if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollected", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollected is a log parse operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) ParseFeeCollected(log types.Log) (*BrevisRequestFeeCollected, error) {
	event := new(BrevisRequestFeeCollected)
	if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollected", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestFeeCollectorUpdatedIterator is returned from FilterFeeCollectorUpdated and is used to iterate over the raw logs and unpacked data for FeeCollectorUpdated events raised by the BrevisRequest contract.
type BrevisRequestFeeCollectorUpdatedIterator struct {
	Event *BrevisRequestFeeCollectorUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestFeeCollectorUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestFeeCollectorUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestFeeCollectorUpdated represents a FeeCollectorUpdated event raised by the BrevisRequest contract.
type BrevisRequestFeeCollectorUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFeeCollectorUpdated is a free log retrieval operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterFeeCollectorUpdated(opts *bind.FilterOpts) (*BrevisRequestFeeCollectorUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFeeCollectorUpdatedIterator{contract: _BrevisRequest.contract, event: "FeeCollectorUpdated", logs: logs, sub: sub}, nil
}

// WatchFeeCollectorUpdated is a free log subscription operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchFeeCollectorUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestFeeCollectorUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestFeeCollectorUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollectorUpdated is a log parse operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseFeeCollectorUpdated(log types.Log) (*BrevisRequestFeeCollectorUpdated, error) {
	event := new(BrevisRequestFeeCollectorUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestOpRequestsFulfilledIterator is returned from FilterOpRequestsFulfilled and is used to iterate over the raw logs and unpacked data for OpRequestsFulfilled events raised by the BrevisRequest contract.
type BrevisRequestOpRequestsFulfilledIterator struct {
	Event *BrevisRequestOpRequestsFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestOpRequestsFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestOpRequestsFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestOpRequestsFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestOpRequestsFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestOpRequestsFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestOpRequestsFulfilled represents a OpRequestsFulfilled event raised by the BrevisRequest contract.
type BrevisRequestOpRequestsFulfilled struct {
	ProofIds        [][32]byte
	Nonces          []uint64
	AppCommitHashes [][32]byte
	AppVkHashes     [][32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterOpRequestsFulfilled is a free log retrieval operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) FilterOpRequestsFulfilled(opts *bind.FilterOpts) (*BrevisRequestOpRequestsFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "OpRequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestOpRequestsFulfilledIterator{contract: _BrevisRequest.contract, event: "OpRequestsFulfilled", logs: logs, sub: sub}, nil
}

// WatchOpRequestsFulfilled is a free log subscription operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) WatchOpRequestsFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestOpRequestsFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "OpRequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestOpRequestsFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "OpRequestsFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOpRequestsFulfilled is a log parse operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) ParseOpRequestsFulfilled(log types.Log) (*BrevisRequestOpRequestsFulfilled, error) {
	event := new(BrevisRequestOpRequestsFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "OpRequestsFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisRequest contract.
type BrevisRequestOwnershipTransferredIterator struct {
	Event *BrevisRequestOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisRequest contract.
type BrevisRequestOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisRequestOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestOwnershipTransferredIterator{contract: _BrevisRequest.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisRequestOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestOwnershipTransferred)
				if err := _BrevisRequest.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisRequestOwnershipTransferred, error) {
	event := new(BrevisRequestOwnershipTransferred)
	if err := _BrevisRequest.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisRequest contract.
type BrevisRequestPausedIterator struct {
	Event *BrevisRequestPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPaused represents a Paused event raised by the BrevisRequest contract.
type BrevisRequestPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisRequestPausedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPausedIterator{contract: _BrevisRequest.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisRequestPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPaused)
				if err := _BrevisRequest.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePaused(log types.Log) (*BrevisRequestPaused, error) {
	event := new(BrevisRequestPaused)
	if err := _BrevisRequest.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisRequest contract.
type BrevisRequestPauserAddedIterator struct {
	Event *BrevisRequestPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPauserAdded represents a PauserAdded event raised by the BrevisRequest contract.
type BrevisRequestPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisRequestPauserAddedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPauserAddedIterator{contract: _BrevisRequest.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisRequestPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPauserAdded)
				if err := _BrevisRequest.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePauserAdded(log types.Log) (*BrevisRequestPauserAdded, error) {
	event := new(BrevisRequestPauserAdded)
	if err := _BrevisRequest.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisRequest contract.
type BrevisRequestPauserRemovedIterator struct {
	Event *BrevisRequestPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPauserRemoved represents a PauserRemoved event raised by the BrevisRequest contract.
type BrevisRequestPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisRequestPauserRemovedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPauserRemovedIterator{contract: _BrevisRequest.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisRequestPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPauserRemoved)
				if err := _BrevisRequest.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePauserRemoved(log types.Log) (*BrevisRequestPauserRemoved, error) {
	event := new(BrevisRequestPauserRemoved)
	if err := _BrevisRequest.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisRequest contract.
type BrevisRequestProverAddedIterator struct {
	Event *BrevisRequestProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestProverAdded represents a ProverAdded event raised by the BrevisRequest contract.
type BrevisRequestProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisRequestProverAddedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestProverAddedIterator{contract: _BrevisRequest.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisRequestProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestProverAdded)
				if err := _BrevisRequest.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseProverAdded(log types.Log) (*BrevisRequestProverAdded, error) {
	event := new(BrevisRequestProverAdded)
	if err := _BrevisRequest.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisRequest contract.
type BrevisRequestProverRemovedIterator struct {
	Event *BrevisRequestProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestProverRemoved represents a ProverRemoved event raised by the BrevisRequest contract.
type BrevisRequestProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisRequestProverRemovedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestProverRemovedIterator{contract: _BrevisRequest.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisRequestProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestProverRemoved)
				if err := _BrevisRequest.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseProverRemoved(log types.Log) (*BrevisRequestProverRemoved, error) {
	event := new(BrevisRequestProverRemoved)
	if err := _BrevisRequest.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestCallbackFailedIterator is returned from FilterRequestCallbackFailed and is used to iterate over the raw logs and unpacked data for RequestCallbackFailed events raised by the BrevisRequest contract.
type BrevisRequestRequestCallbackFailedIterator struct {
	Event *BrevisRequestRequestCallbackFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestCallbackFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestCallbackFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestCallbackFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestCallbackFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestCallbackFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestCallbackFailed represents a RequestCallbackFailed event raised by the BrevisRequest contract.
type BrevisRequestRequestCallbackFailed struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestCallbackFailed is a free log retrieval operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestCallbackFailed(opts *bind.FilterOpts) (*BrevisRequestRequestCallbackFailedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestCallbackFailed")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestCallbackFailedIterator{contract: _BrevisRequest.contract, event: "RequestCallbackFailed", logs: logs, sub: sub}, nil
}

// WatchRequestCallbackFailed is a free log subscription operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestCallbackFailed(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestCallbackFailed) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestCallbackFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestCallbackFailed)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestCallbackFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestCallbackFailed is a log parse operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestCallbackFailed(log types.Log) (*BrevisRequestRequestCallbackFailed, error) {
	event := new(BrevisRequestRequestCallbackFailed)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestCallbackFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestDataPostedIterator is returned from FilterRequestDataPosted and is used to iterate over the raw logs and unpacked data for RequestDataPosted events raised by the BrevisRequest contract.
type BrevisRequestRequestDataPostedIterator struct {
	Event *BrevisRequestRequestDataPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestDataPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestDataPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestDataPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestDataPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestDataPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestDataPosted represents a RequestDataPosted event raised by the BrevisRequest contract.
type BrevisRequestRequestDataPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Data    [][]byte
	Index   *big.Int
	Done    bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestDataPosted is a free log retrieval operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestDataPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisRequestRequestDataPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestDataPostedIterator{contract: _BrevisRequest.contract, event: "RequestDataPosted", logs: logs, sub: sub}, nil
}

// WatchRequestDataPosted is a free log subscription operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestDataPosted(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestDataPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestDataPosted)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestDataPosted is a log parse operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestDataPosted(log types.Log) (*BrevisRequestRequestDataPosted, error) {
	event := new(BrevisRequestRequestDataPosted)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestFeeIncreasedIterator is returned from FilterRequestFeeIncreased and is used to iterate over the raw logs and unpacked data for RequestFeeIncreased events raised by the BrevisRequest contract.
type BrevisRequestRequestFeeIncreasedIterator struct {
	Event *BrevisRequestRequestFeeIncreased // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestFeeIncreasedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestFeeIncreased)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestFeeIncreased)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestFeeIncreasedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestFeeIncreasedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestFeeIncreased represents a RequestFeeIncreased event raised by the BrevisRequest contract.
type BrevisRequestRequestFeeIncreased struct {
	ProofId [32]byte
	Nonce   uint64
	Gas     *big.Int
	Fee     *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestFeeIncreased is a free log retrieval operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestFeeIncreased(opts *bind.FilterOpts) (*BrevisRequestRequestFeeIncreasedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestFeeIncreased")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestFeeIncreasedIterator{contract: _BrevisRequest.contract, event: "RequestFeeIncreased", logs: logs, sub: sub}, nil
}

// WatchRequestFeeIncreased is a free log subscription operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestFeeIncreased(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestFeeIncreased) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestFeeIncreased")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestFeeIncreased)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestFeeIncreased", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFeeIncreased is a log parse operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestFeeIncreased(log types.Log) (*BrevisRequestRequestFeeIncreased, error) {
	event := new(BrevisRequestRequestFeeIncreased)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestFeeIncreased", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestFulfilledIterator is returned from FilterRequestFulfilled and is used to iterate over the raw logs and unpacked data for RequestFulfilled events raised by the BrevisRequest contract.
type BrevisRequestRequestFulfilledIterator struct {
	Event *BrevisRequestRequestFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestFulfilled represents a RequestFulfilled event raised by the BrevisRequest contract.
type BrevisRequestRequestFulfilled struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestFulfilled is a free log retrieval operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestFulfilled(opts *bind.FilterOpts) (*BrevisRequestRequestFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestFulfilledIterator{contract: _BrevisRequest.contract, event: "RequestFulfilled", logs: logs, sub: sub}, nil
}

// WatchRequestFulfilled is a free log subscription operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFulfilled is a log parse operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestFulfilled(log types.Log) (*BrevisRequestRequestFulfilled, error) {
	event := new(BrevisRequestRequestFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestRefundedIterator is returned from FilterRequestRefunded and is used to iterate over the raw logs and unpacked data for RequestRefunded events raised by the BrevisRequest contract.
type BrevisRequestRequestRefundedIterator struct {
	Event *BrevisRequestRequestRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestRefunded represents a RequestRefunded event raised by the BrevisRequest contract.
type BrevisRequestRequestRefunded struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestRefunded is a free log retrieval operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestRefunded(opts *bind.FilterOpts) (*BrevisRequestRequestRefundedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestRefunded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestRefundedIterator{contract: _BrevisRequest.contract, event: "RequestRefunded", logs: logs, sub: sub}, nil
}

// WatchRequestRefunded is a free log subscription operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestRefunded(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestRefunded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestRefunded)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestRefunded is a log parse operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestRefunded(log types.Log) (*BrevisRequestRequestRefunded, error) {
	event := new(BrevisRequestRequestRefunded)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestRefunded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestSentIterator is returned from FilterRequestSent and is used to iterate over the raw logs and unpacked data for RequestSent events raised by the BrevisRequest contract.
type BrevisRequestRequestSentIterator struct {
	Event *BrevisRequestRequestSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestSent represents a RequestSent event raised by the BrevisRequest contract.
type BrevisRequestRequestSent struct {
	ProofId  [32]byte
	Nonce    uint64
	Refundee common.Address
	Fee      *big.Int
	Callback IBrevisRequestCallback
	Option   uint8
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestSent is a free log retrieval operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestSent(opts *bind.FilterOpts) (*BrevisRequestRequestSentIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestSent")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestSentIterator{contract: _BrevisRequest.contract, event: "RequestSent", logs: logs, sub: sub}, nil
}

// WatchRequestSent is a free log subscription operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestSent(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestSent) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestSent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestSent)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestSent is a log parse operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestSent(log types.Log) (*BrevisRequestRequestSent, error) {
	event := new(BrevisRequestRequestSent)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestTimeoutUpdatedIterator is returned from FilterRequestTimeoutUpdated and is used to iterate over the raw logs and unpacked data for RequestTimeoutUpdated events raised by the BrevisRequest contract.
type BrevisRequestRequestTimeoutUpdatedIterator struct {
	Event *BrevisRequestRequestTimeoutUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestTimeoutUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestTimeoutUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestTimeoutUpdated represents a RequestTimeoutUpdated event raised by the BrevisRequest contract.
type BrevisRequestRequestTimeoutUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRequestTimeoutUpdated is a free log retrieval operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestTimeoutUpdated(opts *bind.FilterOpts) (*BrevisRequestRequestTimeoutUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestTimeoutUpdatedIterator{contract: _BrevisRequest.contract, event: "RequestTimeoutUpdated", logs: logs, sub: sub}, nil
}

// WatchRequestTimeoutUpdated is a free log subscription operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestTimeoutUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestTimeoutUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestTimeoutUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestTimeoutUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestTimeoutUpdated is a log parse operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestTimeoutUpdated(log types.Log) (*BrevisRequestRequestTimeoutUpdated, error) {
	event := new(BrevisRequestRequestTimeoutUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestTimeoutUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestsCallbackFailedIterator is returned from FilterRequestsCallbackFailed and is used to iterate over the raw logs and unpacked data for RequestsCallbackFailed events raised by the BrevisRequest contract.
type BrevisRequestRequestsCallbackFailedIterator struct {
	Event *BrevisRequestRequestsCallbackFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestsCallbackFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestsCallbackFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestsCallbackFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestsCallbackFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestsCallbackFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestsCallbackFailed represents a RequestsCallbackFailed event raised by the BrevisRequest contract.
type BrevisRequestRequestsCallbackFailed struct {
	ProofIds [][32]byte
	Nonces   []uint64
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestsCallbackFailed is a free log retrieval operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestsCallbackFailed(opts *bind.FilterOpts) (*BrevisRequestRequestsCallbackFailedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestsCallbackFailed")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestsCallbackFailedIterator{contract: _BrevisRequest.contract, event: "RequestsCallbackFailed", logs: logs, sub: sub}, nil
}

// WatchRequestsCallbackFailed is a free log subscription operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestsCallbackFailed(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestsCallbackFailed) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestsCallbackFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestsCallbackFailed)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestsCallbackFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestsCallbackFailed is a log parse operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestsCallbackFailed(log types.Log) (*BrevisRequestRequestsCallbackFailed, error) {
	event := new(BrevisRequestRequestsCallbackFailed)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestsCallbackFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestsFulfilledIterator is returned from FilterRequestsFulfilled and is used to iterate over the raw logs and unpacked data for RequestsFulfilled events raised by the BrevisRequest contract.
type BrevisRequestRequestsFulfilledIterator struct {
	Event *BrevisRequestRequestsFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestsFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestsFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestsFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestsFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestsFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestsFulfilled represents a RequestsFulfilled event raised by the BrevisRequest contract.
type BrevisRequestRequestsFulfilled struct {
	ProofIds [][32]byte
	Nonces   []uint64
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestsFulfilled is a free log retrieval operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestsFulfilled(opts *bind.FilterOpts) (*BrevisRequestRequestsFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestsFulfilledIterator{contract: _BrevisRequest.contract, event: "RequestsFulfilled", logs: logs, sub: sub}, nil
}

// WatchRequestsFulfilled is a free log subscription operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestsFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestsFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestsFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestsFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestsFulfilled is a log parse operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestsFulfilled(log types.Log) (*BrevisRequestRequestsFulfilled, error) {
	event := new(BrevisRequestRequestsFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestsFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestResponseTimeoutUpdatedIterator is returned from FilterResponseTimeoutUpdated and is used to iterate over the raw logs and unpacked data for ResponseTimeoutUpdated events raised by the BrevisRequest contract.
type BrevisRequestResponseTimeoutUpdatedIterator struct {
	Event *BrevisRequestResponseTimeoutUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestResponseTimeoutUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestResponseTimeoutUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestResponseTimeoutUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestResponseTimeoutUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestResponseTimeoutUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestResponseTimeoutUpdated represents a ResponseTimeoutUpdated event raised by the BrevisRequest contract.
type BrevisRequestResponseTimeoutUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterResponseTimeoutUpdated is a free log retrieval operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) FilterResponseTimeoutUpdated(opts *bind.FilterOpts) (*BrevisRequestResponseTimeoutUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestResponseTimeoutUpdatedIterator{contract: _BrevisRequest.contract, event: "ResponseTimeoutUpdated", logs: logs, sub: sub}, nil
}

// WatchResponseTimeoutUpdated is a free log subscription operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) WatchResponseTimeoutUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestResponseTimeoutUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestResponseTimeoutUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseResponseTimeoutUpdated is a log parse operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) ParseResponseTimeoutUpdated(log types.Log) (*BrevisRequestResponseTimeoutUpdated, error) {
	event := new(BrevisRequestResponseTimeoutUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisRequest contract.
type BrevisRequestUnpausedIterator struct {
	Event *BrevisRequestUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestUnpaused represents a Unpaused event raised by the BrevisRequest contract.
type BrevisRequestUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisRequestUnpausedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestUnpausedIterator{contract: _BrevisRequest.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisRequestUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestUnpaused)
				if err := _BrevisRequest.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseUnpaused(log types.Log) (*BrevisRequestUnpaused, error) {
	event := new(BrevisRequestUnpaused)
	if err := _BrevisRequest.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CommitteeRootMappingVerifierMetaData contains all meta data concerning the CommitteeRootMappingVerifier contract.
var CommitteeRootMappingVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[33]\",\"name\":\"input\",\"type\":\"uint256[33]\"}],\"name\":\"verifyCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234610016576119f1908161001b8239f35b5f80fdfe6040608081526004361015610012575f80fd5b5f803560e01c63ab00dde614610026575f80fd5b346100bb576105203660031901126100bb5761004136610117565b9036606312156100bb576100536100d2565b908160c4913683116100bb57506044905b8282106100a25761009e8661008d878761007d36610158565b90610087366101d6565b92610608565b905190151581529081906020820190565b0390f35b602086916100b03685610196565b815201910190610064565b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906040820182811067ffffffffffffffff8211176100f257604052565b6100be565b604051906080820182811067ffffffffffffffff8211176100f257604052565b8060231215610154576101286100d2565b90816044918211610154576004905b8282106101445750505090565b8135815260209182019101610137565b5f80fd5b8060e31215610154576101696100d2565b90816101049182116101545760c4905b8282106101865750505090565b8135815260209182019101610179565b9080601f83011215610154576101aa6100d2565b80926040810192831161015457905b8282106101c65750505090565b81358152602091820191016101b9565b8061012312156101545760405190610420820182811067ffffffffffffffff8211176100f2576040528161052491821161015457610104905b82821061021c5750505090565b813581526020918201910161020f565b6102346100f7565b906080368337565b604051906060820182811067ffffffffffffffff8211176100f2576040526060368337565b604051906020820182811067ffffffffffffffff8211176100f2576040526020368337565b61028e6100d2565b906102976100d2565b604036823782526102a66100d2565b60403682376020830152565b6102ba6100f7565b906102c36100d2565b5f9081815281602082015283526102d8610286565b60208401526102e56100d2565b81815281602082015260408401526102fb6100d2565b9080825260208201526060830152565b634e487b7160e01b5f52603260045260245ffd5b1561032657565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561037257565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b156103be57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561040a57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561045657565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104a257565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104ee57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561053a57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f1981146105a15760010190565b61057f565b9060218110156105b75760051b0190565b61030b565b156105c357565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b90919392936106156102b2565b9180516020809201516106266100d2565b9182528282015283526106376100d2565b938051518552610648815160200190565b5182860152610667826106596100d2565b920180515183525160200190565b51828201526106746100d2565b9485528185015280830193845280825192015161068f6100d2565b92835281830152604083019182526107437f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476106ce818651511061031f565b6106dd8184875101511061036b565b6106eb8187515151106103b7565b6106fb8184885101515110610403565b6107128161070b88515160200190565b511061044f565b61072b81610724858951015160200190565b511061049b565b61073881855151106104e7565b828451015110610533565b5f5b6021811061139057509461138d949561137161075f611418565b9461136b61076b6100d2565b80955f82528582015f815261077e61022c565b9161078761023c565b907f305c9c1aa4a3294d7d6f331d65dc097fd9b9011350a6065eed3d56ad4d48a5e26107b16100d2565b935f85525f8b8601527f2d704aa2e65d5ad168e2ebdd814a37bf7f58961077a78e2ce2eea371cf886b0e8752527f05595e70b8c63dfb8fe2f8adb49c225ee5e6f783b5736f3221d423194db5585d8252610400898301917e7f03a8f871280b33c0292e973247afd9cddfa419e978678bde69323baece8383527f0e4ddacfcf167969963d2bb01ca92fa86b4bfd92c37917bad4ab760f0279625081519360408601948552610861898989896116a5565b7f2cbe10c7c83f6dbe1bc89736f5dc9a9b91e55be6941a4b99b058acd8001fb00486527f1500351867036612a9db15b6f7d4198993f31565af0610ed3fda8d92ffb5e67181528c83015185526108b9898989896116a5565b7f2ff215cfa1c7c99fc0b382d9d7225a0636ccd9a01be83959da430a3a25d4481f86527f2918236b7c008f70fc98cc3bcc41eb60fb8b85d02b4e83100de7a9a7eed34645815260408301518552610912898989896116a5565b7f0943a399c312616b46deee38e49b364b3449d7bab638b580df78aece26ecedf186527f11c937747adbd7b45585d385c0174241e937dce9fa818ca66d00f550b3f3d12881526060830151855261096b898989896116a5565b7f05dd54c0736f8a8d838a097e3151776cc6f602439ecc7833d223dc6cc69d585186527ee6465472f5b3647daa18848088f62f4fe1e57c401172d39f45b827bcc898f78152608083015185526109c3898989896116a5565b7f0d64a91e0e28a2e96b12a3211ebd9f66d854efbc1bd17fccc28e33993722b96d86527f0b30126ec8f40991e90ef34a78e10acb9848fe65e84547e64346fbaebafc9a98815260a08301518552610a1c898989896116a5565b7f08272a78392bca7c2597f09f39daf6f7129808e6a6b34a49239dbf2a264e4e3b86527f02ac17971af65a980f6ab150b8ebaf573008d90c0af4eeed28d50374e8eed16b815260c08301518552610a75898989896116a5565b7f19e3f8ff1265325376056bd2155edf79762433ec7b24c2196701da40ff2e6b3186527f0b33297cf3ae84083dab64e559bccd29e271c3e7d9ba307b7d623d223d091ead815260e08301518552610ace898989896116a5565b7f01341f47e05793a19ea7b92ff3b84c73f7223d56104d070f246e00eb1db7967986527f052fb71e652150885399cfb863b33f0dc0dfe9b279d0bf29df0fc403810fdb1781526101008301518552610b28898989896116a5565b7f04e2785630031d901e87c72d18c1e526142d7b79ee5b4360f5f9373d385aa1be86527f13fdbcc7f866114bdd363bc99c54b3ea0921b9b5526e46885291a00f8f9feea781526101208301518552610b82898989896116a5565b7f0bc888012014ac70c1692250c46020392de91756724c6c890edbc8d860450b8086527f02ce5d7f6c5c1ec90a48c08531305543ef94f25d0d03f67124280afb560406d481526101408301518552610bdc898989896116a5565b7f0aee169033d6ddce5c5dde351a6ce45eb60dc3018752274e14f68e3f19a5359686527f1481dacc3a815550ede26690b83395cb031c17fb4aca75baa0a74acc4042335181526101608301518552610c36898989896116a5565b7f1c24a404b575734133f0c03bbf71c74c5b03a34f1d0817662c7d9293eaecaad586527f10af37e497d439239dfdab04bce89b1eaeaa12bc5f327129816a7a3841863fdd81526101808301518552610c90898989896116a5565b7f14a256de1a2c7bb25672a1acc5406b90543c8a3b8c7c6e0a1895f019171141a886527f08f0539c9fd5ef363053e6560e4769e20e56dd0a510c30dce8adab0230c5fdb181526101a08301518552610cea898989896116a5565b7f082d61eb34a0a6544527e7db6b9bd16a8f6488733c83bee559ec5378191c93ba86527f144b7ab9c8fd2fb71b51c102820f2b08303be60f9fdd313e68f412d3f027a82081526101c08301518552610d44898989896116a5565b7f22510e5ce22c30374993b2a360ceed3bdc20bd64b8d14cb3baedf76ddbd8062386527f0c0c88dfbf63ebc976d642a63c3d22288c546570b101f0219b3e2f3af5bedcfb81526101e08301518552610d9e898989896116a5565b7f2c71d775cc194f6e13408a12a33cb48babccfee137654d1443371de1d0f30c0c86527f1ba219dea8d4ffd8339c1c10cda690451c10fb5058f36ce7e1407118d871cc8081526102008301518552610df8898989896116a5565b7f14e7d115c5cfbe3c075697f305b8660abf41c5725a40557d3e14c9703aef64c286527f0cbc84b02d09b3f498b122ab5819248195aea678e0a41e744967da6bd8d0ce1181526102208301518552610e52898989896116a5565b7f0332f7d5660e970f229a174367929acabfa2f9fdab763460fd7acebddd944dde86527f15be1ce817121a7c25340b8d9c50a584a179d3dffd489f54311a12f922a6942f81526102408301518552610eac898989896116a5565b7f0257933903a2e91846df829f8084008ddf5fc35dd8d4acdebd426bff0d97e2a386527f17e9653840e81e1a68076e0c5f8c89f61463791e918991df86c86f63dccd939181526102608301518552610f06898989896116a5565b7f106f1170be9c02c979b3d6e1d43737530d6bfc444c16df873400384d39e393be86527f1c2b9f619d809bb543e712ac0ee22cc3c6aa99ae73c97246c9769c9c98713fc581526102808301518552610f60898989896116a5565b7f131eb8c00ed76432c870a74c71365748a51807c021e678beb083b0e7e8b5b61186527f2491a76ab72146d0aeb330815df908ad5dd6cd86201e97d220b63d0d8d0f3ac481526102a08301518552610fba898989896116a5565b7f2561f4abb9fabeeb813dcc6d4d487d8f6e36fdd18805e785cccdf2b0a2ff085786527f2e6269f87539d6b464a25b6bd4522d1e2b78c3918f48e79de55dd640261faa4281526102c08301518552611014898989896116a5565b7f2e485df27f23a93b97e296061758e7dd3d34c4722c6fd7ae249433c55d259adc86527f1614f76a407ac31a5acb91266c2c7f54166ee17112e69f0b5e5fad32dafe5f6581526102e0830151855261106e898989896116a5565b7f153af4e0fe4af748819ca675d8781da95111510763de4bec8abf25bca637703b86527f0b1f5a812c51999ebc7ac97de6ab2409b894ad5fb02d45f0798acc2548344cb9815261030083015185526110c8898989896116a5565b7f2c69e0646f6bfc70dfd02cf64d0b781ab481cafbd190dba9ee603f8160c44dcd86527f126015936956b109beba47938f9808cd9eed7ba5fc4531e6f6f267cadb13f4f881526103208301518552611122898989896116a5565b7f22c6d8b6cf6965d431abf72b985b44f1d0831026a43d6dc8cbcb9ca85ab4a0bc86527f19fd6ce3da2b55331cdd361a63f29e95c52f07bcf9cbe355077e5141bf020d838152610340830151855261117c898989896116a5565b7f0cc996a6a427bcf59dad5cb6a2da92164e142372347a8ca5b1b3b32d8b20a0ef86527f232f08e45f51e15d57617fc960278b4dd236ed78e9014d43950751ea862841f1815261036083015185526111d6898989896116a5565b7f1e03c25c13870ae3e127e009be017aa0f47c7b53fc8636bd519ad68f035aa55c86527f04d8795eee1d4bcb8a4042ed861d91024ec5ce76c4fdac892d0c00479874519981526103808301518552611230898989896116a5565b7f2690cf34bdf3837f3036c3c61e73f94f8026f6a6e9be13695cf81ccebbac7ca886527f0db77d728541f6ab723d2dc8389a97864f9e61349120d35d76c004579c3fc10881526103a0830151855261128a898989896116a5565b7f10f3808b8fb7eb5be9d22fa5e7b4599e94116d5803607ae38bd3c637c10224f286527f06cb766b59e904c5b47098c0f98af9c4444f614cf303f1c939fd24b6bd60cc9c81526103c083015185526112e4898989896116a5565b7f1610f9fbade90d90feada79ae229d67175dee93355fbbf229133ce0d6e75e3a186527f1a3084c2af6e7f823d2044866e00b80af74b5586f26c9685943786f355712ddd81526103e0830151855261133e898989896116a5565b7f1b88a7f08e12e3e28b9b10c0c0cbfd8d7df8b8a8fae1840b33c1cd4d24c8b23c865252015190526116a5565b516116ec565b945190845190850151916060604087015195519601519661185d565b90565b806113c97f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000016113c26113ce948b6105a6565b51106105bc565b610593565b610745565b6113db6100f7565b906113e46100d2565b5f81525f602082015282526113f7610286565b6020830152611404610286565b6040830152611411610286565b6060830152565b6114206113d3565b906114296100d2565b7f0a3a3884405b8d1fe46693685f02ba163634fd63d14bf91b6a433825b9ed6b5a81526020907f111fc830b029cfb2c94e450b570cf3be3eac81076213c2dcb1e1059330c605bf82820152835261147e6100d2565b7f23ab779b99bf99c421500d8fe70c4e84fc1ff6eefdf3e92d8f581d046cb3eab781527f1611f26f3d9d6b19c4a418d02f19f6796be688f08507bc59ee5f9862dd46fa5b828201526114ce6100d2565b7f2d34a3d654ca9ea36195f8167d653fa7240b0af8acad4b224aed268f9d8756ff81527f178cda417a663a79267fba64b28caf8fc8484866bfe0f423cb8d3b7da164d7f98382015261151e6100d2565b91825282820152818401526115316100d2565b7f1f682eee4eeb25b38c3bff07fad9aaeb8c1ae87a95472a7819a57fd8b37a6e1581527f0db20bc4434468f4ce7f5888da80c6013c5392645400eee1ddbb77b0696ea1a7828201526115816100d2565b7f01979b2d16e0fb974244f72e399fd4d24be132523f4aeb010c75f26b6452d53c81527f21900fdcdfde4102dbbcd9525e925c0f4ea5317aefc7a1c350753b5c9741ebd5838201526115d16100d2565b9182528282015260408401526115e56100d2565b907f04969a13dd24e7586c1e7e668f9be1cfab2bfb7baf9e48cd94428a55b4cfb89882527f3026f4334a515ea181839681e5a601e08615013a7355b0a0ad1c6ffce279eb16818301526116366100d2565b907f0987e27c310f4a785adc7dfc5324848dc4b1b4957907733a04c889777c88a78582527f13c07cb3a59387f85f315e9b41060f8a993a3c3d22113439d63f9be212afc234818301526116876100d2565b9283528201526060830152565b9060048110156105b75760051b0190565b90929160608460806107cf19946007865a01fa156116ea57600660c0926020606096865185528187015182860152805160408601520151868401525a01fa156116ea57565bfe5b5f60206116f76100d2565b8281520152805190811580611767575b156117225750506117166100d2565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479081900681039081116105a15761175c6100d2565b918252602082015290565b50602081015115611707565b60405190610320820182811067ffffffffffffffff8211176100f25760405260188252610300366020840137565b906006820291808304600614901517156105a157565b90600182018092116105a157565b90600282018092116105a157565b90600382018092116105a157565b90600482018092116105a157565b90600582018092116105a157565b80518210156105b75760209160051b010190565b1561181857565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b949195969290939661186d6100f7565b9586526020978897888801526040870152606086015261188b6100f7565b93845285840152604083015260608201526118a4611773565b915f5b600481106118df575050506103006118bd610261565b9384920160086107cf195a01fa80156116ea576118d990611811565b51151590565b6119b191929394506118f0816117a1565b6118fa8285611694565b515161190682886117fd565b52866119128386611694565b510151611927611921836117b7565b886117fd565b526119328286611694565b515151611941611921836117c5565b5261195761194f8387611694565b515160200190565b51611964611921836117d3565b52866119708387611694565b51015151611980611921836117e1565b526119ab6119a561199e89611995868a611694565b51015160200190565b51926117ef565b876117fd565b52610593565b90849392916118a756fea26469706673582212207cfeb77e25c1fbfca65bab6160d1261a4a88ce543dd09d70d7385b44efd1e52e64736f6c63430008140033",
}

// CommitteeRootMappingVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use CommitteeRootMappingVerifierMetaData.ABI instead.
var CommitteeRootMappingVerifierABI = CommitteeRootMappingVerifierMetaData.ABI

// CommitteeRootMappingVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CommitteeRootMappingVerifierMetaData.Bin instead.
var CommitteeRootMappingVerifierBin = CommitteeRootMappingVerifierMetaData.Bin

// DeployCommitteeRootMappingVerifier deploys a new Ethereum contract, binding an instance of CommitteeRootMappingVerifier to it.
func DeployCommitteeRootMappingVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CommitteeRootMappingVerifier, error) {
	parsed, err := CommitteeRootMappingVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CommitteeRootMappingVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CommitteeRootMappingVerifier{CommitteeRootMappingVerifierCaller: CommitteeRootMappingVerifierCaller{contract: contract}, CommitteeRootMappingVerifierTransactor: CommitteeRootMappingVerifierTransactor{contract: contract}, CommitteeRootMappingVerifierFilterer: CommitteeRootMappingVerifierFilterer{contract: contract}}, nil
}

// CommitteeRootMappingVerifier is an auto generated Go binding around an Ethereum contract.
type CommitteeRootMappingVerifier struct {
	CommitteeRootMappingVerifierCaller     // Read-only binding to the contract
	CommitteeRootMappingVerifierTransactor // Write-only binding to the contract
	CommitteeRootMappingVerifierFilterer   // Log filterer for contract events
}

// CommitteeRootMappingVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CommitteeRootMappingVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CommitteeRootMappingVerifierSession struct {
	Contract     *CommitteeRootMappingVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts                 // Call options to use throughout this session
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// CommitteeRootMappingVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CommitteeRootMappingVerifierCallerSession struct {
	Contract *CommitteeRootMappingVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                       // Call options to use throughout this session
}

// CommitteeRootMappingVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CommitteeRootMappingVerifierTransactorSession struct {
	Contract     *CommitteeRootMappingVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                       // Transaction auth options to use throughout this session
}

// CommitteeRootMappingVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierRaw struct {
	Contract *CommitteeRootMappingVerifier // Generic contract binding to access the raw methods on
}

// CommitteeRootMappingVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierCallerRaw struct {
	Contract *CommitteeRootMappingVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// CommitteeRootMappingVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierTransactorRaw struct {
	Contract *CommitteeRootMappingVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCommitteeRootMappingVerifier creates a new instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifier(address common.Address, backend bind.ContractBackend) (*CommitteeRootMappingVerifier, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifier{CommitteeRootMappingVerifierCaller: CommitteeRootMappingVerifierCaller{contract: contract}, CommitteeRootMappingVerifierTransactor: CommitteeRootMappingVerifierTransactor{contract: contract}, CommitteeRootMappingVerifierFilterer: CommitteeRootMappingVerifierFilterer{contract: contract}}, nil
}

// NewCommitteeRootMappingVerifierCaller creates a new read-only instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierCaller(address common.Address, caller bind.ContractCaller) (*CommitteeRootMappingVerifierCaller, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierCaller{contract: contract}, nil
}

// NewCommitteeRootMappingVerifierTransactor creates a new write-only instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*CommitteeRootMappingVerifierTransactor, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierTransactor{contract: contract}, nil
}

// NewCommitteeRootMappingVerifierFilterer creates a new log filterer instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*CommitteeRootMappingVerifierFilterer, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierFilterer{contract: contract}, nil
}

// bindCommitteeRootMappingVerifier binds a generic wrapper to an already deployed contract.
func bindCommitteeRootMappingVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CommitteeRootMappingVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CommitteeRootMappingVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCaller) VerifyCommitteeRootMappingProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	var out []interface{}
	err := _CommitteeRootMappingVerifier.contract.Call(opts, &out, "verifyCommitteeRootMappingProof", a, b, c, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _CommitteeRootMappingVerifier.Contract.VerifyCommitteeRootMappingProof(&_CommitteeRootMappingVerifier.CallOpts, a, b, c, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCallerSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _CommitteeRootMappingVerifier.Contract.VerifyCommitteeRootMappingProof(&_CommitteeRootMappingVerifier.CallOpts, a, b, c, input)
}

// CommonMetaData contains all meta data concerning the Common contract.
var CommonMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220a90e4625f375711452c9f5d92f5da7d2dad664e6ee96ea7951a6a9e3803b37ea64736f6c63430008140033",
}

// CommonABI is the input ABI used to generate the binding from.
// Deprecated: Use CommonMetaData.ABI instead.
var CommonABI = CommonMetaData.ABI

// CommonBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CommonMetaData.Bin instead.
var CommonBin = CommonMetaData.Bin

// DeployCommon deploys a new Ethereum contract, binding an instance of Common to it.
func DeployCommon(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Common, error) {
	parsed, err := CommonMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CommonBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Common{CommonCaller: CommonCaller{contract: contract}, CommonTransactor: CommonTransactor{contract: contract}, CommonFilterer: CommonFilterer{contract: contract}}, nil
}

// Common is an auto generated Go binding around an Ethereum contract.
type Common struct {
	CommonCaller     // Read-only binding to the contract
	CommonTransactor // Write-only binding to the contract
	CommonFilterer   // Log filterer for contract events
}

// CommonCaller is an auto generated read-only Go binding around an Ethereum contract.
type CommonCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CommonTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CommonFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CommonSession struct {
	Contract     *Common           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CommonCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CommonCallerSession struct {
	Contract *CommonCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// CommonTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CommonTransactorSession struct {
	Contract     *CommonTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CommonRaw is an auto generated low-level Go binding around an Ethereum contract.
type CommonRaw struct {
	Contract *Common // Generic contract binding to access the raw methods on
}

// CommonCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CommonCallerRaw struct {
	Contract *CommonCaller // Generic read-only contract binding to access the raw methods on
}

// CommonTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CommonTransactorRaw struct {
	Contract *CommonTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCommon creates a new instance of Common, bound to a specific deployed contract.
func NewCommon(address common.Address, backend bind.ContractBackend) (*Common, error) {
	contract, err := bindCommon(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Common{CommonCaller: CommonCaller{contract: contract}, CommonTransactor: CommonTransactor{contract: contract}, CommonFilterer: CommonFilterer{contract: contract}}, nil
}

// NewCommonCaller creates a new read-only instance of Common, bound to a specific deployed contract.
func NewCommonCaller(address common.Address, caller bind.ContractCaller) (*CommonCaller, error) {
	contract, err := bindCommon(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CommonCaller{contract: contract}, nil
}

// NewCommonTransactor creates a new write-only instance of Common, bound to a specific deployed contract.
func NewCommonTransactor(address common.Address, transactor bind.ContractTransactor) (*CommonTransactor, error) {
	contract, err := bindCommon(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CommonTransactor{contract: contract}, nil
}

// NewCommonFilterer creates a new log filterer instance of Common, bound to a specific deployed contract.
func NewCommonFilterer(address common.Address, filterer bind.ContractFilterer) (*CommonFilterer, error) {
	contract, err := bindCommon(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CommonFilterer{contract: contract}, nil
}

// bindCommon binds a generic wrapper to an already deployed contract.
func bindCommon(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CommonMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Common *CommonRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Common.Contract.CommonCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Common *CommonRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Common.Contract.CommonTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Common *CommonRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Common.Contract.CommonTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Common *CommonCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Common.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Common *CommonTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Common.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Common *CommonTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Common.Contract.contract.Transact(opts, method, params...)
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// Context is an auto generated Go binding around an Ethereum contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContextMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// CurrencyLibraryMetaData contains all meta data concerning the CurrencyLibrary contract.
var CurrencyLibraryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234601857606f908161001d823930815050f35b5f80fdfe60808060405260043610156011575f80fd5b5f3560e01c63a0cf0aea146023575f80fd5b5f366003190112603557805f60209252f35b5f80fdfea26469706673582212207c1f3b40944783cc503f197c1429c329f3ba9a0cfd3f490073aed42ef4d8109f64736f6c63430008140033",
}

// CurrencyLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use CurrencyLibraryMetaData.ABI instead.
var CurrencyLibraryABI = CurrencyLibraryMetaData.ABI

// CurrencyLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CurrencyLibraryMetaData.Bin instead.
var CurrencyLibraryBin = CurrencyLibraryMetaData.Bin

// DeployCurrencyLibrary deploys a new Ethereum contract, binding an instance of CurrencyLibrary to it.
func DeployCurrencyLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CurrencyLibrary, error) {
	parsed, err := CurrencyLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CurrencyLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CurrencyLibrary{CurrencyLibraryCaller: CurrencyLibraryCaller{contract: contract}, CurrencyLibraryTransactor: CurrencyLibraryTransactor{contract: contract}, CurrencyLibraryFilterer: CurrencyLibraryFilterer{contract: contract}}, nil
}

// CurrencyLibrary is an auto generated Go binding around an Ethereum contract.
type CurrencyLibrary struct {
	CurrencyLibraryCaller     // Read-only binding to the contract
	CurrencyLibraryTransactor // Write-only binding to the contract
	CurrencyLibraryFilterer   // Log filterer for contract events
}

// CurrencyLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type CurrencyLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CurrencyLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CurrencyLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CurrencyLibrarySession struct {
	Contract     *CurrencyLibrary  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CurrencyLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CurrencyLibraryCallerSession struct {
	Contract *CurrencyLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// CurrencyLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CurrencyLibraryTransactorSession struct {
	Contract     *CurrencyLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// CurrencyLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type CurrencyLibraryRaw struct {
	Contract *CurrencyLibrary // Generic contract binding to access the raw methods on
}

// CurrencyLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CurrencyLibraryCallerRaw struct {
	Contract *CurrencyLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// CurrencyLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CurrencyLibraryTransactorRaw struct {
	Contract *CurrencyLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCurrencyLibrary creates a new instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibrary(address common.Address, backend bind.ContractBackend) (*CurrencyLibrary, error) {
	contract, err := bindCurrencyLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibrary{CurrencyLibraryCaller: CurrencyLibraryCaller{contract: contract}, CurrencyLibraryTransactor: CurrencyLibraryTransactor{contract: contract}, CurrencyLibraryFilterer: CurrencyLibraryFilterer{contract: contract}}, nil
}

// NewCurrencyLibraryCaller creates a new read-only instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryCaller(address common.Address, caller bind.ContractCaller) (*CurrencyLibraryCaller, error) {
	contract, err := bindCurrencyLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryCaller{contract: contract}, nil
}

// NewCurrencyLibraryTransactor creates a new write-only instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*CurrencyLibraryTransactor, error) {
	contract, err := bindCurrencyLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryTransactor{contract: contract}, nil
}

// NewCurrencyLibraryFilterer creates a new log filterer instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*CurrencyLibraryFilterer, error) {
	contract, err := bindCurrencyLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryFilterer{contract: contract}, nil
}

// bindCurrencyLibrary binds a generic wrapper to an already deployed contract.
func bindCurrencyLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CurrencyLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CurrencyLibrary *CurrencyLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CurrencyLibrary.Contract.CurrencyLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CurrencyLibrary *CurrencyLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.CurrencyLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CurrencyLibrary *CurrencyLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.CurrencyLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CurrencyLibrary *CurrencyLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CurrencyLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CurrencyLibrary *CurrencyLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CurrencyLibrary *CurrencyLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.contract.Transact(opts, method, params...)
}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibraryCaller) NATIVE(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CurrencyLibrary.contract.Call(opts, &out, "NATIVE")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibrarySession) NATIVE() (common.Address, error) {
	return _CurrencyLibrary.Contract.NATIVE(&_CurrencyLibrary.CallOpts)
}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibraryCallerSession) NATIVE() (common.Address, error) {
	return _CurrencyLibrary.Contract.NATIVE(&_CurrencyLibrary.CallOpts)
}

// ERC20MetaData contains all meta data concerning the ERC20 contract.
var ERC20MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234620003055762000c95803803806200001d8162000309565b928339810190604081830312620003055780516001600160401b03908181116200030557836200004f9184016200032f565b916020938482015183811162000305576200006b92016200032f565b825182811162000210576003918254916001958684811c94168015620002fa575b88851014620002e6578190601f9485811162000293575b50889085831160011462000230575f9262000224575b50505f1982861b1c191690861b1783555b8051938411620002105760049586548681811c9116801562000205575b82821014620001f257838111620001aa575b50809285116001146200014057509383949184925f9562000134575b50501b925f19911b1c19161790555b6040516108f59081620003a08239f35b015193505f8062000115565b92919084601f198116885f52855f20955f905b898383106200018f575050501062000175575b50505050811b01905562000124565b01519060f8845f19921b161c191690555f80808062000166565b85870151895590970196948501948893509081019062000153565b875f52815f208480880160051c820192848910620001e8575b0160051c019087905b828110620001dc575050620000f9565b5f8155018790620001cc565b92508192620001c3565b602288634e487b7160e01b5f525260245ffd5b90607f1690620000e7565b634e487b7160e01b5f52604160045260245ffd5b015190505f80620000b9565b90889350601f19831691875f528a5f20925f5b8c8282106200027c575050841162000264575b505050811b018355620000ca565b01515f1983881b60f8161c191690555f808062000256565b8385015186558c9790950194938401930162000243565b909150855f52885f208580850160051c8201928b8610620002dc575b918a91869594930160051c01915b828110620002cd575050620000a3565b5f81558594508a9101620002bd565b92508192620002af565b634e487b7160e01b5f52602260045260245ffd5b93607f16936200008c565b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176200021057604052565b919080601f84011215620003055782516001600160401b038111620002105760209062000365601f8201601f1916830162000309565b9281845282828701011162000305575f5b8181106200038b5750825f9394955001015290565b85810183015184820184015282016200037656fe6080604081815260049182361015610015575f80fd5b5f92833560e01c91826306fdde03146104aa57508163095ea7b31461048057816318160ddd1461046157816323b872dd14610397578163313ce5671461037b578163395093511461032c57816370a08231146102f657816395d89b41146101d7578163a457c2d71461011657508063a9059cbb146100e65763dd62ed3e1461009b575f80fd5b346100e257806003193601126100e257806020926100b76105cd565b6100bf6105e7565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b50346100e257806003193601126100e25760209061010f6101056105cd565b602435903361061e565b5160018152f35b905082346101d457826003193601126101d4576101316105cd565b91836024359233815260016020528181206001600160a01b038616825260205220549082821061016b5760208561010f85850387336107c1565b608490602086519162461bcd60e51b8352820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152fd5b80fd5b8383346100e257816003193601126100e257805190828454600181811c908083169283156102ec575b60209384841081146102d9578388529081156102bd5750600114610268575b505050829003601f01601f191682019267ffffffffffffffff8411838510176102555750829182610251925282610586565b0390f35b634e487b7160e01b815260418552602490fd5b8787529192508591837f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b5b8385106102a9575050505083010185808061021f565b805488860183015293019284908201610293565b60ff1916878501525050151560051b840101905085808061021f565b634e487b7160e01b895260228a52602489fd5b91607f1691610200565b5050346100e25760203660031901126100e257806020926001600160a01b0361031d6105cd565b16815280845220549051908152f35b5050346100e257806003193601126100e25761010f60209261037461034f6105cd565b91338152600186528481206001600160a01b03841682528652846024359120546105fd565b90336107c1565b5050346100e257816003193601126100e2576020905160128152f35b839150346100e25760603660031901126100e2576103b36105cd565b6103bb6105e7565b9184604435946001600160a01b038416815260016020528181203382526020522054905f1982036103f5575b60208661010f87878761061e565b84821061041e57509183916104136020969561010f950333836107c1565b9193948193506103e7565b606490602087519162461bcd60e51b8352820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152fd5b5050346100e257816003193601126100e2576020906002549051908152f35b5050346100e257806003193601126100e25760209061010f6104a06105cd565b60243590336107c1565b8490843461058257826003193601126105825782600354600181811c90808316928315610578575b60209384841081146102d9578388529081156102bd575060011461052257505050829003601f01601f191682019267ffffffffffffffff8411838510176102555750829182610251925282610586565b600387529192508591837fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b5b838510610564575050505083010185808061021f565b80548886018301529301928490820161054e565b91607f16916104d2565b8280fd5b602080825282518183018190529093925f5b8281106105b957505060409293505f838284010152601f8019910116010190565b818101860151848201604001528501610598565b600435906001600160a01b03821682036105e357565b5f80fd5b602435906001600160a01b03821682036105e357565b9190820180921161060a57565b634e487b7160e01b5f52601160045260245ffd5b6001600160a01b038091169182156107565716918215610705575f8281528060205260408120549180831061069a57604082827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef95876020965282865203828220558681522061068f8282546105fd565b9055604051908152a3565b60405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608490fd5b60405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608490fd5b60405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b0380911691821561086e571691821561081e5760207f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591835f526001825260405f20855f5282528060405f2055604051908152a3565b60405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608490fd5b60405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608490fdfea2646970667358221220ee6f9b29e27e07bbb0cca767b54305831223e002caaaf19329d5985d27164b8b64736f6c63430008140033",
}

// ERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20MetaData.ABI instead.
var ERC20ABI = ERC20MetaData.ABI

// ERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20MetaData.Bin instead.
var ERC20Bin = ERC20MetaData.Bin

// DeployERC20 deploys a new Ethereum contract, binding an instance of ERC20 to it.
func DeployERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string) (common.Address, *types.Transaction, *ERC20, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20Bin), backend, name_, symbol_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// ERC20 is an auto generated Go binding around an Ethereum contract.
type ERC20 struct {
	ERC20Caller     // Read-only binding to the contract
	ERC20Transactor // Write-only binding to the contract
	ERC20Filterer   // Log filterer for contract events
}

// ERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20Session struct {
	Contract     *ERC20            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20CallerSession struct {
	Contract *ERC20Caller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20TransactorSession struct {
	Contract     *ERC20Transactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20Raw struct {
	Contract *ERC20 // Generic contract binding to access the raw methods on
}

// ERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20CallerRaw struct {
	Contract *ERC20Caller // Generic read-only contract binding to access the raw methods on
}

// ERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20TransactorRaw struct {
	Contract *ERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20 creates a new instance of ERC20, bound to a specific deployed contract.
func NewERC20(address common.Address, backend bind.ContractBackend) (*ERC20, error) {
	contract, err := bindERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// NewERC20Caller creates a new read-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Caller(address common.Address, caller bind.ContractCaller) (*ERC20Caller, error) {
	contract, err := bindERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Caller{contract: contract}, nil
}

// NewERC20Transactor creates a new write-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC20Transactor, error) {
	contract, err := bindERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Transactor{contract: contract}, nil
}

// NewERC20Filterer creates a new log filterer instance of ERC20, bound to a specific deployed contract.
func NewERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC20Filterer, error) {
	contract, err := bindERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20Filterer{contract: contract}, nil
}

// bindERC20 binds a generic wrapper to an already deployed contract.
func bindERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.ERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Session) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20CallerSession) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Session) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20CallerSession) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Session) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20CallerSession) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Session) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// ERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20 contract.
type ERC20ApprovalIterator struct {
	Event *ERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Approval represents a Approval event raised by the ERC20 contract.
type ERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20ApprovalIterator{contract: _ERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Approval)
				if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) ParseApproval(log types.Log) (*ERC20Approval, error) {
	event := new(ERC20Approval)
	if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20 contract.
type ERC20TransferIterator struct {
	Event *ERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Transfer represents a Transfer event raised by the ERC20 contract.
type ERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20TransferIterator{contract: _ERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Transfer)
				if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) ParseTransfer(log types.Log) (*ERC20Transfer, error) {
	event := new(ERC20Transfer)
	if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BurnableMetaData contains all meta data concerning the ERC20Burnable contract.
var ERC20BurnableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ERC20BurnableABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20BurnableMetaData.ABI instead.
var ERC20BurnableABI = ERC20BurnableMetaData.ABI

// ERC20Burnable is an auto generated Go binding around an Ethereum contract.
type ERC20Burnable struct {
	ERC20BurnableCaller     // Read-only binding to the contract
	ERC20BurnableTransactor // Write-only binding to the contract
	ERC20BurnableFilterer   // Log filterer for contract events
}

// ERC20BurnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20BurnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20BurnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20BurnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20BurnableSession struct {
	Contract     *ERC20Burnable    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20BurnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20BurnableCallerSession struct {
	Contract *ERC20BurnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ERC20BurnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20BurnableTransactorSession struct {
	Contract     *ERC20BurnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ERC20BurnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20BurnableRaw struct {
	Contract *ERC20Burnable // Generic contract binding to access the raw methods on
}

// ERC20BurnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20BurnableCallerRaw struct {
	Contract *ERC20BurnableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20BurnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20BurnableTransactorRaw struct {
	Contract *ERC20BurnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Burnable creates a new instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20Burnable(address common.Address, backend bind.ContractBackend) (*ERC20Burnable, error) {
	contract, err := bindERC20Burnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Burnable{ERC20BurnableCaller: ERC20BurnableCaller{contract: contract}, ERC20BurnableTransactor: ERC20BurnableTransactor{contract: contract}, ERC20BurnableFilterer: ERC20BurnableFilterer{contract: contract}}, nil
}

// NewERC20BurnableCaller creates a new read-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableCaller(address common.Address, caller bind.ContractCaller) (*ERC20BurnableCaller, error) {
	contract, err := bindERC20Burnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableCaller{contract: contract}, nil
}

// NewERC20BurnableTransactor creates a new write-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20BurnableTransactor, error) {
	contract, err := bindERC20Burnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransactor{contract: contract}, nil
}

// NewERC20BurnableFilterer creates a new log filterer instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20BurnableFilterer, error) {
	contract, err := bindERC20Burnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableFilterer{contract: contract}, nil
}

// bindERC20Burnable binds a generic wrapper to an already deployed contract.
func bindERC20Burnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20BurnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.ERC20BurnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCallerSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burnFrom", account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// ERC20BurnableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20Burnable contract.
type ERC20BurnableApprovalIterator struct {
	Event *ERC20BurnableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableApproval represents a Approval event raised by the ERC20Burnable contract.
type ERC20BurnableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20BurnableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableApprovalIterator{contract: _ERC20Burnable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20BurnableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableApproval)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseApproval(log types.Log) (*ERC20BurnableApproval, error) {
	event := new(ERC20BurnableApproval)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BurnableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20Burnable contract.
type ERC20BurnableTransferIterator struct {
	Event *ERC20BurnableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableTransfer represents a Transfer event raised by the ERC20Burnable contract.
type ERC20BurnableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20BurnableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransferIterator{contract: _ERC20Burnable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20BurnableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableTransfer)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseTransfer(log types.Log) (*ERC20BurnableTransfer, error) {
	event := new(ERC20BurnableTransfer)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientMetaData contains all meta data concerning the EthereumLightClient contract.
var EthereumLightClientMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"genesisTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"genesisValidatorsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64[]\",\"name\":\"_forkEpochs\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_forkVersions\",\"type\":\"bytes4[]\"},{\"internalType\":\"uint64\",\"name\":\"_finalizedSlot\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_zkVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionStateRoot\",\"type\":\"bytes32\"}],\"name\":\"FinalityUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"epoch\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"ForkVersionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionStateRoot\",\"type\":\"bytes32\"}],\"name\":\"OptimisticUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"}],\"name\":\"SyncCommitteeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bestValidUpdate\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"computeDomain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domain\",\"type\":\"bytes32\"}],\"name\":\"computeSigningRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkEpochs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkVersions\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestFinalizedSlotAndCommitteeRoots\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"currentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLightClientForceUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"finalityBranch\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"nextSyncCommitteeBranch\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientUpdate\",\"name\":\"update\",\"type\":\"tuple\"}],\"name\":\"processLightClientUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"epoch\",\"type\":\"uint64\"},{\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"updateForkVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"}],\"name\":\"verifyCommitteeSignature\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkVerifier\",\"outputs\":[{\"internalType\":\"contractIBeaconVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060c081523462000580576200599b803803806200001e81620005c2565b9283398101906101008183031262000580578051602082015184830151919390916001600160401b038111620005805783019080601f830112156200058057815190620000756200006f83620005e8565b620005c2565b92602084848152016020819460051b830101918383116200058057602001905b828210620005a75750505060608501516001600160401b038111620005805785019181601f840112156200058057825192620000d56200006f85620005e8565b9260208486815201916020839660051b8201019182116200058057602001915b81831062000584575050506200010e6080870162000600565b9360a08701519560e060c08901519801519860018060a01b038a168a03620005805760805260a05251906001600160401b03821162000331576801000000000000000082116200033157603c5482603c5580831062000524575b5090603c5f5260205f20905f5b8160021c8110620004dc5750600319811681036200048a575b505090519190506001600160401b03821162000331576801000000000000000082116200033157603d5482603d558083106200042d575b5090603d5f5260205f20905f5b8160031c8110620003de57506007198116810362000387575b50505060018060401b031660018060401b03195f5416175f5560045560055560018060a01b03199060018060a01b031681603e541617603e55603f548251903360018060a01b0382167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36001600160a81b0319163360ff60a01b19811691909117603f555f90815260208490528390205460ff1662000345575060415468010000000000000000811015620003315760018101806041558110156200031d5760415f5260205f2001903390825416179055335f5280602052805f20600160ff198254161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f860208251338152a15161536d90816200062e823960805181614b22015260a05181614be60152f35b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b62461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f925f5b600719831683038110620003a957505060031c01555f8080620001eb565b90936020620003d4600192875160e01c908560021b60031b9163ffffffff809116831b921b19161790565b950191016200038b565b5f805b60088110620003f8575083820155600101620001d2565b9490602062000423600192845160e01c908960021b60031b9163ffffffff809116831b921b19161790565b92019501620003e1565b6200046090603d5f5260205f20600780860160031c820192601c8760021b168062000467575b500160031c019062000615565b5f620001c5565b62000483905f198601908154905f199060200360031b1c169055565b5f62000453565b5f925f5b600319831683038110620004ac57505060021c01555f80806200018e565b8151919490916001916020916001600160401b03600686901b81811b19909316911690911b17950191016200048e565b5f805b60048110620004f657508382015560010162000175565b85519095916001916020916001600160401b0360068a901b81811b199092169216901b1792019501620004df565b6200055690603c5f5260205f20600380860160021c820192601887831b16806200055d575b500160021c019062000615565b5f62000168565b62000579905f198601908154905f199060200360031b1c169055565b5f62000549565b5f80fd5b82516001600160e01b0319811681036200058057815260209283019201620000f5565b60208091620005b68462000600565b81520191019062000095565b6040519190601f01601f191682016001600160401b038111838210176200033157604052565b6001600160401b038111620003315760051b60200190565b51906001600160401b03821682036200058057565b81811062000621575050565b5f81556001016200061556fe60806040526004361015610011575f80fd5b5f3560e01c8063031523dd14611ad05780631242076614611aa1578063158535ff14611a7057806339536c8f14611a535780633cf5ea9e14611a2d5780633dd3f4aa146118435780633f4ba83a1461174b57806343a6c5a61461171b57806346fbf68e146114505780634f4fef18146116fe57806358a16b44146116e15780635c975abb146116bc57806365e700de1461169f578063677625f21461156d57806367b49cc7146115505780636b2c0f55146115195780636ef8d66d14611500578063751f7f151461148d57806380f51c121461145057806382dc1ec4146114195780638456cb591461130a5780638da5cb5b146112e4578063a036e79914611295578063a1a9ad5514610dc7578063a4059e0714610daa578063aae3913b14610d72578063ab556e9f14610c27578063ba67ee4814610539578063baa94ea2146104f3578063bcbaf770146104c2578063c5190436146104a5578063d180236914610480578063d6df096d1461045a578063e153d79914610424578063e1861b0814610407578063e6c6fcec146103b8578063e79b7a5114610362578063f2fde38b1461026e578063fabc74f5146102165763fd1190ea146101d1575f80fd5b3461021257602036600319011261021257600435604354811015610212576001600160a01b0361020260209261333d565b9190546040519260031b1c168152f35b5f80fd5b34610212576020366003190112610212576001600160a01b03610237613372565b165f52604260205260ff60405f205416604051600382101561025a576020918152f35b634e487b7160e01b5f52602160045260245ffd5b3461021257602036600319011261021257610287613372565b603f54906001600160a01b03808316916102a23384146136e5565b169182156102f7577fffffffffffffffffffffffff0000000000000000000000000000000000000000168217603f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b346102125761037036613388565b6001600160a01b039061038882603f541633146136e5565b5f5b81518110156103b657806103ac846103a56103b19486614c98565b51166150b2565b614c8a565b61038a565b005b34610212576103c636613388565b6001600160a01b03906103de82603f541633146136e5565b5f5b81518110156103b657806103ac846103fb6104029486614c98565b5116614ed4565b6103e0565b34610212575f366003190112610212576020600754604051908152f35b34610212575f3660031901126102125760606001600160401b035f54166004546006549060405192835260208301526040820152f35b34610212575f3660031901126102125760206001600160a01b03603e5416604051908152f35b34610212575f3660031901126102125760206001600160401b035f5416604051908152f35b34610212575f366003190112610212576020600154604051908152f35b3461021257602036600319011261021257600435603c54811015610212576001600160401b036102026020926136a6565b3461021257602036600319011261021257600435603d548110156102125761051c602091613667565b905460405160039290921b1c60e01b6001600160e01b0319168152f35b34610212575f3660031901126102125760405161055581612fd7565b60405161056181612fa1565b6001600160401b03600854818116835260401c1660208201526009546040820152600a549060609182820152600b54608082015282526040516105a381612fd7565b6040516105af81612fbc565b600c548152604051806020600d54918281520190600d5f527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5905f5b818110610c11575050508161060191038261300d565b6020820152815260405161061481612fbc565b600e548152604051806020600f54918281520190600f5f527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802905f5b818110610bfb575050508161066691038261300d565b6020820152602082015260405161067c81612fbc565b601054815260405180602060115491828152019060115f527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68905f5b818110610be557505050816106ce91038261300d565b6020820152604082015260208301526040516106e981612fbc565b601254815260405180602060135491828152019060135f527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090905f5b818110610bcf575050508161073b91038261300d565b6020820152604083015260405161075181612fd7565b60405161075d81612fa1565b6001600160401b03601454818116835260401c1660208201526015546040820152601654838201526017546080820152815260405161079b81612fd7565b6040516107a781612fbc565b601854815260405180602060195491828152019060195f527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695905f5b818110610bb957505050816107f991038261300d565b6020820152815260405161080c81612fbc565b601a548152604051806020601b54918281520190601b5f527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1905f5b818110610ba3575050508161085e91038261300d565b6020820152602082015260405161087481612fbc565b601c548152604051806020601d54918281520190601d5f527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f905f5b818110610b8d57505050816108c691038261300d565b6020820152604082015260208201526040516108e181612fbc565b601e548152604051806020601f54918281520190601f5f527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807905f5b818110610b77575050508161093391038261300d565b6020820152604082015260215491602354906040519061095282612ff2565b60405160245f825b60028210610b605750505061096e81612fbc565b82526040519361097d85612fbc565b84936026975f955b600290818810156109ad5790602060019261099f8d6134b1565b8152019a0196019598610985565b50508787959295602084015260405180602a905f905b60028210610b49575050506109d781612fbc565b604084015260405180602c905f905b60028210610b32575050506109fa81612fbc565b8584015260405193610a0b85612ff2565b6001600160401b03602e54168552602f5460208601526030546040860152604051610a3581612ff2565b610a3d613416565b815260405195610a4c87612fbc565b86956033995f975b600290818a1015610a7c57906020600192610a6e8f6134b1565b8152019c019801979a610a54565b5050610ad8975091610af8604092610b2895948c8c6020880152610a9e61344b565b86880152610aaa61347e565b81880152808501968752610ae66001600160401b03603b54169987519d8e9d8e61038090818152019061352b565b8d810360208f01529061352b565b99868c01528a015260808901906135fb565b6001600160401b038151166101c088015260208101516101e08801520151610200860152516102208501906135fb565b6103608301520390f35b8254815260019283019291909101906020016109e6565b8254815260019283019291909101906020016109c3565b82548152600192830192919091019060200161095a565b825484526020909301926001928301920161091d565b82548452602090930192600192830192016108b0565b8254845260209093019260019283019201610848565b82548452602090930192600192830192016107e3565b8254845260209093019260019283019201610725565b82548452602090930192600192830192016106b8565b8254845260209093019260019283019201610650565b82548452602090930192600192830192016105eb565b3461021257604036600319011261021257610c4061302e565b602435906001600160e01b031982169081830361021257610c6d6001600160a01b03603f541633146136e5565b8115610d2d57603c5491600160401b9283811015610d1957806001610c959201603c556136a6565b926001600160401b038091169382549060031b9185831b921b1916179055603d5492831015610d19577f3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af93610cf284600160409601603d55613667565b63ffffffff829392549160031b9260e01c831b921b191617905582519182526020820152a1005b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601060248201527f62616420666f726b2076657273696f6e000000000000000000000000000000006044820152606490fd5b34610212576020366003190112610212576004356001600160e01b03198116810361021257610da2602091614bcb565b604051908152f35b34610212575f366003190112610212576020600454604051908152f35b34610212575f36600319011261021257610ded6001600160a01b03603f541633146136e5565b610df5614b20565b6001600160401b0390815f54169062015180820190818311611281578316111561123c5781600854169081156111f75782601454161115610e49575b610e41610e3c613730565b614787565b6103b6613e3a565b610e69906001600160401b03166001600160401b03196014541617601455565b610e9d8160085460401c1667ffffffffffffffff60401b6014549160401b169067ffffffffffffffff60401b191617601455565b600954601555600a54601655600b54601755600c54601855600d54818111610d1957600160401b90818111610d1957601954816019558082106111b7575b507fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb58054905f915b8383106111815750505050600e54601a55600f54828111610d1957818111610d1957601b5481601b55808210611141575b507f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac8028054905f915b83831061110b5750505050601054601c55601154828111610d1957818111610d1957601d5481601d558082106110cb575b507f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c688054905f915b8383106110955750505050601254601e55601354918211610d19578111610d1957601f5481601f55808210611055575b507f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a09090601f5f5281545f905b82821061101f575050610e31565b60018091940191825494817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d8070155019092611011565b817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d80791820191015b81811061108a5750610fe5565b5f815560010161107d565b60018091920192835492817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f0155019190610fb5565b817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f91820191015b8181106111005750610f8d565b5f81556001016110f3565b60018091920192835492817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc10155019190610f5c565b817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc191820191015b8181106111765750610f34565b5f8155600101611169565b60018091920192835492817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c96950155019190610f03565b817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c969591820191015b8181106111ec5750610edb565b5f81556001016111df565b60405162461bcd60e51b815260206004820152601460248201527f6e6f20626573742076616c6964207570646174650000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f74696d656f7574206e6f742070617373656400000000000000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b34610212576112a336613388565b6001600160a01b03906112bb82603f541633146136e5565b5f5b81518110156103b657806103ac846112d86112df9486614c98565b511661518e565b6112bd565b34610212575f3660031901126102125760206001600160a01b03603f5416604051908152f35b34610212575f36600319011261021257335f5260206040815261133360ff60405f205416614e88565b603f5460ff8160a01c166113d45760ff60a01b1974010000000000000000000000000000000000000000911617603f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25881604051338152a15f5b6043548110156103b657806001600160a01b036113ad6113cf9361333d565b90549060031b1c165f526042835260405f20600260ff19825416179055614c8a565b61138e565b60405162461bcd60e51b815260048101839052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b34610212576020366003190112610212576103b6611435613372565b61144b6001600160a01b03603f541633146136e5565b6150b2565b34610212576020366003190112610212576001600160a01b03611471613372565b165f526040602052602060ff60405f2054166040519015158152f35b3461021257366003190160c081126102125760a013610212576040516114b281612fa1565b6001600160401b03600435818116810361021257825260243590811681036102125781610da29160208094015260443560408201526064356060820152608435608082015260a43590614c60565b34610212575f366003190112610212576103b63361518e565b34610212576020366003190112610212576103b6611535613372565b61154b6001600160a01b03603f541633146136e5565b61518e565b34610212575f366003190112610212576020600654604051908152f35b346102125761157b36613388565b6001600160a01b0361159281603f541633146136e5565b5f5b82518110156103b657816115a88285614c98565b511690815f52604291602083815260ff60405f205416600381101561025a5761165b57604391825492600160401b841015610d195761165695611637836116177fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd03968497600195868201905561333d565b90919082549060031b916001600160a01b03809116831b921b1916179055565b825f52835260405f209060ff19825416179055604051908152a1614c8a565b611594565b6064906040519062461bcd60e51b82526004820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b34610212575f366003190112610212576020600554604051908152f35b34610212575f36600319011261021257602060ff603f5460a01c166040519015158152f35b34610212575f366003190112610212576020604154604051908152f35b34610212575f366003190112610212576020604354604051908152f35b34610212575f36600319011261021257600354600254604080519283526001600160401b03909116602083015290f35b34610212575f36600319011261021257335f5260206040815261177460ff60405f205416614e88565b603f5460ff8160a01c16156117fe5760ff60a01b1916603f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa81604051338152a15f5b6043548110156103b657806001600160a01b036117d76117f99361333d565b90549060031b1c165f526042835260405f20600160ff19825416179055614c8a565b6117b8565b60405162461bcd60e51b815260048101839052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b34610212576102603660031901126102125761185d61302e565b60a03660231901126102125760405161187581612fa1565b6001600160401b0390602435828116810361021257815260443592828416840361021257602093848301526064356040830152608435606083015260a43560808301526101a060c31936011261021257604051926118d284612ff2565b60c435908116810361021257835260e43584840152610104356040840152610140366101231901126102125760405161190a81612ff2565b3661014312156102125760405161192081612fbc565b80610164913683116102125787610124915b848310611a1e5750505082523661018312156102125760405161195481612fbc565b806101e49236841161021257905b88848310611a06579150508301523661020312156102125760405161198681612fbc565b8061022492368411610212578890915b8483106119f757505050604083015236610243121561021257604051906119bc82612fbc565b816102649136831161021257905b8282106119e8575050506103b69550606082015260608401526142fc565b813581529088019088016119ca565b82358152918101918101611996565b604091611a133685613215565b815201910190611962565b82358152918101918101611932565b34610212575f3660031901126102125760206001600160401b0360025416604051908152f35b34610212575f366003190112610212576020600354604051908152f35b3461021257602036600319011261021257600435604154811015610212576001600160a01b036102026020926132f4565b34610212575f366003190112610212576001545f54604080519283526001600160401b03909116602083015290f35b346102125760031960203682011261021257600435906001600160401b038211610212576103c090823603011261021257611b0b6080612f85565b80600401356001600160401b03811161021257611b2e9060043691840101613112565b60805260248101356001600160401b03811161021257611b549060043691840101613112565b60a05260448101356001600160401b03811161021257611b7a906004369184010161306f565b60c052606481013560e05260848101356001600160401b03811161021257611ba8906004369184010161306f565b6101005260a481013561012052611bc23660c4830161325a565b610140526101a036829003610203190112610212576103a4611c2c91604051611bea81612ff2565b611bf76102048301613044565b815261022482013560208201526102448201356040820152611c1d36610264840161325a565b60608201526101605201613044565b61010060800152335f52604260205260ff60405f205416600381101561025a57600103612f40576101605151611c6a906001600160401b0316614b00565b611c7c611c75613730565b6080614961565b808015612f39575b15612ef45760016001600160401b0360e06080015151161115612eaf576001600160401b03611cb1614b20565b8160805151511691829116119081612e98575b5015612e53575f54608051515160065491821591908280612e46575b80612e2b575b6001600160401b0382166001600160401b03841611908115612e23575b5015612dde5760c05151612c4a5760a0515160600151612c05575b61010051516129775750505050606060800151158061296c575b15612927575b611d8060805160405190611d5182612fbc565b600a82527f6f7074696d697374696300000000000000000000000000000000000000000000602083015261458b565b610180516080515161016051611da1929091906001600160401b03166142fc565b611ee9575b8080611ec8575b611e4e575b80611dc8575b611dbe57005b610e416080614787565b5060206080015151516001600160401b035f54166001600160401b03821611908115611df5575b50611db8565b61010051511515915081611e41575b81611e21575b5080611e17575b81611def565b5060065415611e11565b90506607ffffffffffff806080515151600d1c1691600d1c161481611e0a565b60c0515115159150611e04565b7f27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df896080516001600160401b03602082015151519182600355515116806001600160401b03196002541617600255611ec060405192839283602090939291936001600160401b0360408201951681520152565b0390a1611db2565b506001600160401b036080515151166001600160401b036002541610611dad565b608051608081516001600160401b038151166008549067ffffffffffffffff60401b602084015160401b16916fffffffffffffffffffffffffffffffff1916171760085560408101516009556060810151600a550151600b556020810151602081518051600c5501518051906001600160401b038211610d1957600160401b8211610d1957600d5482600d558083106128e6575b50602001600d5f525f5b8281106128b2575050506020808201518051600e5501518051906001600160401b038211610d1957600160401b8211610d1957600f5482600f55808310612871575b50602001600f5f525f5b82811061283d57505050604001518051601055602001518051906001600160401b038211610d1957600160401b8211610d1957601154826011558083106127fc575b5060200160115f525f5b8281106127c857505050604001518051601255602001518051906001600160401b038211610d1957600160401b8211610d195760135482601355808310612787575b5060200160135f525f5b82811061275357505050602060800151608081516120a96001600160401b038251166001600160401b03166001600160401b03196014541617601455565b6120e36001600160401b0360208301511667ffffffffffffffff60401b6014549160401b169067ffffffffffffffff60401b191617601455565b604081015160155560608101516016550151601755602081015160208151805160185501518051906001600160401b038211610d1957600160401b8211610d195760195482601955808310612712575b5060200160195f525f5b8281106126de575050506020808201518051601a5501518051906001600160401b038211610d1957600160401b8211610d1957601b5482601b5580831061269d575b50602001601b5f525f5b82811061266957505050604001518051601c55602001518051906001600160401b038211610d1957600160401b8211610d1957601d5482601d55808310612628575b50602001601d5f525f5b8281106125f457505050604001518051601e55602001518051906001600160401b038211610d1957600160401b8211610d1957601f5482601f558083106125b3575b50602001601f5f525f5b82811061257f57505060c051805191506001600160401b038211610d1957600160401b8211610d19576020548260205580831061253e575b5060200160205f525f5b82811061250a57505060e05160215550610100518051906001600160401b038211610d1957600160401b8211610d1957602254826022558083106124c9575b5060200160225f525f5b82811061249557505061012051602355506101405180515f5b600281106124805750506020810151906026915f905b60028210156123195780515f5b6002811061230557505060026020600192019401910190926122db565b6001906020835193019281880155016122e8565b5050905060408101515f5b6002811061246b575050606001515f5b60028110612456575050606060e0608001516001600160401b038151166001600160401b0319602e541617602e556020810151602f556040810151603055015180515f5b600281106124415750506020810151906033915f905b60028210156123cc5780515f5b600281106123b8575050600260206001920194019101909261238e565b60019060208351930192818801550161239b565b5050905060408101515f5b6002811061242c575050606001515f5b600281106124175750506001600160401b0361010060800151166001600160401b0319603b541617603b55611da6565b600190602083519301928160390155016123e7565b600190602083519301928160370155016123d7565b60019060208351930192816031015501612378565b6001906020835193019281602c015501612334565b6001906020835193019281602a015501612324565b600190602083519301928160240155016122c5565b60019060208351930192817f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e5100155016122ac565b7f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908382015b81830181106124ff5750506122a2565b5f81556001016124ef565b60019060208351930192817fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb015501612263565b7fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908382015b8183018110612574575050612259565b5f8155600101612564565b60019060208351930192817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807015501612221565b7fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908382015b81830181106125e9575050612217565b5f81556001016125d9565b60019060208351930192817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f0155016121d5565b7f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908382015b818301811061265e5750506121cb565b5f815560010161264e565b60019060208351930192817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1015501612189565b7f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908382015b81830181106126d357505061217f565b5f81556001016126c3565b60019060208351930192817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c969501550161213d565b7f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908382015b8183018110612748575050612133565b5f8155600101612738565b60019060208351930192817f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a09001550161206b565b7f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908382015b81830181106127bd575050612061565b5f81556001016127ad565b60019060208351930192817f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6801550161201f565b7f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908382015b8183018110612832575050612015565b5f8155600101612822565b60019060208351930192817f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802015501611fd3565b7f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908382015b81830181106128a7575050611fc9565b5f8155600101612897565b60019060208351930192817fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5015501611f87565b7fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908382015b818301811061291c575050611f7d565b5f815560010161290c565b60405162461bcd60e51b815260206004820152601c60248201527f6e6f206e6578742073796e6320636f6d6d69747465652070726f6f66000000006044820152606490fd5b506101205115611d38565b6607ffffffffffff8091600d1c1691600d1c16149081612bfc575b50612ba9575b5060e051610100516080515160600151935f9391929091905b8351851015612a5d5760ff8511611281576001851b15612a49575f6020916001806037891c16148214612a31576129f5612a08916129ef8989614c98565b51614c43565b8360405192828480945193849201614524565b8101039060025afa15612a2657612a205f5194614c8a565b936129b1565b6040513d5f823e3d90fd5b6129f5612a0891612a428989614c98565b5190614c43565b634e487b7160e01b5f52601260045260245ffd5b925092509203612b64576001600160a01b03603e5416602060606080015161018460a0608001519160c06080015194612ab56040519687958694637a53878160e01b86526004860152602485015260448401906135fb565b5afa908115612a26575f91612b35575b50611d3e5760405162461bcd60e51b815260206004820152602a60248201527f626164206e6578742073796e6320636f6d6d697474656520726f6f74206d617060448201527f70696e672070726f6f66000000000000000000000000000000000000000000006064820152608490fd5b612b57915060203d602011612b5d575b612b4f818361300d565b810190614280565b83612ac5565b503d612b45565b60405162461bcd60e51b815260206004820152601d60248201527f626164206e6578742073796e6320636f6d6d69747465652070726f6f660000006044820152606490fd5b60e05103612bb75782612998565b60405162461bcd60e51b815260206004820152601760248201527f626164206e6578742073796e6320636f6d6d69747465650000000000000000006044820152606490fd5b90501584612992565b60405162461bcd60e51b815260206004820152600c60248201527f6e6f2066696e2070726f6f6600000000000000000000000000000000000000006044820152606490fd5b60a0515180516001600160401b0316612cb0575060a051516060015115611d1e5760405162461bcd60e51b815260206004820152601e60248201527f67656e65736973206865616465722073686f756c6420626520656d70747900006044820152606490fd5b612cc1909693969592949195614cac565b9560406080015194606060805151015197965f975b8751891015612d435760ff8911611281576001891b15612a49575f60209160018060698d1c16148214612d32576129f5612d14916129ef8d8d614c98565b8101039060025afa15612a2657612d2c5f5198614c8a565b97612cd6565b6129f5612d1491612a428d8d614c98565b9295989194975092955003612d995760a051604051612d9491612d6582612fbc565b600982527f66696e616c697a65640000000000000000000000000000000000000000000000602083015261458b565b611d1e565b60405162461bcd60e51b815260206004820152600d60248201527f6261642066696e2070726f6f66000000000000000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601960248201527f6261642061747420736c6f74206f7220636f6d6d6974746565000000000000006044820152606490fd5b905087611d03565b506607ffffffffffff8082600d1c169083600d1c1614611ce6565b5061010051511515611ce0565b60405162461bcd60e51b815260206004820152600860248201527f62616420736c6f740000000000000000000000000000000000000000000000006044820152606490fd5b60a05151516001600160401b031610905083611cc4565b60405162461bcd60e51b815260206004820152601860248201527f6e6f7420656e6f7567682070617274696369706174696f6e00000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f71756f72756d206e6f74207265616368656400000000000000000000000000006044820152606490fd5b5081611c84565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b61012081019081106001600160401b03821117610d1957604052565b60a081019081106001600160401b03821117610d1957604052565b604081019081106001600160401b03821117610d1957604052565b606081019081106001600160401b03821117610d1957604052565b608081019081106001600160401b03821117610d1957604052565b90601f801991011681019081106001600160401b03821117610d1957604052565b600435906001600160401b038216820361021257565b35906001600160401b038216820361021257565b6001600160401b038111610d195760051b60200190565b81601f820112156102125780359161308683613058565b92613094604051948561300d565b808452602092838086019260051b820101928311610212578301905b8282106130be575050505090565b813581529083019083016130b0565b919060408382031261021257604051906130e682612fbc565b8193803583526020810135916001600160401b0383116102125760209261310d920161306f565b910152565b91908281039260e084126102125760409081519261312f84612fd7565b60a084961261021257825161314381612fa1565b61314c83613044565b815261315a60208401613044565b602082015283830135848201526060830135606082015260808301356080820152845260a08201356001600160401b0390818111610212578301606081840312610212578451906131aa82612fd7565b803583811161021257846131bf9183016130cd565b8252602081013583811161021257846131d99183016130cd565b60208301528581013590838211610212576131f6918591016130cd565b85820152602086015260c08301359081116102125761310d92016130cd565b9080601f83011215610212576040519161322e83612fbc565b82906040810192831161021257905b82821061324a5750505090565b813581526020918201910161323d565b919091610140818403126102125760409283519161327783612ff2565b82946132838383613215565b845282605f8301121561021257805161329b81612fbc565b8060c084019185831161021257838501905b8382106132db5750509284926132d16060966101009461310d9760208b0152613215565b9087015201613215565b602085916132e98985613215565b8152019101906132ad565b6041548110156133295760415f527f7c9785e8241615bc80415d89775984a1337d15dc1bf4ce50f41988b2a2b336a701905f90565b634e487b7160e01b5f52603260045260245ffd5b6043548110156133295760435f527f9690ad99d6ce244efa8a0f6c2d04036d3b33a9474db32a71b71135c69510279301905f90565b600435906001600160a01b038216820361021257565b60208060031983011261021257600435916001600160401b03831161021257806023840112156102125782600401356133c081613058565b936133ce604051958661300d565b81855260248486019260051b82010192831161021257602401905b8282106133f7575050505090565b81356001600160a01b03811681036102125781529083019083016133e9565b6040519060315f835b600282106134355750505061343382612fbc565b565b600160208192855481520193019101909161341f565b6040519060375f835b600282106134685750505061343382612fbc565b6001602081928554815201930191019091613454565b6040519060395f835b6002821061349b5750505061343382612fbc565b6001602081928554815201930191019091613487565b60405191905f835b600282106134cd5750505061343382612fbc565b60016020819285548152019301910190916134b9565b6060906040830190805184526020928380920151946040838201528551809452019301915f5b828110613517575050505090565b835185529381019392810192600101613509565b6135d191608082516001600160401b03808251168452602082015116602084015260408101516040840152606081015160608401520151608082015260406135c0602084015160e060a085015261358f8151606060e08701526101408601906134e3565b836135ad60208401519260df199384898303016101008a01526134e3565b92015190858303016101208601526134e3565b9201519060c08184039101526134e3565b90565b5f915b600283106135e457505050565b6001908251815260208091019201920191906135d7565b91906136088184516135d4565b60208381015193906040905f908483015b6002831061364b575050506134339394508161364160609261010094015160c08601906135d4565b01519101906135d4565b81848261365b6001948c516135d4565b01980192019196613619565b90603d5482101561332957603d5f52601c8260031c7fece66cfdbd22e3f37d348a3d8e19074452862cd65fd4b9a11f0336d1ac6d1dc3019260021b1690565b90603c5482101561332957603c5f5260188260021c7fc6bb06cb7f92603de181bf256cd16846b93b752a170ff24824098b31aa008a7e019260031b1690565b156136ec57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b6040805161373d81612f85565b809282519261374b84612fd7565b80519261375784612fa1565b600854916001600160401b03808416865280602094831c168487015260095482870152600a549560609687820152600b546080820152875281519661379b88612fd7565b8251976137a789612fbc565b600c5489528351988987600d549b8c8152015f9b600d8d527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908d5b818110613e1057505050816137f991038261300d565b878201528152835161380a81612fbc565b600e54815284518088600f54918281520190600f8d527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908d5b818110613dfc575050508161385a91038261300d565b8782015286820152835161386d81612fbc565b60105481528451808860115491828152019060118d527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908d5b818110613de857505050816138bd91038261300d565b87820152848201528582015282516138d481612fbc565b60125481528351808760135491828152019060138c527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908c5b818110613dd4575050508161392491038261300d565b86820152838201528352815161393981612fd7565b825161394481612fa1565b826014548181168352851c1686820152601554848201526016548882015260175460808201528152825161397781612fd7565b835161398281612fbc565b60185481528451808860195491828152019060198d527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908d5b818110613dc057505050816139d291038261300d565b87820152815283516139e381612fbc565b601a54815284518088601b54918281520190601b8d527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908d5b818110613dac5750505081613a3391038261300d565b87820152868201528351613a4681612fbc565b601c54815284518088601d54918281520190601d8d527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908d5b818110613d985750505081613a9691038261300d565b8782015284820152858201528251613aad81612fbc565b601e54815283518087601f54918281520190601f8c527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908c5b818110613d845750505081613afd91038261300d565b81870152818401528385015281518454808252858952818601907fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908a5b818110613d705750505081613b5191038261300d565b82840152602154868401528151808560225491828152019060228a527f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908a5b818110613d5c5750505081613ba791038261300d565b608084015260235460a0840152815196613bc088612ff2565b8251602482825b60028210613d4657505050613bdb81612fbc565b8852825196613be988612fbc565b879660269583985b600290818b1015613c18579089600192613c0a8b6134b1565b815201980199019896613bf1565b50509398919750939891945085820152875180602a9086905b60028210613d3057505050613c4581612fbc565b818901528751602c85825b60028210613d1a57505050613c6481612fbc565b8682015260c0820152865195613c7987612ff2565b80602e54168752602f548588015260305488880152875196613c9a88612ff2565b613ca2613416565b8852885197613cb089612fbc565b8897603396985b600290818b1015613cde579089600192613cd08b6134b1565b815201980199019896613cb7565b50509398919550939891956101009750840152613cf961344b565b90830152613d0561347e565b8183015282015260e0840152603b5416910152565b8254815260019283019291909101908801613c50565b8254815260019283019291909101908801613c31565b8254815260019283019291909101908801613bc7565b825484529288019260019283019201613b91565b825484529288019260019283019201613b3b565b82548452928a019260019283019201613ae7565b82548452928b019260019283019201613a80565b82548452928b019260019283019201613a1d565b82548452928b0192600192830192016139bc565b82548452928a01926001928301920161390e565b82548452928b0192600192830192016138a7565b82548452928b019260019283019201613844565b82548452928b0192600192830192016137e3565b818110613e2f575050565b5f8155600101613e24565b5f806008558060095580600a5580600b5580600c55600d5481600d558061423e575b5080600e55600f5481600f55806141fc575b508060105560115481601155806141ba575b50806012556013548160135580614178575b5080601455806015558060165580601755806018556019548160195580614136575b5080601a55601b5481601b55806140f4575b5080601c55601d5481601d55806140b2575b5080601e55601f5481601f5580614070575b50602054816020558061402e575b50806021556022548160225580613fec575b508060235560245b60268110613fe1575060265b602a8110613fcc5750602a5b602c8110613fc15750602c5b602e8110613fb6575080602e5580602f558060305560315b60338110613fab575060335b60378110613f96575060375b60398110613f8b575060395b603b8110613f805750603b55565b818155600101613f72565b818155600101613f66565b80613fa5600280930182613e24565b01613f5a565b818155600101613f4e565b818155600101613f36565b818155600101613f2a565b80613fdb600280930182613e24565b01613f1e565b818155600101613f12565b602282527f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908101905b8181106140235750613f0a565b828155600101614016565b602082527fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908101905b8181106140655750613ef8565b828155600101614058565b601f82527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908101905b8181106140a75750613eea565b82815560010161409a565b601d82527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908101905b8181106140e95750613ed8565b8281556001016140dc565b601b82527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908101905b81811061412b5750613ec6565b82815560010161411e565b601982527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908101905b81811061416d5750613eb4565b828155600101614160565b601382527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908101905b8181106141af5750613e92565b8281556001016141a2565b601182527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908101905b8181106141f15750613e80565b8281556001016141e4565b600f82527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908101905b8181106142335750613e6e565b828155600101614226565b600d82527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908101905b8181106142755750613e5c565b828155600101614268565b90816020910312610212575180151581036102125790565b9060016001600160401b038093160191821161128157565b156142b757565b60405162461bcd60e51b815260206004820152601160248201527f62616420706f736569646f6e20726f6f740000000000000000000000000000006044820152606490fd5b6607ffffffffffff805f54600d1c169082600d1c169160065415155f146144bd5781831480156144a3575b1561445e5760209361435161434c6707ffffffffffffff614357945b60051c16614b5a565b614bcb565b90614c60565b9103614444576101c46005546143718486015182146142b0565b915b6001600160a01b03603e54166143c96001600160401b038751169660606040820151910151906040519889978896630291ab6d60e51b8852600488015260248701526044860152606485015260848401906135fb565b5afa908115612a26575f91614426575b50156143e157565b60405162461bcd60e51b815260206004820152601160248201527f62616420626c73207369672070726f6f660000000000000000000000000000006044820152606490fd5b61443e915060203d8111612b5d57612b4f818361300d565b5f6143d9565b6101c46007546144588486015182146142b0565b91614373565b60405162461bcd60e51b815260206004820152601060248201527f6261642073696720706572696f642032000000000000000000000000000000006044820152606490fd5b506001600160401b036144b583614298565b168314614327565b8183036144df5760209361435161434c6707ffffffffffffff61435794614343565b60405162461bcd60e51b815260206004820152601060248201527f6261642073696720706572696f642031000000000000000000000000000000006044820152606490fd5b5f5b8381106145355750505f910152565b8181015183820152602001614526565b1561454d5750565b6044604051809262461bcd60e51b82526020600483015261457d8151809281602486015260208686019101614524565b601f01601f19168101030190fd5b9190916020908181015192604094858301608081519451015185855195015194935f945b86518610156146355760ff861161128157600180871b15612a495788915f916019891c811603614624576145ea6145fc916129ef8a8c614c98565b838d5192828480945193849201614524565b8101039060025afa1561461a576146145f5195614c8a565b946145af565b88513d5f823e3d90fd5b6145ea6145fc91612a428a8c614c98565b9093979295506146999194508851907f626164206578656320726f6f742070726f6f6620000000000000000000000000888301528851956146936034848b8d0199614683818484018d614524565b810103601481018652018461300d565b14614545565b5192515184845194015193925f935b855185101561472e5760ff851161128157600180861b15612a495787915f916012881c81160361471d576146e36146f5916129ef898b614c98565b838c5192828480945193849201614524565b8101039060025afa156147135761470d5f5194614c8a565b936146a8565b87513d5f823e3d90fd5b6146e36146f591612a42898b614c98565b9450603a919350947f626164206578656320737461746520726f6f742070726f6f66200000000000009561477761343398614693959a5198899485015251809285850190614524565b810103601a81018652018461300d565b602081019081515151906001600160401b0392838316926607ffffffffffff805f54600d1c1691600d1c16906006548681155f146148ee57505081036148a957827fdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c79161483161480a60a060606020980151948560065501519283600755614298565b91604051938493846040919493926001600160401b03606083019616825260208201520152565b0390a15b5101515151905f54928316811161484b57505050565b807f4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c24893836001556001600160401b031916175f556148a460405192839283602090939291936001600160401b0360408201951681520152565b0390a1565b60405162461bcd60e51b815260206004820152600f60248201527f6d69736d6174636820706572696f6400000000000000000000000000000000006044820152606490fd5b6148fd60209693949294614298565b16811461490d575b505050614835565b7fdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c79260045560075460055561495661480a60a06060850151948560065501519283600755614298565b0390a15f8080614905565b60e08201906001600160401b0391828151511615614abc5760e0820161498a8482515116614b00565b6149978584515116614b00565b15908015918015831503614aa657505080614a94575b614a83576149ba83614aca565b6149c386614aca565b151581151503614a7a5750604083015151151560408601515115158103614a7a578490614a35575b80915151169151511690818103614a2d57505081815151511682845151511690818103614a25575050816101008092015116920151161190565b109392505050565b119392505050565b50602083015151516607ffffffffffff90818086515151600d1c1691600d1c1614908060208801515151600d1c169087515151600d1c16148103614a7a5750836149eb565b94505050505090565b909350829150515116915151161090565b508381515116848351511614156149ad565b955095505050505081614ab7575090565b905090565b5060e0015151161515919050565b60808101515115159081614adc575090565b905061010081515151916607ffffffffffff9182910151600d1c1691600d1c161490565b60036001600160401b038092160290811690810361128157610400111590565b7f0000000000000000000000000000000000000000000000000000000000000000420342811161128157600c6001600160401b0391041690565b603d545f199290838101908111611281575b614b75816136a6565b906001600160401b03809154600393841b1c169085161015614bb357508015614b9f578301614b6c565b60245f634e487b7160e01b81526011600452fd5b9250614bc0919350613667565b9054911b1c60e01b90565b5f614c286020926040518481019163ffffffff60e01b1682527f0000000000000000000000000000000000000000000000000000000000000000604082015260408152614c1781612fd7565b604051928392839251928391614524565b8101039060025afa15612a26575f5160201c600760f81b1790565b919060405192602084015260408301526040825261343382612fd7565b614c786129f5602093614c735f94614cac565b614c43565b8101039060025afa15612a26575f5190565b5f1981146112815760010190565b80518210156133295760209160051b010190565b6001600160401b0390614cda614cc483835116614e5a565b614cd46020948585015116614e5a565b90614c43565b9180604092614cf184519586815194859201614524565b825f86819760029581010390855afa15614e435784518386614d30614d1e88860151606087015190614c43565b83895192828480945193849201614524565b81010390865afa15614e505785614d5f614d4d8693835190614c43565b83885192828480945193849201614524565b81010390855afa15614e43578285614da06080825194015187518481019182528389820152888152614d9081612fd7565b8851928392839251928391614524565b81010390855afa15614e435784518386614ddd875183810190838252838a820152898152614dcd81612fd7565b8951928392839251928391614524565b81010390865afa15614e505785614dfa614d4d8693835190614c43565b81010390855afa15614e435790614e29614e178693845190614c43565b84865192828480945193849201614524565b810103915afa15614e3957505190565b51903d90823e3d90fd5b50505051903d90823e3d90fd5b84513d87823e3d90fd5b5f9081905b60208210614e6c57505090565b600892831b60ff821617921c90614e8290614c8a565b90614e5f565b15614e8f57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f9280845260429060209180835260409060ff82882054166003908181101561509e571561505a576043805490915f1991828101908111615046578a5b845481101561500257878b614f318361333d565b905490861b1c1614614f4b57614f4690614c8a565b614f1d565b919293949596979899818310614fdd575b5050505081548015614fc957918493917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859899930190614fb3614f9e8361333d565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b89526031600452602489fd5b614ff993614fed6116179361333d565b9054911b1c169161333d565b5f808080614f5c565b865162461bcd60e51b8152600481018a9052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b8b52601160045260248bfd5b825162461bcd60e51b815260048101869052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b89526021600452602489fd5b6001600160a01b038116905f8281526040918260205260ff838320541661514a57604154600160401b81101561513657927f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8949261511d8293611617876001602099016041556132f4565b83815281855220805460ff1916600117905551908152a1565b634e487b7160e01b83526041600452602483fd5b825162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116915f9280845260409060209180835260ff8187205416156152f457604180545f1980820197909188116152e057885b835481101561529c5781866151dc836132f4565b929054600393841b1c16146151fa57506151f590614c8a565b6151c8565b929394959697989091818310615277575b505050508154801561526357917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9697918493019061524c614f9e836132f4565b5583815281855220805460ff1916905551908152a1565b634e487b7160e01b88526031600452602488fd5b61529393615287611617936132f4565b9054911b1c16916132f4565b5f80808061520b565b845162461bcd60e51b815260048101889052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b89526011600452602489fd5b5162461bcd60e51b815260048101839052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea26469706673582212205280d435b3ca6448caadc06ee9fd1526f38f062c76607503918dab930ca8675864736f6c63430008140033",
}

// EthereumLightClientABI is the input ABI used to generate the binding from.
// Deprecated: Use EthereumLightClientMetaData.ABI instead.
var EthereumLightClientABI = EthereumLightClientMetaData.ABI

// EthereumLightClientBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EthereumLightClientMetaData.Bin instead.
var EthereumLightClientBin = EthereumLightClientMetaData.Bin

// DeployEthereumLightClient deploys a new Ethereum contract, binding an instance of EthereumLightClient to it.
func DeployEthereumLightClient(auth *bind.TransactOpts, backend bind.ContractBackend, genesisTime *big.Int, genesisValidatorsRoot [32]byte, _forkEpochs []uint64, _forkVersions [][4]byte, _finalizedSlot uint64, syncCommitteeRoot [32]byte, syncCommitteePoseidonRoot [32]byte, _zkVerifier common.Address) (common.Address, *types.Transaction, *EthereumLightClient, error) {
	parsed, err := EthereumLightClientMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EthereumLightClientBin), backend, genesisTime, genesisValidatorsRoot, _forkEpochs, _forkVersions, _finalizedSlot, syncCommitteeRoot, syncCommitteePoseidonRoot, _zkVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &EthereumLightClient{EthereumLightClientCaller: EthereumLightClientCaller{contract: contract}, EthereumLightClientTransactor: EthereumLightClientTransactor{contract: contract}, EthereumLightClientFilterer: EthereumLightClientFilterer{contract: contract}}, nil
}

// EthereumLightClient is an auto generated Go binding around an Ethereum contract.
type EthereumLightClient struct {
	EthereumLightClientCaller     // Read-only binding to the contract
	EthereumLightClientTransactor // Write-only binding to the contract
	EthereumLightClientFilterer   // Log filterer for contract events
}

// EthereumLightClientCaller is an auto generated read-only Go binding around an Ethereum contract.
type EthereumLightClientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EthereumLightClientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EthereumLightClientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EthereumLightClientSession struct {
	Contract     *EthereumLightClient // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// EthereumLightClientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EthereumLightClientCallerSession struct {
	Contract *EthereumLightClientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// EthereumLightClientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EthereumLightClientTransactorSession struct {
	Contract     *EthereumLightClientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// EthereumLightClientRaw is an auto generated low-level Go binding around an Ethereum contract.
type EthereumLightClientRaw struct {
	Contract *EthereumLightClient // Generic contract binding to access the raw methods on
}

// EthereumLightClientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EthereumLightClientCallerRaw struct {
	Contract *EthereumLightClientCaller // Generic read-only contract binding to access the raw methods on
}

// EthereumLightClientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EthereumLightClientTransactorRaw struct {
	Contract *EthereumLightClientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEthereumLightClient creates a new instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClient(address common.Address, backend bind.ContractBackend) (*EthereumLightClient, error) {
	contract, err := bindEthereumLightClient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClient{EthereumLightClientCaller: EthereumLightClientCaller{contract: contract}, EthereumLightClientTransactor: EthereumLightClientTransactor{contract: contract}, EthereumLightClientFilterer: EthereumLightClientFilterer{contract: contract}}, nil
}

// NewEthereumLightClientCaller creates a new read-only instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientCaller(address common.Address, caller bind.ContractCaller) (*EthereumLightClientCaller, error) {
	contract, err := bindEthereumLightClient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientCaller{contract: contract}, nil
}

// NewEthereumLightClientTransactor creates a new write-only instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientTransactor(address common.Address, transactor bind.ContractTransactor) (*EthereumLightClientTransactor, error) {
	contract, err := bindEthereumLightClient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientTransactor{contract: contract}, nil
}

// NewEthereumLightClientFilterer creates a new log filterer instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientFilterer(address common.Address, filterer bind.ContractFilterer) (*EthereumLightClientFilterer, error) {
	contract, err := bindEthereumLightClient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientFilterer{contract: contract}, nil
}

// bindEthereumLightClient binds a generic wrapper to an already deployed contract.
func bindEthereumLightClient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EthereumLightClientMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EthereumLightClient *EthereumLightClientRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EthereumLightClient.Contract.EthereumLightClientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EthereumLightClient *EthereumLightClientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.EthereumLightClientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EthereumLightClient *EthereumLightClientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.EthereumLightClientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EthereumLightClient *EthereumLightClientCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EthereumLightClient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EthereumLightClient *EthereumLightClientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EthereumLightClient *EthereumLightClientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.contract.Transact(opts, method, params...)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientCaller) BestValidUpdate(opts *bind.CallOpts) (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "bestValidUpdate")

	outstruct := new(struct {
		AttestedHeader                    HeaderWithExecution
		FinalizedHeader                   HeaderWithExecution
		NextSyncCommitteeRoot             [32]byte
		NextSyncCommitteePoseidonRoot     [32]byte
		NextSyncCommitteeRootMappingProof IBeaconVerifierProof
		SyncAggregate                     SyncAggregate
		SignatureSlot                     uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.AttestedHeader = *abi.ConvertType(out[0], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.FinalizedHeader = *abi.ConvertType(out[1], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.NextSyncCommitteeRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteePoseidonRoot = *abi.ConvertType(out[3], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteeRootMappingProof = *abi.ConvertType(out[4], new(IBeaconVerifierProof)).(*IBeaconVerifierProof)
	outstruct.SyncAggregate = *abi.ConvertType(out[5], new(SyncAggregate)).(*SyncAggregate)
	outstruct.SignatureSlot = *abi.ConvertType(out[6], new(uint64)).(*uint64)

	return *outstruct, err

}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _EthereumLightClient.Contract.BestValidUpdate(&_EthereumLightClient.CallOpts)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientCallerSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _EthereumLightClient.Contract.BestValidUpdate(&_EthereumLightClient.CallOpts)
}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) ComputeDomain(opts *bind.CallOpts, forkVersion [4]byte) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "computeDomain", forkVersion)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) ComputeDomain(forkVersion [4]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeDomain(&_EthereumLightClient.CallOpts, forkVersion)
}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) ComputeDomain(forkVersion [4]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeDomain(&_EthereumLightClient.CallOpts, forkVersion)
}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) ComputeSigningRoot(opts *bind.CallOpts, header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "computeSigningRoot", header, domain)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) ComputeSigningRoot(header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeSigningRoot(&_EthereumLightClient.CallOpts, header, domain)
}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) ComputeSigningRoot(header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeSigningRoot(&_EthereumLightClient.CallOpts, header, domain)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) CurrentSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "currentSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) CurrentSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "currentSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedSlot() (uint64, error) {
	return _EthereumLightClient.Contract.FinalizedSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedSlot() (uint64, error) {
	return _EthereumLightClient.Contract.FinalizedSlot(&_EthereumLightClient.CallOpts)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) ForkEpochs(opts *bind.CallOpts, arg0 *big.Int) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "forkEpochs", arg0)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _EthereumLightClient.Contract.ForkEpochs(&_EthereumLightClient.CallOpts, arg0)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _EthereumLightClient.Contract.ForkEpochs(&_EthereumLightClient.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientCaller) ForkVersions(opts *bind.CallOpts, arg0 *big.Int) ([4]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "forkVersions", arg0)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _EthereumLightClient.Contract.ForkVersions(&_EthereumLightClient.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientCallerSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _EthereumLightClient.Contract.ForkVersions(&_EthereumLightClient.CallOpts, arg0)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) IsPauser(account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsPauser(&_EthereumLightClient.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) IsPauser(account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsPauser(&_EthereumLightClient.CallOpts, account)
}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientCaller) LatestFinalizedSlotAndCommitteeRoots(opts *bind.CallOpts) (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "latestFinalizedSlotAndCommitteeRoots")

	outstruct := new(struct {
		Slot        uint64
		CurrentRoot [32]byte
		NextRoot    [32]byte
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Slot = *abi.ConvertType(out[0], new(uint64)).(*uint64)
	outstruct.CurrentRoot = *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)
	outstruct.NextRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)

	return *outstruct, err

}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientSession) LatestFinalizedSlotAndCommitteeRoots() (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	return _EthereumLightClient.Contract.LatestFinalizedSlotAndCommitteeRoots(&_EthereumLightClient.CallOpts)
}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientCallerSession) LatestFinalizedSlotAndCommitteeRoots() (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	return _EthereumLightClient.Contract.LatestFinalizedSlotAndCommitteeRoots(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) NextSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "nextSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) NextSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "nextSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientSession) NumPausers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumPausers(&_EthereumLightClient.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCallerSession) NumPausers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumPausers(&_EthereumLightClient.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientSession) NumProvers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumProvers(&_EthereumLightClient.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCallerSession) NumProvers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumProvers(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticSlot() (uint64, error) {
	return _EthereumLightClient.Contract.OptimisticSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticSlot() (uint64, error) {
	return _EthereumLightClient.Contract.OptimisticSlot(&_EthereumLightClient.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) Owner() (common.Address, error) {
	return _EthereumLightClient.Contract.Owner(&_EthereumLightClient.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) Owner() (common.Address, error) {
	return _EthereumLightClient.Contract.Owner(&_EthereumLightClient.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) Paused() (bool, error) {
	return _EthereumLightClient.Contract.Paused(&_EthereumLightClient.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) Paused() (bool, error) {
	return _EthereumLightClient.Contract.Paused(&_EthereumLightClient.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.PauserList(&_EthereumLightClient.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.PauserList(&_EthereumLightClient.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) Pausers(arg0 common.Address) (bool, error) {
	return _EthereumLightClient.Contract.Pausers(&_EthereumLightClient.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _EthereumLightClient.Contract.Pausers(&_EthereumLightClient.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _EthereumLightClient.Contract.ProverStates(&_EthereumLightClient.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _EthereumLightClient.Contract.ProverStates(&_EthereumLightClient.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.Provers(&_EthereumLightClient.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.Provers(&_EthereumLightClient.CallOpts, arg0)
}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientCaller) VerifyCommitteeSignature(opts *bind.CallOpts, signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "verifyCommitteeSignature", signatureSlot, header, syncAggregate)

	if err != nil {
		return err
	}

	return err

}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientSession) VerifyCommitteeSignature(signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	return _EthereumLightClient.Contract.VerifyCommitteeSignature(&_EthereumLightClient.CallOpts, signatureSlot, header, syncAggregate)
}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientCallerSession) VerifyCommitteeSignature(signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	return _EthereumLightClient.Contract.VerifyCommitteeSignature(&_EthereumLightClient.CallOpts, signatureSlot, header, syncAggregate)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) ZkVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "zkVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) ZkVerifier() (common.Address, error) {
	return _EthereumLightClient.Contract.ZkVerifier(&_EthereumLightClient.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) ZkVerifier() (common.Address, error) {
	return _EthereumLightClient.Contract.ZkVerifier(&_EthereumLightClient.CallOpts)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPauser(&_EthereumLightClient.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPauser(&_EthereumLightClient.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPausers(&_EthereumLightClient.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPausers(&_EthereumLightClient.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientSession) Pause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Pause(&_EthereumLightClient.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) Pause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Pause(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) ProcessLightClientForceUpdate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "processLightClientForceUpdate")
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientSession) ProcessLightClientForceUpdate() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientForceUpdate(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) ProcessLightClientForceUpdate() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientForceUpdate(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) ProcessLightClientUpdate(opts *bind.TransactOpts, update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "processLightClientUpdate", update)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientSession) ProcessLightClientUpdate(update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientUpdate(&_EthereumLightClient.TransactOpts, update)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) ProcessLightClientUpdate(update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientUpdate(&_EthereumLightClient.TransactOpts, update)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePauser(&_EthereumLightClient.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePauser(&_EthereumLightClient.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePausers(&_EthereumLightClient.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePausers(&_EthereumLightClient.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemoveProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemoveProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientSession) RenouncePauser() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RenouncePauser(&_EthereumLightClient.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RenouncePauser(&_EthereumLightClient.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.TransferOwnership(&_EthereumLightClient.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.TransferOwnership(&_EthereumLightClient.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientSession) Unpause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Unpause(&_EthereumLightClient.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) Unpause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Unpause(&_EthereumLightClient.TransactOpts)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) UpdateForkVersion(opts *bind.TransactOpts, epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "updateForkVersion", epoch, forkVersion)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientSession) UpdateForkVersion(epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.UpdateForkVersion(&_EthereumLightClient.TransactOpts, epoch, forkVersion)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) UpdateForkVersion(epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.UpdateForkVersion(&_EthereumLightClient.TransactOpts, epoch, forkVersion)
}

// EthereumLightClientFinalityUpdateIterator is returned from FilterFinalityUpdate and is used to iterate over the raw logs and unpacked data for FinalityUpdate events raised by the EthereumLightClient contract.
type EthereumLightClientFinalityUpdateIterator struct {
	Event *EthereumLightClientFinalityUpdate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientFinalityUpdateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientFinalityUpdate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientFinalityUpdate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientFinalityUpdateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientFinalityUpdateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientFinalityUpdate represents a FinalityUpdate event raised by the EthereumLightClient contract.
type EthereumLightClientFinalityUpdate struct {
	Slot               *big.Int
	ExecutionStateRoot [32]byte
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterFinalityUpdate is a free log retrieval operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterFinalityUpdate(opts *bind.FilterOpts) (*EthereumLightClientFinalityUpdateIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "FinalityUpdate")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientFinalityUpdateIterator{contract: _EthereumLightClient.contract, event: "FinalityUpdate", logs: logs, sub: sub}, nil
}

// WatchFinalityUpdate is a free log subscription operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchFinalityUpdate(opts *bind.WatchOpts, sink chan<- *EthereumLightClientFinalityUpdate) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "FinalityUpdate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientFinalityUpdate)
				if err := _EthereumLightClient.contract.UnpackLog(event, "FinalityUpdate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFinalityUpdate is a log parse operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseFinalityUpdate(log types.Log) (*EthereumLightClientFinalityUpdate, error) {
	event := new(EthereumLightClientFinalityUpdate)
	if err := _EthereumLightClient.contract.UnpackLog(event, "FinalityUpdate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientForkVersionUpdatedIterator is returned from FilterForkVersionUpdated and is used to iterate over the raw logs and unpacked data for ForkVersionUpdated events raised by the EthereumLightClient contract.
type EthereumLightClientForkVersionUpdatedIterator struct {
	Event *EthereumLightClientForkVersionUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientForkVersionUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientForkVersionUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientForkVersionUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientForkVersionUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientForkVersionUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientForkVersionUpdated represents a ForkVersionUpdated event raised by the EthereumLightClient contract.
type EthereumLightClientForkVersionUpdated struct {
	Epoch       uint64
	ForkVersion [4]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterForkVersionUpdated is a free log retrieval operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterForkVersionUpdated(opts *bind.FilterOpts) (*EthereumLightClientForkVersionUpdatedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ForkVersionUpdated")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientForkVersionUpdatedIterator{contract: _EthereumLightClient.contract, event: "ForkVersionUpdated", logs: logs, sub: sub}, nil
}

// WatchForkVersionUpdated is a free log subscription operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchForkVersionUpdated(opts *bind.WatchOpts, sink chan<- *EthereumLightClientForkVersionUpdated) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ForkVersionUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientForkVersionUpdated)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ForkVersionUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseForkVersionUpdated is a log parse operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseForkVersionUpdated(log types.Log) (*EthereumLightClientForkVersionUpdated, error) {
	event := new(EthereumLightClientForkVersionUpdated)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ForkVersionUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientOptimisticUpdateIterator is returned from FilterOptimisticUpdate and is used to iterate over the raw logs and unpacked data for OptimisticUpdate events raised by the EthereumLightClient contract.
type EthereumLightClientOptimisticUpdateIterator struct {
	Event *EthereumLightClientOptimisticUpdate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientOptimisticUpdateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientOptimisticUpdate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientOptimisticUpdate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientOptimisticUpdateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientOptimisticUpdateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientOptimisticUpdate represents a OptimisticUpdate event raised by the EthereumLightClient contract.
type EthereumLightClientOptimisticUpdate struct {
	Slot               *big.Int
	ExecutionStateRoot [32]byte
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterOptimisticUpdate is a free log retrieval operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterOptimisticUpdate(opts *bind.FilterOpts) (*EthereumLightClientOptimisticUpdateIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "OptimisticUpdate")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientOptimisticUpdateIterator{contract: _EthereumLightClient.contract, event: "OptimisticUpdate", logs: logs, sub: sub}, nil
}

// WatchOptimisticUpdate is a free log subscription operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchOptimisticUpdate(opts *bind.WatchOpts, sink chan<- *EthereumLightClientOptimisticUpdate) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "OptimisticUpdate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientOptimisticUpdate)
				if err := _EthereumLightClient.contract.UnpackLog(event, "OptimisticUpdate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOptimisticUpdate is a log parse operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseOptimisticUpdate(log types.Log) (*EthereumLightClientOptimisticUpdate, error) {
	event := new(EthereumLightClientOptimisticUpdate)
	if err := _EthereumLightClient.contract.UnpackLog(event, "OptimisticUpdate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the EthereumLightClient contract.
type EthereumLightClientOwnershipTransferredIterator struct {
	Event *EthereumLightClientOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientOwnershipTransferred represents a OwnershipTransferred event raised by the EthereumLightClient contract.
type EthereumLightClientOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*EthereumLightClientOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientOwnershipTransferredIterator{contract: _EthereumLightClient.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *EthereumLightClientOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientOwnershipTransferred)
				if err := _EthereumLightClient.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseOwnershipTransferred(log types.Log) (*EthereumLightClientOwnershipTransferred, error) {
	event := new(EthereumLightClientOwnershipTransferred)
	if err := _EthereumLightClient.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the EthereumLightClient contract.
type EthereumLightClientPausedIterator struct {
	Event *EthereumLightClientPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPaused represents a Paused event raised by the EthereumLightClient contract.
type EthereumLightClientPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPaused(opts *bind.FilterOpts) (*EthereumLightClientPausedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPausedIterator{contract: _EthereumLightClient.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPaused) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPaused)
				if err := _EthereumLightClient.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePaused(log types.Log) (*EthereumLightClientPaused, error) {
	event := new(EthereumLightClientPaused)
	if err := _EthereumLightClient.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the EthereumLightClient contract.
type EthereumLightClientPauserAddedIterator struct {
	Event *EthereumLightClientPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPauserAdded represents a PauserAdded event raised by the EthereumLightClient contract.
type EthereumLightClientPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*EthereumLightClientPauserAddedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPauserAddedIterator{contract: _EthereumLightClient.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPauserAdded) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPauserAdded)
				if err := _EthereumLightClient.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePauserAdded(log types.Log) (*EthereumLightClientPauserAdded, error) {
	event := new(EthereumLightClientPauserAdded)
	if err := _EthereumLightClient.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the EthereumLightClient contract.
type EthereumLightClientPauserRemovedIterator struct {
	Event *EthereumLightClientPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPauserRemoved represents a PauserRemoved event raised by the EthereumLightClient contract.
type EthereumLightClientPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*EthereumLightClientPauserRemovedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPauserRemovedIterator{contract: _EthereumLightClient.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPauserRemoved)
				if err := _EthereumLightClient.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePauserRemoved(log types.Log) (*EthereumLightClientPauserRemoved, error) {
	event := new(EthereumLightClientPauserRemoved)
	if err := _EthereumLightClient.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the EthereumLightClient contract.
type EthereumLightClientProverAddedIterator struct {
	Event *EthereumLightClientProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientProverAdded represents a ProverAdded event raised by the EthereumLightClient contract.
type EthereumLightClientProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterProverAdded(opts *bind.FilterOpts) (*EthereumLightClientProverAddedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientProverAddedIterator{contract: _EthereumLightClient.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *EthereumLightClientProverAdded) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientProverAdded)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseProverAdded(log types.Log) (*EthereumLightClientProverAdded, error) {
	event := new(EthereumLightClientProverAdded)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the EthereumLightClient contract.
type EthereumLightClientProverRemovedIterator struct {
	Event *EthereumLightClientProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientProverRemoved represents a ProverRemoved event raised by the EthereumLightClient contract.
type EthereumLightClientProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*EthereumLightClientProverRemovedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientProverRemovedIterator{contract: _EthereumLightClient.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *EthereumLightClientProverRemoved) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientProverRemoved)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseProverRemoved(log types.Log) (*EthereumLightClientProverRemoved, error) {
	event := new(EthereumLightClientProverRemoved)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientSyncCommitteeUpdatedIterator is returned from FilterSyncCommitteeUpdated and is used to iterate over the raw logs and unpacked data for SyncCommitteeUpdated events raised by the EthereumLightClient contract.
type EthereumLightClientSyncCommitteeUpdatedIterator struct {
	Event *EthereumLightClientSyncCommitteeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientSyncCommitteeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientSyncCommitteeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientSyncCommitteeUpdated represents a SyncCommitteeUpdated event raised by the EthereumLightClient contract.
type EthereumLightClientSyncCommitteeUpdated struct {
	Period       *big.Int
	SszRoot      [32]byte
	PoseidonRoot [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSyncCommitteeUpdated is a free log retrieval operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterSyncCommitteeUpdated(opts *bind.FilterOpts) (*EthereumLightClientSyncCommitteeUpdatedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "SyncCommitteeUpdated")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientSyncCommitteeUpdatedIterator{contract: _EthereumLightClient.contract, event: "SyncCommitteeUpdated", logs: logs, sub: sub}, nil
}

// WatchSyncCommitteeUpdated is a free log subscription operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchSyncCommitteeUpdated(opts *bind.WatchOpts, sink chan<- *EthereumLightClientSyncCommitteeUpdated) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "SyncCommitteeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientSyncCommitteeUpdated)
				if err := _EthereumLightClient.contract.UnpackLog(event, "SyncCommitteeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSyncCommitteeUpdated is a log parse operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseSyncCommitteeUpdated(log types.Log) (*EthereumLightClientSyncCommitteeUpdated, error) {
	event := new(EthereumLightClientSyncCommitteeUpdated)
	if err := _EthereumLightClient.contract.UnpackLog(event, "SyncCommitteeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the EthereumLightClient contract.
type EthereumLightClientUnpausedIterator struct {
	Event *EthereumLightClientUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientUnpaused represents a Unpaused event raised by the EthereumLightClient contract.
type EthereumLightClientUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterUnpaused(opts *bind.FilterOpts) (*EthereumLightClientUnpausedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientUnpausedIterator{contract: _EthereumLightClient.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *EthereumLightClientUnpaused) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientUnpaused)
				if err := _EthereumLightClient.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseUnpaused(log types.Log) (*EthereumLightClientUnpaused, error) {
	event := new(EthereumLightClientUnpaused)
	if err := _EthereumLightClient.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeLibraryMetaData contains all meta data concerning the FeeLibrary contract.
var FeeLibraryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"DYNAMIC_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOOK_SWAP_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOOK_WITHDRAW_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATIC_FEE_MASK\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608080604052346100195760e0908161001e823930815050f35b5f80fdfe60808060405260043610156011575f80fd5b5f90813560e01c9081634f7deff714608f57508063c7a97b4e146077578063d11e7dee14605f5763f26ef49d146045575f80fd5b80600319360112605c576020604051628000008152f35b80fd5b5080600319360112605c576020604051624000008152f35b5080600319360112605c576020604051620fffff8152f35b90508160031936011260a657806220000060209252f35b5080fdfea2646970667358221220d40de33af200db2108593e465bba47dc273a323509668f3b87e6580e05b1f1b364736f6c63430008140033",
}

// FeeLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use FeeLibraryMetaData.ABI instead.
var FeeLibraryABI = FeeLibraryMetaData.ABI

// FeeLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FeeLibraryMetaData.Bin instead.
var FeeLibraryBin = FeeLibraryMetaData.Bin

// DeployFeeLibrary deploys a new Ethereum contract, binding an instance of FeeLibrary to it.
func DeployFeeLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FeeLibrary, error) {
	parsed, err := FeeLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FeeLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FeeLibrary{FeeLibraryCaller: FeeLibraryCaller{contract: contract}, FeeLibraryTransactor: FeeLibraryTransactor{contract: contract}, FeeLibraryFilterer: FeeLibraryFilterer{contract: contract}}, nil
}

// FeeLibrary is an auto generated Go binding around an Ethereum contract.
type FeeLibrary struct {
	FeeLibraryCaller     // Read-only binding to the contract
	FeeLibraryTransactor // Write-only binding to the contract
	FeeLibraryFilterer   // Log filterer for contract events
}

// FeeLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type FeeLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FeeLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FeeLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FeeLibrarySession struct {
	Contract     *FeeLibrary       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FeeLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FeeLibraryCallerSession struct {
	Contract *FeeLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// FeeLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FeeLibraryTransactorSession struct {
	Contract     *FeeLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// FeeLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type FeeLibraryRaw struct {
	Contract *FeeLibrary // Generic contract binding to access the raw methods on
}

// FeeLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FeeLibraryCallerRaw struct {
	Contract *FeeLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// FeeLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FeeLibraryTransactorRaw struct {
	Contract *FeeLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFeeLibrary creates a new instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibrary(address common.Address, backend bind.ContractBackend) (*FeeLibrary, error) {
	contract, err := bindFeeLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FeeLibrary{FeeLibraryCaller: FeeLibraryCaller{contract: contract}, FeeLibraryTransactor: FeeLibraryTransactor{contract: contract}, FeeLibraryFilterer: FeeLibraryFilterer{contract: contract}}, nil
}

// NewFeeLibraryCaller creates a new read-only instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryCaller(address common.Address, caller bind.ContractCaller) (*FeeLibraryCaller, error) {
	contract, err := bindFeeLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryCaller{contract: contract}, nil
}

// NewFeeLibraryTransactor creates a new write-only instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*FeeLibraryTransactor, error) {
	contract, err := bindFeeLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryTransactor{contract: contract}, nil
}

// NewFeeLibraryFilterer creates a new log filterer instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*FeeLibraryFilterer, error) {
	contract, err := bindFeeLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryFilterer{contract: contract}, nil
}

// bindFeeLibrary binds a generic wrapper to an already deployed contract.
func bindFeeLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FeeLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeLibrary *FeeLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeLibrary.Contract.FeeLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeLibrary *FeeLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeLibrary.Contract.FeeLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeLibrary *FeeLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeLibrary.Contract.FeeLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeLibrary *FeeLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeLibrary *FeeLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeLibrary *FeeLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeLibrary.Contract.contract.Transact(opts, method, params...)
}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) DYNAMICFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "DYNAMIC_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) DYNAMICFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.DYNAMICFEEFLAG(&_FeeLibrary.CallOpts)
}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) DYNAMICFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.DYNAMICFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) HOOKSWAPFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "HOOK_SWAP_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) HOOKSWAPFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKSWAPFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) HOOKSWAPFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKSWAPFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) HOOKWITHDRAWFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "HOOK_WITHDRAW_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) HOOKWITHDRAWFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKWITHDRAWFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) HOOKWITHDRAWFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKWITHDRAWFEEFLAG(&_FeeLibrary.CallOpts)
}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) STATICFEEMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "STATIC_FEE_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) STATICFEEMASK() (*big.Int, error) {
	return _FeeLibrary.Contract.STATICFEEMASK(&_FeeLibrary.CallOpts)
}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) STATICFEEMASK() (*big.Int, error) {
	return _FeeLibrary.Contract.STATICFEEMASK(&_FeeLibrary.CallOpts)
}

// FeeVaultMetaData contains all meta data concerning the FeeVault contract.
var FeeVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x6080346100a457601f6104e938819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3600154161760015561042c90816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040818152600480361015610020575b505050361561001e575f80fd5b005b5f92833560e01c9081637ff7b0d214610224575080638da5cb5b146101fe578063a42dce8014610178578063c415b95c1461014c5763f2fde38b03610011573461014857602036600319011261014857610078610391565b908354906001600160a01b03808316936100933386146103ab565b169384156100df57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b5050346101745781600319360112610174576020906001600160a01b03600154169051908152f35b5080fd5b505034610174576020366003190112610174577f5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38906101b5610391565b6001600160a01b036101cb8186541633146103ab565b806001549216908173ffffffffffffffffffffffffffffffffffffffff198416176001558351921682526020820152a180f35b5050346101745781600319360112610174576001600160a01b0360209254169051908152f35b848484346101485781600319360112610148578035906024356001600160a01b03958682169687830361038d5760015416330361034c575084808085819461c350f13d156103475767ffffffffffffffff3d81811161033457855191601f8201601f19908116603f011683019081118382101761032157865281528560203d92013e5b156102de57507ff10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186929382519182526020820152a180f35b606490602084519162461bcd60e51b8352820152601260248201527f73656e64206e6174697665206661696c656400000000000000000000000000006044820152fd5b634e487b7160e01b885260418552602488fd5b634e487b7160e01b875260418452602487fd5b6102a7565b62461bcd60e51b8152602083820152601160248201527f6e6f742066656520636f6c6c6563746f720000000000000000000000000000006044820152606490fd5b8680fd5b600435906001600160a01b03821682036103a757565b5f80fd5b156103b257565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfea264697066735822122050074f8378aad9f9dcd9800401cb61634df4ab69789ded3bdec520a69a906b5d64736f6c63430008140033",
}

// FeeVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use FeeVaultMetaData.ABI instead.
var FeeVaultABI = FeeVaultMetaData.ABI

// FeeVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FeeVaultMetaData.Bin instead.
var FeeVaultBin = FeeVaultMetaData.Bin

// DeployFeeVault deploys a new Ethereum contract, binding an instance of FeeVault to it.
func DeployFeeVault(auth *bind.TransactOpts, backend bind.ContractBackend, _feeCollector common.Address) (common.Address, *types.Transaction, *FeeVault, error) {
	parsed, err := FeeVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FeeVaultBin), backend, _feeCollector)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FeeVault{FeeVaultCaller: FeeVaultCaller{contract: contract}, FeeVaultTransactor: FeeVaultTransactor{contract: contract}, FeeVaultFilterer: FeeVaultFilterer{contract: contract}}, nil
}

// FeeVault is an auto generated Go binding around an Ethereum contract.
type FeeVault struct {
	FeeVaultCaller     // Read-only binding to the contract
	FeeVaultTransactor // Write-only binding to the contract
	FeeVaultFilterer   // Log filterer for contract events
}

// FeeVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type FeeVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FeeVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FeeVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FeeVaultSession struct {
	Contract     *FeeVault         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FeeVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FeeVaultCallerSession struct {
	Contract *FeeVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// FeeVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FeeVaultTransactorSession struct {
	Contract     *FeeVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// FeeVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type FeeVaultRaw struct {
	Contract *FeeVault // Generic contract binding to access the raw methods on
}

// FeeVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FeeVaultCallerRaw struct {
	Contract *FeeVaultCaller // Generic read-only contract binding to access the raw methods on
}

// FeeVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FeeVaultTransactorRaw struct {
	Contract *FeeVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFeeVault creates a new instance of FeeVault, bound to a specific deployed contract.
func NewFeeVault(address common.Address, backend bind.ContractBackend) (*FeeVault, error) {
	contract, err := bindFeeVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FeeVault{FeeVaultCaller: FeeVaultCaller{contract: contract}, FeeVaultTransactor: FeeVaultTransactor{contract: contract}, FeeVaultFilterer: FeeVaultFilterer{contract: contract}}, nil
}

// NewFeeVaultCaller creates a new read-only instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultCaller(address common.Address, caller bind.ContractCaller) (*FeeVaultCaller, error) {
	contract, err := bindFeeVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FeeVaultCaller{contract: contract}, nil
}

// NewFeeVaultTransactor creates a new write-only instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*FeeVaultTransactor, error) {
	contract, err := bindFeeVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FeeVaultTransactor{contract: contract}, nil
}

// NewFeeVaultFilterer creates a new log filterer instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*FeeVaultFilterer, error) {
	contract, err := bindFeeVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FeeVaultFilterer{contract: contract}, nil
}

// bindFeeVault binds a generic wrapper to an already deployed contract.
func bindFeeVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FeeVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeVault *FeeVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeVault.Contract.FeeVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeVault *FeeVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.Contract.FeeVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeVault *FeeVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeVault.Contract.FeeVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeVault *FeeVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeVault *FeeVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeVault *FeeVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeVault.Contract.contract.Transact(opts, method, params...)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultCaller) FeeCollector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _FeeVault.contract.Call(opts, &out, "feeCollector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultSession) FeeCollector() (common.Address, error) {
	return _FeeVault.Contract.FeeCollector(&_FeeVault.CallOpts)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultCallerSession) FeeCollector() (common.Address, error) {
	return _FeeVault.Contract.FeeCollector(&_FeeVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _FeeVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultSession) Owner() (common.Address, error) {
	return _FeeVault.Contract.Owner(&_FeeVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultCallerSession) Owner() (common.Address, error) {
	return _FeeVault.Contract.Owner(&_FeeVault.CallOpts)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultTransactor) CollectFee(opts *bind.TransactOpts, _amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "collectFee", _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.CollectFee(&_FeeVault.TransactOpts, _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultTransactorSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.CollectFee(&_FeeVault.TransactOpts, _amount, _to)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultTransactor) SetFeeCollector(opts *bind.TransactOpts, _feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "setFeeCollector", _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.SetFeeCollector(&_FeeVault.TransactOpts, _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultTransactorSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.SetFeeCollector(&_FeeVault.TransactOpts, _feeCollector)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.TransferOwnership(&_FeeVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.TransferOwnership(&_FeeVault.TransactOpts, newOwner)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultSession) Receive() (*types.Transaction, error) {
	return _FeeVault.Contract.Receive(&_FeeVault.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultTransactorSession) Receive() (*types.Transaction, error) {
	return _FeeVault.Contract.Receive(&_FeeVault.TransactOpts)
}

// FeeVaultFeeCollectedIterator is returned from FilterFeeCollected and is used to iterate over the raw logs and unpacked data for FeeCollected events raised by the FeeVault contract.
type FeeVaultFeeCollectedIterator struct {
	Event *FeeVaultFeeCollected // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultFeeCollectedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultFeeCollected)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultFeeCollected)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultFeeCollectedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultFeeCollectedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultFeeCollected represents a FeeCollected event raised by the FeeVault contract.
type FeeVaultFeeCollected struct {
	Amount   *big.Int
	Receiver common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFeeCollected is a free log retrieval operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) FilterFeeCollected(opts *bind.FilterOpts) (*FeeVaultFeeCollectedIterator, error) {

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return &FeeVaultFeeCollectedIterator{contract: _FeeVault.contract, event: "FeeCollected", logs: logs, sub: sub}, nil
}

// WatchFeeCollected is a free log subscription operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) WatchFeeCollected(opts *bind.WatchOpts, sink chan<- *FeeVaultFeeCollected) (event.Subscription, error) {

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultFeeCollected)
				if err := _FeeVault.contract.UnpackLog(event, "FeeCollected", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollected is a log parse operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) ParseFeeCollected(log types.Log) (*FeeVaultFeeCollected, error) {
	event := new(FeeVaultFeeCollected)
	if err := _FeeVault.contract.UnpackLog(event, "FeeCollected", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeVaultFeeCollectorUpdatedIterator is returned from FilterFeeCollectorUpdated and is used to iterate over the raw logs and unpacked data for FeeCollectorUpdated events raised by the FeeVault contract.
type FeeVaultFeeCollectorUpdatedIterator struct {
	Event *FeeVaultFeeCollectorUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultFeeCollectorUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultFeeCollectorUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultFeeCollectorUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultFeeCollectorUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultFeeCollectorUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultFeeCollectorUpdated represents a FeeCollectorUpdated event raised by the FeeVault contract.
type FeeVaultFeeCollectorUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFeeCollectorUpdated is a free log retrieval operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) FilterFeeCollectorUpdated(opts *bind.FilterOpts) (*FeeVaultFeeCollectorUpdatedIterator, error) {

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return &FeeVaultFeeCollectorUpdatedIterator{contract: _FeeVault.contract, event: "FeeCollectorUpdated", logs: logs, sub: sub}, nil
}

// WatchFeeCollectorUpdated is a free log subscription operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) WatchFeeCollectorUpdated(opts *bind.WatchOpts, sink chan<- *FeeVaultFeeCollectorUpdated) (event.Subscription, error) {

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultFeeCollectorUpdated)
				if err := _FeeVault.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollectorUpdated is a log parse operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) ParseFeeCollectorUpdated(log types.Log) (*FeeVaultFeeCollectorUpdated, error) {
	event := new(FeeVaultFeeCollectorUpdated)
	if err := _FeeVault.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the FeeVault contract.
type FeeVaultOwnershipTransferredIterator struct {
	Event *FeeVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultOwnershipTransferred represents a OwnershipTransferred event raised by the FeeVault contract.
type FeeVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*FeeVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &FeeVaultOwnershipTransferredIterator{contract: _FeeVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *FeeVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultOwnershipTransferred)
				if err := _FeeVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) ParseOwnershipTransferred(log types.Log) (*FeeVaultOwnershipTransferred, error) {
	event := new(FeeVaultOwnershipTransferred)
	if err := _FeeVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FixedPoint128MetaData contains all meta data concerning the FixedPoint128 contract.
var FixedPoint128MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122058137079b05a69c108e8ea72d4489ce277c03499928f0a65b81f98b79e997fae64736f6c63430008140033",
}

// FixedPoint128ABI is the input ABI used to generate the binding from.
// Deprecated: Use FixedPoint128MetaData.ABI instead.
var FixedPoint128ABI = FixedPoint128MetaData.ABI

// FixedPoint128Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FixedPoint128MetaData.Bin instead.
var FixedPoint128Bin = FixedPoint128MetaData.Bin

// DeployFixedPoint128 deploys a new Ethereum contract, binding an instance of FixedPoint128 to it.
func DeployFixedPoint128(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FixedPoint128, error) {
	parsed, err := FixedPoint128MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FixedPoint128Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FixedPoint128{FixedPoint128Caller: FixedPoint128Caller{contract: contract}, FixedPoint128Transactor: FixedPoint128Transactor{contract: contract}, FixedPoint128Filterer: FixedPoint128Filterer{contract: contract}}, nil
}

// FixedPoint128 is an auto generated Go binding around an Ethereum contract.
type FixedPoint128 struct {
	FixedPoint128Caller     // Read-only binding to the contract
	FixedPoint128Transactor // Write-only binding to the contract
	FixedPoint128Filterer   // Log filterer for contract events
}

// FixedPoint128Caller is an auto generated read-only Go binding around an Ethereum contract.
type FixedPoint128Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Transactor is an auto generated write-only Go binding around an Ethereum contract.
type FixedPoint128Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FixedPoint128Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FixedPoint128Session struct {
	Contract     *FixedPoint128    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FixedPoint128CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FixedPoint128CallerSession struct {
	Contract *FixedPoint128Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// FixedPoint128TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FixedPoint128TransactorSession struct {
	Contract     *FixedPoint128Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// FixedPoint128Raw is an auto generated low-level Go binding around an Ethereum contract.
type FixedPoint128Raw struct {
	Contract *FixedPoint128 // Generic contract binding to access the raw methods on
}

// FixedPoint128CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FixedPoint128CallerRaw struct {
	Contract *FixedPoint128Caller // Generic read-only contract binding to access the raw methods on
}

// FixedPoint128TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FixedPoint128TransactorRaw struct {
	Contract *FixedPoint128Transactor // Generic write-only contract binding to access the raw methods on
}

// NewFixedPoint128 creates a new instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128(address common.Address, backend bind.ContractBackend) (*FixedPoint128, error) {
	contract, err := bindFixedPoint128(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128{FixedPoint128Caller: FixedPoint128Caller{contract: contract}, FixedPoint128Transactor: FixedPoint128Transactor{contract: contract}, FixedPoint128Filterer: FixedPoint128Filterer{contract: contract}}, nil
}

// NewFixedPoint128Caller creates a new read-only instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Caller(address common.Address, caller bind.ContractCaller) (*FixedPoint128Caller, error) {
	contract, err := bindFixedPoint128(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Caller{contract: contract}, nil
}

// NewFixedPoint128Transactor creates a new write-only instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Transactor(address common.Address, transactor bind.ContractTransactor) (*FixedPoint128Transactor, error) {
	contract, err := bindFixedPoint128(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Transactor{contract: contract}, nil
}

// NewFixedPoint128Filterer creates a new log filterer instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Filterer(address common.Address, filterer bind.ContractFilterer) (*FixedPoint128Filterer, error) {
	contract, err := bindFixedPoint128(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Filterer{contract: contract}, nil
}

// bindFixedPoint128 binds a generic wrapper to an already deployed contract.
func bindFixedPoint128(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FixedPoint128MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint128 *FixedPoint128Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint128.Contract.FixedPoint128Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint128 *FixedPoint128Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint128.Contract.FixedPoint128Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint128 *FixedPoint128Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint128.Contract.FixedPoint128Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint128 *FixedPoint128CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint128.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint128 *FixedPoint128TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint128.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint128 *FixedPoint128TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint128.Contract.contract.Transact(opts, method, params...)
}

// FixedPoint96MetaData contains all meta data concerning the FixedPoint96 contract.
var FixedPoint96MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202f0c93e43c9b19ca4163b311ea6a376d3780b335025a9ae1a3b76228d695223c64736f6c63430008140033",
}

// FixedPoint96ABI is the input ABI used to generate the binding from.
// Deprecated: Use FixedPoint96MetaData.ABI instead.
var FixedPoint96ABI = FixedPoint96MetaData.ABI

// FixedPoint96Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FixedPoint96MetaData.Bin instead.
var FixedPoint96Bin = FixedPoint96MetaData.Bin

// DeployFixedPoint96 deploys a new Ethereum contract, binding an instance of FixedPoint96 to it.
func DeployFixedPoint96(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FixedPoint96, error) {
	parsed, err := FixedPoint96MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FixedPoint96Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FixedPoint96{FixedPoint96Caller: FixedPoint96Caller{contract: contract}, FixedPoint96Transactor: FixedPoint96Transactor{contract: contract}, FixedPoint96Filterer: FixedPoint96Filterer{contract: contract}}, nil
}

// FixedPoint96 is an auto generated Go binding around an Ethereum contract.
type FixedPoint96 struct {
	FixedPoint96Caller     // Read-only binding to the contract
	FixedPoint96Transactor // Write-only binding to the contract
	FixedPoint96Filterer   // Log filterer for contract events
}

// FixedPoint96Caller is an auto generated read-only Go binding around an Ethereum contract.
type FixedPoint96Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Transactor is an auto generated write-only Go binding around an Ethereum contract.
type FixedPoint96Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FixedPoint96Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FixedPoint96Session struct {
	Contract     *FixedPoint96     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FixedPoint96CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FixedPoint96CallerSession struct {
	Contract *FixedPoint96Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// FixedPoint96TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FixedPoint96TransactorSession struct {
	Contract     *FixedPoint96Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// FixedPoint96Raw is an auto generated low-level Go binding around an Ethereum contract.
type FixedPoint96Raw struct {
	Contract *FixedPoint96 // Generic contract binding to access the raw methods on
}

// FixedPoint96CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FixedPoint96CallerRaw struct {
	Contract *FixedPoint96Caller // Generic read-only contract binding to access the raw methods on
}

// FixedPoint96TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FixedPoint96TransactorRaw struct {
	Contract *FixedPoint96Transactor // Generic write-only contract binding to access the raw methods on
}

// NewFixedPoint96 creates a new instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96(address common.Address, backend bind.ContractBackend) (*FixedPoint96, error) {
	contract, err := bindFixedPoint96(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96{FixedPoint96Caller: FixedPoint96Caller{contract: contract}, FixedPoint96Transactor: FixedPoint96Transactor{contract: contract}, FixedPoint96Filterer: FixedPoint96Filterer{contract: contract}}, nil
}

// NewFixedPoint96Caller creates a new read-only instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Caller(address common.Address, caller bind.ContractCaller) (*FixedPoint96Caller, error) {
	contract, err := bindFixedPoint96(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Caller{contract: contract}, nil
}

// NewFixedPoint96Transactor creates a new write-only instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Transactor(address common.Address, transactor bind.ContractTransactor) (*FixedPoint96Transactor, error) {
	contract, err := bindFixedPoint96(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Transactor{contract: contract}, nil
}

// NewFixedPoint96Filterer creates a new log filterer instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Filterer(address common.Address, filterer bind.ContractFilterer) (*FixedPoint96Filterer, error) {
	contract, err := bindFixedPoint96(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Filterer{contract: contract}, nil
}

// bindFixedPoint96 binds a generic wrapper to an already deployed contract.
func bindFixedPoint96(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FixedPoint96MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint96 *FixedPoint96Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint96.Contract.FixedPoint96Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint96 *FixedPoint96Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint96.Contract.FixedPoint96Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint96 *FixedPoint96Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint96.Contract.FixedPoint96Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint96 *FixedPoint96CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint96.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint96 *FixedPoint96TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint96.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint96 *FixedPoint96TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint96.Contract.contract.Transact(opts, method, params...)
}

// FullMathMetaData contains all meta data concerning the FullMath contract.
var FullMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202ed6c61bfc87c4068cd8caa5fabe7ead9f25d431c779d05d4e8ad802f88f306c64736f6c63430008140033",
}

// FullMathABI is the input ABI used to generate the binding from.
// Deprecated: Use FullMathMetaData.ABI instead.
var FullMathABI = FullMathMetaData.ABI

// FullMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FullMathMetaData.Bin instead.
var FullMathBin = FullMathMetaData.Bin

// DeployFullMath deploys a new Ethereum contract, binding an instance of FullMath to it.
func DeployFullMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FullMath, error) {
	parsed, err := FullMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FullMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FullMath{FullMathCaller: FullMathCaller{contract: contract}, FullMathTransactor: FullMathTransactor{contract: contract}, FullMathFilterer: FullMathFilterer{contract: contract}}, nil
}

// FullMath is an auto generated Go binding around an Ethereum contract.
type FullMath struct {
	FullMathCaller     // Read-only binding to the contract
	FullMathTransactor // Write-only binding to the contract
	FullMathFilterer   // Log filterer for contract events
}

// FullMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type FullMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FullMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FullMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FullMathSession struct {
	Contract     *FullMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FullMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FullMathCallerSession struct {
	Contract *FullMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// FullMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FullMathTransactorSession struct {
	Contract     *FullMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// FullMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type FullMathRaw struct {
	Contract *FullMath // Generic contract binding to access the raw methods on
}

// FullMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FullMathCallerRaw struct {
	Contract *FullMathCaller // Generic read-only contract binding to access the raw methods on
}

// FullMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FullMathTransactorRaw struct {
	Contract *FullMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFullMath creates a new instance of FullMath, bound to a specific deployed contract.
func NewFullMath(address common.Address, backend bind.ContractBackend) (*FullMath, error) {
	contract, err := bindFullMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FullMath{FullMathCaller: FullMathCaller{contract: contract}, FullMathTransactor: FullMathTransactor{contract: contract}, FullMathFilterer: FullMathFilterer{contract: contract}}, nil
}

// NewFullMathCaller creates a new read-only instance of FullMath, bound to a specific deployed contract.
func NewFullMathCaller(address common.Address, caller bind.ContractCaller) (*FullMathCaller, error) {
	contract, err := bindFullMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FullMathCaller{contract: contract}, nil
}

// NewFullMathTransactor creates a new write-only instance of FullMath, bound to a specific deployed contract.
func NewFullMathTransactor(address common.Address, transactor bind.ContractTransactor) (*FullMathTransactor, error) {
	contract, err := bindFullMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FullMathTransactor{contract: contract}, nil
}

// NewFullMathFilterer creates a new log filterer instance of FullMath, bound to a specific deployed contract.
func NewFullMathFilterer(address common.Address, filterer bind.ContractFilterer) (*FullMathFilterer, error) {
	contract, err := bindFullMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FullMathFilterer{contract: contract}, nil
}

// bindFullMath binds a generic wrapper to an already deployed contract.
func bindFullMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FullMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FullMath *FullMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FullMath.Contract.FullMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FullMath *FullMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FullMath.Contract.FullMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FullMath *FullMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FullMath.Contract.FullMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FullMath *FullMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FullMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FullMath *FullMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FullMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FullMath *FullMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FullMath.Contract.contract.Transact(opts, method, params...)
}

// HelpersMetaData contains all meta data concerning the Helpers contract.
var HelpersMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220886aea72f095839daeed114144d16b954abd9d734b4750b386e897a8b737905064736f6c63430008140033",
}

// HelpersABI is the input ABI used to generate the binding from.
// Deprecated: Use HelpersMetaData.ABI instead.
var HelpersABI = HelpersMetaData.ABI

// HelpersBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use HelpersMetaData.Bin instead.
var HelpersBin = HelpersMetaData.Bin

// DeployHelpers deploys a new Ethereum contract, binding an instance of Helpers to it.
func DeployHelpers(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Helpers, error) {
	parsed, err := HelpersMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(HelpersBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Helpers{HelpersCaller: HelpersCaller{contract: contract}, HelpersTransactor: HelpersTransactor{contract: contract}, HelpersFilterer: HelpersFilterer{contract: contract}}, nil
}

// Helpers is an auto generated Go binding around an Ethereum contract.
type Helpers struct {
	HelpersCaller     // Read-only binding to the contract
	HelpersTransactor // Write-only binding to the contract
	HelpersFilterer   // Log filterer for contract events
}

// HelpersCaller is an auto generated read-only Go binding around an Ethereum contract.
type HelpersCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersTransactor is an auto generated write-only Go binding around an Ethereum contract.
type HelpersTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type HelpersFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type HelpersSession struct {
	Contract     *Helpers          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HelpersCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type HelpersCallerSession struct {
	Contract *HelpersCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// HelpersTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type HelpersTransactorSession struct {
	Contract     *HelpersTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// HelpersRaw is an auto generated low-level Go binding around an Ethereum contract.
type HelpersRaw struct {
	Contract *Helpers // Generic contract binding to access the raw methods on
}

// HelpersCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type HelpersCallerRaw struct {
	Contract *HelpersCaller // Generic read-only contract binding to access the raw methods on
}

// HelpersTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type HelpersTransactorRaw struct {
	Contract *HelpersTransactor // Generic write-only contract binding to access the raw methods on
}

// NewHelpers creates a new instance of Helpers, bound to a specific deployed contract.
func NewHelpers(address common.Address, backend bind.ContractBackend) (*Helpers, error) {
	contract, err := bindHelpers(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Helpers{HelpersCaller: HelpersCaller{contract: contract}, HelpersTransactor: HelpersTransactor{contract: contract}, HelpersFilterer: HelpersFilterer{contract: contract}}, nil
}

// NewHelpersCaller creates a new read-only instance of Helpers, bound to a specific deployed contract.
func NewHelpersCaller(address common.Address, caller bind.ContractCaller) (*HelpersCaller, error) {
	contract, err := bindHelpers(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HelpersCaller{contract: contract}, nil
}

// NewHelpersTransactor creates a new write-only instance of Helpers, bound to a specific deployed contract.
func NewHelpersTransactor(address common.Address, transactor bind.ContractTransactor) (*HelpersTransactor, error) {
	contract, err := bindHelpers(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HelpersTransactor{contract: contract}, nil
}

// NewHelpersFilterer creates a new log filterer instance of Helpers, bound to a specific deployed contract.
func NewHelpersFilterer(address common.Address, filterer bind.ContractFilterer) (*HelpersFilterer, error) {
	contract, err := bindHelpers(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HelpersFilterer{contract: contract}, nil
}

// bindHelpers binds a generic wrapper to an already deployed contract.
func bindHelpers(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := HelpersMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Helpers *HelpersRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Helpers.Contract.HelpersCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Helpers *HelpersRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Helpers.Contract.HelpersTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Helpers *HelpersRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Helpers.Contract.HelpersTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Helpers *HelpersCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Helpers.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Helpers *HelpersTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Helpers.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Helpers *HelpersTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Helpers.Contract.contract.Transact(opts, method, params...)
}

// HooksMetaData contains all meta data concerning the Hooks contract.
var HooksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHookResponse\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122042d822709753692908c3058f202b48f96b62bfdacbf6217ead2bdf2975ee0ad064736f6c63430008140033",
}

// HooksABI is the input ABI used to generate the binding from.
// Deprecated: Use HooksMetaData.ABI instead.
var HooksABI = HooksMetaData.ABI

// HooksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use HooksMetaData.Bin instead.
var HooksBin = HooksMetaData.Bin

// DeployHooks deploys a new Ethereum contract, binding an instance of Hooks to it.
func DeployHooks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Hooks, error) {
	parsed, err := HooksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(HooksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Hooks{HooksCaller: HooksCaller{contract: contract}, HooksTransactor: HooksTransactor{contract: contract}, HooksFilterer: HooksFilterer{contract: contract}}, nil
}

// Hooks is an auto generated Go binding around an Ethereum contract.
type Hooks struct {
	HooksCaller     // Read-only binding to the contract
	HooksTransactor // Write-only binding to the contract
	HooksFilterer   // Log filterer for contract events
}

// HooksCaller is an auto generated read-only Go binding around an Ethereum contract.
type HooksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type HooksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type HooksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type HooksSession struct {
	Contract     *Hooks            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HooksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type HooksCallerSession struct {
	Contract *HooksCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// HooksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type HooksTransactorSession struct {
	Contract     *HooksTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HooksRaw is an auto generated low-level Go binding around an Ethereum contract.
type HooksRaw struct {
	Contract *Hooks // Generic contract binding to access the raw methods on
}

// HooksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type HooksCallerRaw struct {
	Contract *HooksCaller // Generic read-only contract binding to access the raw methods on
}

// HooksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type HooksTransactorRaw struct {
	Contract *HooksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewHooks creates a new instance of Hooks, bound to a specific deployed contract.
func NewHooks(address common.Address, backend bind.ContractBackend) (*Hooks, error) {
	contract, err := bindHooks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Hooks{HooksCaller: HooksCaller{contract: contract}, HooksTransactor: HooksTransactor{contract: contract}, HooksFilterer: HooksFilterer{contract: contract}}, nil
}

// NewHooksCaller creates a new read-only instance of Hooks, bound to a specific deployed contract.
func NewHooksCaller(address common.Address, caller bind.ContractCaller) (*HooksCaller, error) {
	contract, err := bindHooks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HooksCaller{contract: contract}, nil
}

// NewHooksTransactor creates a new write-only instance of Hooks, bound to a specific deployed contract.
func NewHooksTransactor(address common.Address, transactor bind.ContractTransactor) (*HooksTransactor, error) {
	contract, err := bindHooks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HooksTransactor{contract: contract}, nil
}

// NewHooksFilterer creates a new log filterer instance of Hooks, bound to a specific deployed contract.
func NewHooksFilterer(address common.Address, filterer bind.ContractFilterer) (*HooksFilterer, error) {
	contract, err := bindHooks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HooksFilterer{contract: contract}, nil
}

// bindHooks binds a generic wrapper to an already deployed contract.
func bindHooks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := HooksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Hooks *HooksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Hooks.Contract.HooksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Hooks *HooksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Hooks.Contract.HooksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Hooks *HooksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Hooks.Contract.HooksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Hooks *HooksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Hooks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Hooks *HooksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Hooks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Hooks *HooksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Hooks.Contract.contract.Transact(opts, method, params...)
}

// IAnchorBlocksMetaData contains all meta data concerning the IAnchorBlocks contract.
var IAnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IAnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use IAnchorBlocksMetaData.ABI instead.
var IAnchorBlocksABI = IAnchorBlocksMetaData.ABI

// IAnchorBlocks is an auto generated Go binding around an Ethereum contract.
type IAnchorBlocks struct {
	IAnchorBlocksCaller     // Read-only binding to the contract
	IAnchorBlocksTransactor // Write-only binding to the contract
	IAnchorBlocksFilterer   // Log filterer for contract events
}

// IAnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAnchorBlocksSession struct {
	Contract     *IAnchorBlocks    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAnchorBlocksCallerSession struct {
	Contract *IAnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// IAnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAnchorBlocksTransactorSession struct {
	Contract     *IAnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// IAnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAnchorBlocksRaw struct {
	Contract *IAnchorBlocks // Generic contract binding to access the raw methods on
}

// IAnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAnchorBlocksCallerRaw struct {
	Contract *IAnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// IAnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAnchorBlocksTransactorRaw struct {
	Contract *IAnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAnchorBlocks creates a new instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocks(address common.Address, backend bind.ContractBackend) (*IAnchorBlocks, error) {
	contract, err := bindIAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocks{IAnchorBlocksCaller: IAnchorBlocksCaller{contract: contract}, IAnchorBlocksTransactor: IAnchorBlocksTransactor{contract: contract}, IAnchorBlocksFilterer: IAnchorBlocksFilterer{contract: contract}}, nil
}

// NewIAnchorBlocksCaller creates a new read-only instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*IAnchorBlocksCaller, error) {
	contract, err := bindIAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksCaller{contract: contract}, nil
}

// NewIAnchorBlocksTransactor creates a new write-only instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*IAnchorBlocksTransactor, error) {
	contract, err := bindIAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksTransactor{contract: contract}, nil
}

// NewIAnchorBlocksFilterer creates a new log filterer instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*IAnchorBlocksFilterer, error) {
	contract, err := bindIAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksFilterer{contract: contract}, nil
}

// bindIAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindIAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAnchorBlocks *IAnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAnchorBlocks.Contract.IAnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAnchorBlocks *IAnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.IAnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAnchorBlocks *IAnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.IAnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAnchorBlocks *IAnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAnchorBlocks *IAnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAnchorBlocks *IAnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksCaller) Blocks(opts *bind.CallOpts, blockNum *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IAnchorBlocks.contract.Call(opts, &out, "blocks", blockNum)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _IAnchorBlocks.Contract.Blocks(&_IAnchorBlocks.CallOpts, blockNum)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksCallerSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _IAnchorBlocks.Contract.Blocks(&_IAnchorBlocks.CallOpts, blockNum)
}

// IBeaconVerifierMetaData contains all meta data concerning the IBeaconVerifier contract.
var IBeaconVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"signingRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"participation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySignatureProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySyncCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBeaconVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IBeaconVerifierMetaData.ABI instead.
var IBeaconVerifierABI = IBeaconVerifierMetaData.ABI

// IBeaconVerifier is an auto generated Go binding around an Ethereum contract.
type IBeaconVerifier struct {
	IBeaconVerifierCaller     // Read-only binding to the contract
	IBeaconVerifierTransactor // Write-only binding to the contract
	IBeaconVerifierFilterer   // Log filterer for contract events
}

// IBeaconVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBeaconVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBeaconVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBeaconVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBeaconVerifierSession struct {
	Contract     *IBeaconVerifier  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBeaconVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBeaconVerifierCallerSession struct {
	Contract *IBeaconVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IBeaconVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBeaconVerifierTransactorSession struct {
	Contract     *IBeaconVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IBeaconVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBeaconVerifierRaw struct {
	Contract *IBeaconVerifier // Generic contract binding to access the raw methods on
}

// IBeaconVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBeaconVerifierCallerRaw struct {
	Contract *IBeaconVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IBeaconVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBeaconVerifierTransactorRaw struct {
	Contract *IBeaconVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBeaconVerifier creates a new instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifier(address common.Address, backend bind.ContractBackend) (*IBeaconVerifier, error) {
	contract, err := bindIBeaconVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifier{IBeaconVerifierCaller: IBeaconVerifierCaller{contract: contract}, IBeaconVerifierTransactor: IBeaconVerifierTransactor{contract: contract}, IBeaconVerifierFilterer: IBeaconVerifierFilterer{contract: contract}}, nil
}

// NewIBeaconVerifierCaller creates a new read-only instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierCaller(address common.Address, caller bind.ContractCaller) (*IBeaconVerifierCaller, error) {
	contract, err := bindIBeaconVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierCaller{contract: contract}, nil
}

// NewIBeaconVerifierTransactor creates a new write-only instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IBeaconVerifierTransactor, error) {
	contract, err := bindIBeaconVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierTransactor{contract: contract}, nil
}

// NewIBeaconVerifierFilterer creates a new log filterer instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IBeaconVerifierFilterer, error) {
	contract, err := bindIBeaconVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierFilterer{contract: contract}, nil
}

// bindIBeaconVerifier binds a generic wrapper to an already deployed contract.
func bindIBeaconVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBeaconVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBeaconVerifier *IBeaconVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBeaconVerifier.Contract.IBeaconVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBeaconVerifier *IBeaconVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.IBeaconVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBeaconVerifier *IBeaconVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.IBeaconVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBeaconVerifier *IBeaconVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBeaconVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBeaconVerifier *IBeaconVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBeaconVerifier *IBeaconVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCaller) VerifySignatureProof(opts *bind.CallOpts, signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _IBeaconVerifier.contract.Call(opts, &out, "verifySignatureProof", signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySignatureProof(&_IBeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCallerSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySignatureProof(&_IBeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCaller) VerifySyncCommitteeRootMappingProof(opts *bind.CallOpts, sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _IBeaconVerifier.contract.Call(opts, &out, "verifySyncCommitteeRootMappingProof", sszRoot, poseidonRoot, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_IBeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCallerSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_IBeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// IBlockChunksMetaData contains all meta data concerning the IBlockChunks contract.
var IBlockChunksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"}],\"name\":\"UpdateEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"}],\"name\":\"historicalRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"claimedBlkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[7]\",\"name\":\"merkleProof\",\"type\":\"bytes32[7]\"}],\"internalType\":\"structIBlockChunks.BlockHashWitness\",\"name\":\"witness\",\"type\":\"tuple\"}],\"name\":\"isBlockHashValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"nextNumFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateOld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateRecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBlockChunksABI is the input ABI used to generate the binding from.
// Deprecated: Use IBlockChunksMetaData.ABI instead.
var IBlockChunksABI = IBlockChunksMetaData.ABI

// IBlockChunks is an auto generated Go binding around an Ethereum contract.
type IBlockChunks struct {
	IBlockChunksCaller     // Read-only binding to the contract
	IBlockChunksTransactor // Write-only binding to the contract
	IBlockChunksFilterer   // Log filterer for contract events
}

// IBlockChunksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBlockChunksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBlockChunksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBlockChunksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBlockChunksSession struct {
	Contract     *IBlockChunks     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBlockChunksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBlockChunksCallerSession struct {
	Contract *IBlockChunksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IBlockChunksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBlockChunksTransactorSession struct {
	Contract     *IBlockChunksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IBlockChunksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBlockChunksRaw struct {
	Contract *IBlockChunks // Generic contract binding to access the raw methods on
}

// IBlockChunksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBlockChunksCallerRaw struct {
	Contract *IBlockChunksCaller // Generic read-only contract binding to access the raw methods on
}

// IBlockChunksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBlockChunksTransactorRaw struct {
	Contract *IBlockChunksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBlockChunks creates a new instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunks(address common.Address, backend bind.ContractBackend) (*IBlockChunks, error) {
	contract, err := bindIBlockChunks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBlockChunks{IBlockChunksCaller: IBlockChunksCaller{contract: contract}, IBlockChunksTransactor: IBlockChunksTransactor{contract: contract}, IBlockChunksFilterer: IBlockChunksFilterer{contract: contract}}, nil
}

// NewIBlockChunksCaller creates a new read-only instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksCaller(address common.Address, caller bind.ContractCaller) (*IBlockChunksCaller, error) {
	contract, err := bindIBlockChunks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksCaller{contract: contract}, nil
}

// NewIBlockChunksTransactor creates a new write-only instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksTransactor(address common.Address, transactor bind.ContractTransactor) (*IBlockChunksTransactor, error) {
	contract, err := bindIBlockChunks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksTransactor{contract: contract}, nil
}

// NewIBlockChunksFilterer creates a new log filterer instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksFilterer(address common.Address, filterer bind.ContractFilterer) (*IBlockChunksFilterer, error) {
	contract, err := bindIBlockChunks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksFilterer{contract: contract}, nil
}

// bindIBlockChunks binds a generic wrapper to an already deployed contract.
func bindIBlockChunks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBlockChunksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBlockChunks *IBlockChunksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBlockChunks.Contract.IBlockChunksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBlockChunks *IBlockChunksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBlockChunks.Contract.IBlockChunksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBlockChunks *IBlockChunksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBlockChunks.Contract.IBlockChunksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBlockChunks *IBlockChunksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBlockChunks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBlockChunks *IBlockChunksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBlockChunks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBlockChunks *IBlockChunksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBlockChunks.Contract.contract.Transact(opts, method, params...)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksCaller) HistoricalRoots(opts *bind.CallOpts, chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	var out []interface{}
	err := _IBlockChunks.contract.Call(opts, &out, "historicalRoots", chainId, startBlockNumber)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _IBlockChunks.Contract.HistoricalRoots(&_IBlockChunks.CallOpts, chainId, startBlockNumber)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksCallerSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _IBlockChunks.Contract.HistoricalRoots(&_IBlockChunks.CallOpts, chainId, startBlockNumber)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksCaller) IsBlockHashValid(opts *bind.CallOpts, witness IBlockChunksBlockHashWitness) (bool, error) {
	var out []interface{}
	err := _IBlockChunks.contract.Call(opts, &out, "isBlockHashValid", witness)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _IBlockChunks.Contract.IsBlockHashValid(&_IBlockChunks.CallOpts, witness)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksCallerSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _IBlockChunks.Contract.IsBlockHashValid(&_IBlockChunks.CallOpts, witness)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactor) UpdateOld(opts *bind.TransactOpts, chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.contract.Transact(opts, "updateOld", chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateOld(&_IBlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactorSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateOld(&_IBlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactor) UpdateRecent(opts *bind.TransactOpts, chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.contract.Transact(opts, "updateRecent", chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateRecent(&_IBlockChunks.TransactOpts, chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactorSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateRecent(&_IBlockChunks.TransactOpts, chainId, proofData)
}

// IBlockChunksUpdateEventIterator is returned from FilterUpdateEvent and is used to iterate over the raw logs and unpacked data for UpdateEvent events raised by the IBlockChunks contract.
type IBlockChunksUpdateEventIterator struct {
	Event *IBlockChunksUpdateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBlockChunksUpdateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBlockChunksUpdateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBlockChunksUpdateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBlockChunksUpdateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBlockChunksUpdateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBlockChunksUpdateEvent represents a UpdateEvent event raised by the IBlockChunks contract.
type IBlockChunksUpdateEvent struct {
	ChainId          uint64
	StartBlockNumber uint32
	PrevHash         [32]byte
	Root             [32]byte
	NumFinal         uint32
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterUpdateEvent is a free log retrieval operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) FilterUpdateEvent(opts *bind.FilterOpts) (*IBlockChunksUpdateEventIterator, error) {

	logs, sub, err := _IBlockChunks.contract.FilterLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return &IBlockChunksUpdateEventIterator{contract: _IBlockChunks.contract, event: "UpdateEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateEvent is a free log subscription operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) WatchUpdateEvent(opts *bind.WatchOpts, sink chan<- *IBlockChunksUpdateEvent) (event.Subscription, error) {

	logs, sub, err := _IBlockChunks.contract.WatchLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBlockChunksUpdateEvent)
				if err := _IBlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateEvent is a log parse operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) ParseUpdateEvent(log types.Log) (*IBlockChunksUpdateEvent, error) {
	event := new(IBlockChunksUpdateEvent)
	if err := _IBlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisAppMetaData contains all meta data concerning the IBrevisApp contract.
var IBrevisAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBrevisAppABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisAppMetaData.ABI instead.
var IBrevisAppABI = IBrevisAppMetaData.ABI

// IBrevisApp is an auto generated Go binding around an Ethereum contract.
type IBrevisApp struct {
	IBrevisAppCaller     // Read-only binding to the contract
	IBrevisAppTransactor // Write-only binding to the contract
	IBrevisAppFilterer   // Log filterer for contract events
}

// IBrevisAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisAppSession struct {
	Contract     *IBrevisApp       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisAppCallerSession struct {
	Contract *IBrevisAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IBrevisAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisAppTransactorSession struct {
	Contract     *IBrevisAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IBrevisAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisAppRaw struct {
	Contract *IBrevisApp // Generic contract binding to access the raw methods on
}

// IBrevisAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisAppCallerRaw struct {
	Contract *IBrevisAppCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisAppTransactorRaw struct {
	Contract *IBrevisAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisApp creates a new instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisApp(address common.Address, backend bind.ContractBackend) (*IBrevisApp, error) {
	contract, err := bindIBrevisApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisApp{IBrevisAppCaller: IBrevisAppCaller{contract: contract}, IBrevisAppTransactor: IBrevisAppTransactor{contract: contract}, IBrevisAppFilterer: IBrevisAppFilterer{contract: contract}}, nil
}

// NewIBrevisAppCaller creates a new read-only instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppCaller(address common.Address, caller bind.ContractCaller) (*IBrevisAppCaller, error) {
	contract, err := bindIBrevisApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppCaller{contract: contract}, nil
}

// NewIBrevisAppTransactor creates a new write-only instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisAppTransactor, error) {
	contract, err := bindIBrevisApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppTransactor{contract: contract}, nil
}

// NewIBrevisAppFilterer creates a new log filterer instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisAppFilterer, error) {
	contract, err := bindIBrevisApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppFilterer{contract: contract}, nil
}

// bindIBrevisApp binds a generic wrapper to an already deployed contract.
func bindIBrevisApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisApp *IBrevisAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisApp.Contract.IBrevisAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisApp *IBrevisAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisApp.Contract.IBrevisAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisApp *IBrevisAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisApp.Contract.IBrevisAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisApp *IBrevisAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisApp *IBrevisAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisApp *IBrevisAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashs, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppSession) BrevisBatchCallback(_appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisBatchCallback(&_IBrevisApp.TransactOpts, _appVkHashs, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppTransactorSession) BrevisBatchCallback(_appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisBatchCallback(&_IBrevisApp.TransactOpts, _appVkHashs, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisCallback(&_IBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisCallback(&_IBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// IBrevisProofMetaData contains all meta data concerning the IBrevisProof contract.
var IBrevisProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_requestIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"}],\"name\":\"validateProofAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBrevisProofABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisProofMetaData.ABI instead.
var IBrevisProofABI = IBrevisProofMetaData.ABI

// IBrevisProof is an auto generated Go binding around an Ethereum contract.
type IBrevisProof struct {
	IBrevisProofCaller     // Read-only binding to the contract
	IBrevisProofTransactor // Write-only binding to the contract
	IBrevisProofFilterer   // Log filterer for contract events
}

// IBrevisProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisProofSession struct {
	Contract     *IBrevisProof     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisProofCallerSession struct {
	Contract *IBrevisProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IBrevisProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisProofTransactorSession struct {
	Contract     *IBrevisProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IBrevisProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisProofRaw struct {
	Contract *IBrevisProof // Generic contract binding to access the raw methods on
}

// IBrevisProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisProofCallerRaw struct {
	Contract *IBrevisProofCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisProofTransactorRaw struct {
	Contract *IBrevisProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisProof creates a new instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProof(address common.Address, backend bind.ContractBackend) (*IBrevisProof, error) {
	contract, err := bindIBrevisProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisProof{IBrevisProofCaller: IBrevisProofCaller{contract: contract}, IBrevisProofTransactor: IBrevisProofTransactor{contract: contract}, IBrevisProofFilterer: IBrevisProofFilterer{contract: contract}}, nil
}

// NewIBrevisProofCaller creates a new read-only instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofCaller(address common.Address, caller bind.ContractCaller) (*IBrevisProofCaller, error) {
	contract, err := bindIBrevisProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofCaller{contract: contract}, nil
}

// NewIBrevisProofTransactor creates a new write-only instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisProofTransactor, error) {
	contract, err := bindIBrevisProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofTransactor{contract: contract}, nil
}

// NewIBrevisProofFilterer creates a new log filterer instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisProofFilterer, error) {
	contract, err := bindIBrevisProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofFilterer{contract: contract}, nil
}

// bindIBrevisProof binds a generic wrapper to an already deployed contract.
func bindIBrevisProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisProof *IBrevisProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisProof.Contract.IBrevisProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisProof *IBrevisProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisProof.Contract.IBrevisProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisProof *IBrevisProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisProof.Contract.IBrevisProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisProof *IBrevisProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisProof *IBrevisProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisProof *IBrevisProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisProof.Contract.contract.Transact(opts, method, params...)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _IBrevisProof.Contract.ValidateAggProofData(&_IBrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _IBrevisProof.Contract.ValidateAggProofData(&_IBrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _IBrevisProof.Contract.ValidateAggProofData0(&_IBrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _IBrevisProof.Contract.ValidateAggProofData0(&_IBrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofCaller) ValidateProofAppData(opts *bind.CallOpts, _requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateProofAppData", _requestId, _appCommitHash, _appVkHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofSession) ValidateProofAppData(_requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _IBrevisProof.Contract.ValidateProofAppData(&_IBrevisProof.CallOpts, _requestId, _appCommitHash, _appVkHash)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofCallerSession) ValidateProofAppData(_requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _IBrevisProof.Contract.ValidateProofAppData(&_IBrevisProof.CallOpts, _requestId, _appCommitHash, _appVkHash)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.contract.Transact(opts, "submitAggProof", _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofSession) SubmitAggProof(_chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitAggProof(&_IBrevisProof.TransactOpts, _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofTransactorSession) SubmitAggProof(_chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitAggProof(&_IBrevisProof.TransactOpts, _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofTransactor) SubmitProof(opts *bind.TransactOpts, _chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.contract.Transact(opts, "submitProof", _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitProof(&_IBrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofTransactorSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitProof(&_IBrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// IBrevisRequestMetaData contains all meta data concerning the IBrevisRequest contract.
var IBrevisRequestMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_appChallengeWindow\",\"type\":\"uint256\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBrevisRequestABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisRequestMetaData.ABI instead.
var IBrevisRequestABI = IBrevisRequestMetaData.ABI

// IBrevisRequest is an auto generated Go binding around an Ethereum contract.
type IBrevisRequest struct {
	IBrevisRequestCaller     // Read-only binding to the contract
	IBrevisRequestTransactor // Write-only binding to the contract
	IBrevisRequestFilterer   // Log filterer for contract events
}

// IBrevisRequestCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisRequestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisRequestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisRequestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisRequestSession struct {
	Contract     *IBrevisRequest   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisRequestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisRequestCallerSession struct {
	Contract *IBrevisRequestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IBrevisRequestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisRequestTransactorSession struct {
	Contract     *IBrevisRequestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IBrevisRequestRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisRequestRaw struct {
	Contract *IBrevisRequest // Generic contract binding to access the raw methods on
}

// IBrevisRequestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisRequestCallerRaw struct {
	Contract *IBrevisRequestCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisRequestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisRequestTransactorRaw struct {
	Contract *IBrevisRequestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisRequest creates a new instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequest(address common.Address, backend bind.ContractBackend) (*IBrevisRequest, error) {
	contract, err := bindIBrevisRequest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequest{IBrevisRequestCaller: IBrevisRequestCaller{contract: contract}, IBrevisRequestTransactor: IBrevisRequestTransactor{contract: contract}, IBrevisRequestFilterer: IBrevisRequestFilterer{contract: contract}}, nil
}

// NewIBrevisRequestCaller creates a new read-only instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestCaller(address common.Address, caller bind.ContractCaller) (*IBrevisRequestCaller, error) {
	contract, err := bindIBrevisRequest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestCaller{contract: contract}, nil
}

// NewIBrevisRequestTransactor creates a new write-only instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisRequestTransactor, error) {
	contract, err := bindIBrevisRequest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestTransactor{contract: contract}, nil
}

// NewIBrevisRequestFilterer creates a new log filterer instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisRequestFilterer, error) {
	contract, err := bindIBrevisRequest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestFilterer{contract: contract}, nil
}

// bindIBrevisRequest binds a generic wrapper to an already deployed contract.
func bindIBrevisRequest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisRequestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisRequest *IBrevisRequestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisRequest.Contract.IBrevisRequestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisRequest *IBrevisRequestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.IBrevisRequestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisRequest *IBrevisRequestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.IBrevisRequestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisRequest *IBrevisRequestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisRequest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisRequest *IBrevisRequestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisRequest *IBrevisRequestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.contract.Transact(opts, method, params...)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCaller) ValidateOpAppData(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	var out []interface{}
	err := _IBrevisRequest.contract.Call(opts, &out, "validateOpAppData", _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_IBrevisRequest *IBrevisRequestSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData(&_IBrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0xa66f7917.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCallerSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData(&_IBrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow)
}

// IDynamicFeeManagerMetaData contains all meta data concerning the IDynamicFeeManager contract.
var IDynamicFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IDynamicFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IDynamicFeeManagerMetaData.ABI instead.
var IDynamicFeeManagerABI = IDynamicFeeManagerMetaData.ABI

// IDynamicFeeManager is an auto generated Go binding around an Ethereum contract.
type IDynamicFeeManager struct {
	IDynamicFeeManagerCaller     // Read-only binding to the contract
	IDynamicFeeManagerTransactor // Write-only binding to the contract
	IDynamicFeeManagerFilterer   // Log filterer for contract events
}

// IDynamicFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IDynamicFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IDynamicFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IDynamicFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IDynamicFeeManagerSession struct {
	Contract     *IDynamicFeeManager // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IDynamicFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IDynamicFeeManagerCallerSession struct {
	Contract *IDynamicFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// IDynamicFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IDynamicFeeManagerTransactorSession struct {
	Contract     *IDynamicFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// IDynamicFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IDynamicFeeManagerRaw struct {
	Contract *IDynamicFeeManager // Generic contract binding to access the raw methods on
}

// IDynamicFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IDynamicFeeManagerCallerRaw struct {
	Contract *IDynamicFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IDynamicFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IDynamicFeeManagerTransactorRaw struct {
	Contract *IDynamicFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIDynamicFeeManager creates a new instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManager(address common.Address, backend bind.ContractBackend) (*IDynamicFeeManager, error) {
	contract, err := bindIDynamicFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManager{IDynamicFeeManagerCaller: IDynamicFeeManagerCaller{contract: contract}, IDynamicFeeManagerTransactor: IDynamicFeeManagerTransactor{contract: contract}, IDynamicFeeManagerFilterer: IDynamicFeeManagerFilterer{contract: contract}}, nil
}

// NewIDynamicFeeManagerCaller creates a new read-only instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*IDynamicFeeManagerCaller, error) {
	contract, err := bindIDynamicFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerCaller{contract: contract}, nil
}

// NewIDynamicFeeManagerTransactor creates a new write-only instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IDynamicFeeManagerTransactor, error) {
	contract, err := bindIDynamicFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerTransactor{contract: contract}, nil
}

// NewIDynamicFeeManagerFilterer creates a new log filterer instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IDynamicFeeManagerFilterer, error) {
	contract, err := bindIDynamicFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerFilterer{contract: contract}, nil
}

// bindIDynamicFeeManager binds a generic wrapper to an already deployed contract.
func bindIDynamicFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IDynamicFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDynamicFeeManager *IDynamicFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDynamicFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerTransactor) GetFee(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.contract.Transact(opts, "getFee", sender, key, params, data)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerSession) GetFee(sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.GetFee(&_IDynamicFeeManager.TransactOpts, sender, key, params, data)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorSession) GetFee(sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.GetFee(&_IDynamicFeeManager.TransactOpts, sender, key, params, data)
}

// IERC1155MetaData contains all meta data concerning the IERC1155 contract.
var IERC1155MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IERC1155ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC1155MetaData.ABI instead.
var IERC1155ABI = IERC1155MetaData.ABI

// IERC1155 is an auto generated Go binding around an Ethereum contract.
type IERC1155 struct {
	IERC1155Caller     // Read-only binding to the contract
	IERC1155Transactor // Write-only binding to the contract
	IERC1155Filterer   // Log filterer for contract events
}

// IERC1155Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC1155Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC1155Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC1155Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC1155Session struct {
	Contract     *IERC1155         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC1155CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC1155CallerSession struct {
	Contract *IERC1155Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IERC1155TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC1155TransactorSession struct {
	Contract     *IERC1155Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IERC1155Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC1155Raw struct {
	Contract *IERC1155 // Generic contract binding to access the raw methods on
}

// IERC1155CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC1155CallerRaw struct {
	Contract *IERC1155Caller // Generic read-only contract binding to access the raw methods on
}

// IERC1155TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC1155TransactorRaw struct {
	Contract *IERC1155Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC1155 creates a new instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155(address common.Address, backend bind.ContractBackend) (*IERC1155, error) {
	contract, err := bindIERC1155(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC1155{IERC1155Caller: IERC1155Caller{contract: contract}, IERC1155Transactor: IERC1155Transactor{contract: contract}, IERC1155Filterer: IERC1155Filterer{contract: contract}}, nil
}

// NewIERC1155Caller creates a new read-only instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Caller(address common.Address, caller bind.ContractCaller) (*IERC1155Caller, error) {
	contract, err := bindIERC1155(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC1155Caller{contract: contract}, nil
}

// NewIERC1155Transactor creates a new write-only instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC1155Transactor, error) {
	contract, err := bindIERC1155(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC1155Transactor{contract: contract}, nil
}

// NewIERC1155Filterer creates a new log filterer instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC1155Filterer, error) {
	contract, err := bindIERC1155(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC1155Filterer{contract: contract}, nil
}

// bindIERC1155 binds a generic wrapper to an already deployed contract.
func bindIERC1155(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC1155MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC1155 *IERC1155Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC1155.Contract.IERC1155Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC1155 *IERC1155Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC1155.Contract.IERC1155Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC1155 *IERC1155Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC1155.Contract.IERC1155Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC1155 *IERC1155CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC1155.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC1155 *IERC1155TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC1155.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC1155 *IERC1155TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC1155.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155Caller) BalanceOf(opts *bind.CallOpts, account common.Address, id *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "balanceOf", account, id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155Session) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IERC1155.Contract.BalanceOf(&_IERC1155.CallOpts, account, id)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155CallerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IERC1155.Contract.BalanceOf(&_IERC1155.CallOpts, account, id)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155Caller) BalanceOfBatch(opts *bind.CallOpts, accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "balanceOfBatch", accounts, ids)

	if err != nil {
		return *new([]*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)

	return out0, err

}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155Session) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IERC1155.Contract.BalanceOfBatch(&_IERC1155.CallOpts, accounts, ids)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155CallerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IERC1155.Contract.BalanceOfBatch(&_IERC1155.CallOpts, accounts, ids)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155Caller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "isApprovedForAll", account, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155Session) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IERC1155.Contract.IsApprovedForAll(&_IERC1155.CallOpts, account, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155CallerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IERC1155.Contract.IsApprovedForAll(&_IERC1155.CallOpts, account, operator)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC1155.Contract.SupportsInterface(&_IERC1155.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC1155.Contract.SupportsInterface(&_IERC1155.CallOpts, interfaceId)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155Transactor) SafeBatchTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "safeBatchTransferFrom", from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155Session) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeBatchTransferFrom(&_IERC1155.TransactOpts, from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155TransactorSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeBatchTransferFrom(&_IERC1155.TransactOpts, from, to, ids, amounts, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155Transactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "safeTransferFrom", from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155Session) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeTransferFrom(&_IERC1155.TransactOpts, from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155TransactorSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeTransferFrom(&_IERC1155.TransactOpts, from, to, id, amount, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155Transactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155Session) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.Contract.SetApprovalForAll(&_IERC1155.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155TransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.Contract.SetApprovalForAll(&_IERC1155.TransactOpts, operator, approved)
}

// IERC1155ApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IERC1155 contract.
type IERC1155ApprovalForAllIterator struct {
	Event *IERC1155ApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155ApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155ApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155ApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155ApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155ApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155ApprovalForAll represents a ApprovalForAll event raised by the IERC1155 contract.
type IERC1155ApprovalForAll struct {
	Account  common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (*IERC1155ApprovalForAllIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155ApprovalForAllIterator{contract: _IERC1155.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IERC1155ApprovalForAll, account []common.Address, operator []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155ApprovalForAll)
				if err := _IERC1155.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) ParseApprovalForAll(log types.Log) (*IERC1155ApprovalForAll, error) {
	event := new(IERC1155ApprovalForAll)
	if err := _IERC1155.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155TransferBatchIterator is returned from FilterTransferBatch and is used to iterate over the raw logs and unpacked data for TransferBatch events raised by the IERC1155 contract.
type IERC1155TransferBatchIterator struct {
	Event *IERC1155TransferBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155TransferBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155TransferBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155TransferBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155TransferBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155TransferBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155TransferBatch represents a TransferBatch event raised by the IERC1155 contract.
type IERC1155TransferBatch struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Ids      []*big.Int
	Values   []*big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferBatch is a free log retrieval operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IERC1155TransferBatchIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155TransferBatchIterator{contract: _IERC1155.contract, event: "TransferBatch", logs: logs, sub: sub}, nil
}

// WatchTransferBatch is a free log subscription operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *IERC1155TransferBatch, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155TransferBatch)
				if err := _IERC1155.contract.UnpackLog(event, "TransferBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferBatch is a log parse operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) ParseTransferBatch(log types.Log) (*IERC1155TransferBatch, error) {
	event := new(IERC1155TransferBatch)
	if err := _IERC1155.contract.UnpackLog(event, "TransferBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155TransferSingleIterator is returned from FilterTransferSingle and is used to iterate over the raw logs and unpacked data for TransferSingle events raised by the IERC1155 contract.
type IERC1155TransferSingleIterator struct {
	Event *IERC1155TransferSingle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155TransferSingleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155TransferSingle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155TransferSingle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155TransferSingleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155TransferSingleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155TransferSingle represents a TransferSingle event raised by the IERC1155 contract.
type IERC1155TransferSingle struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Id       *big.Int
	Value    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferSingle is a free log retrieval operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IERC1155TransferSingleIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155TransferSingleIterator{contract: _IERC1155.contract, event: "TransferSingle", logs: logs, sub: sub}, nil
}

// WatchTransferSingle is a free log subscription operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *IERC1155TransferSingle, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155TransferSingle)
				if err := _IERC1155.contract.UnpackLog(event, "TransferSingle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferSingle is a log parse operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) ParseTransferSingle(log types.Log) (*IERC1155TransferSingle, error) {
	event := new(IERC1155TransferSingle)
	if err := _IERC1155.contract.UnpackLog(event, "TransferSingle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155URIIterator is returned from FilterURI and is used to iterate over the raw logs and unpacked data for URI events raised by the IERC1155 contract.
type IERC1155URIIterator struct {
	Event *IERC1155URI // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155URIIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155URI)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155URI)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155URIIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155URIIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155URI represents a URI event raised by the IERC1155 contract.
type IERC1155URI struct {
	Value string
	Id    *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterURI is a free log retrieval operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (*IERC1155URIIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155URIIterator{contract: _IERC1155.contract, event: "URI", logs: logs, sub: sub}, nil
}

// WatchURI is a free log subscription operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) WatchURI(opts *bind.WatchOpts, sink chan<- *IERC1155URI, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155URI)
				if err := _IERC1155.contract.UnpackLog(event, "URI", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseURI is a log parse operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) ParseURI(log types.Log) (*IERC1155URI, error) {
	event := new(IERC1155URI)
	if err := _IERC1155.contract.UnpackLog(event, "URI", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC165MetaData contains all meta data concerning the IERC165 contract.
var IERC165MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IERC165ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC165MetaData.ABI instead.
var IERC165ABI = IERC165MetaData.ABI

// IERC165 is an auto generated Go binding around an Ethereum contract.
type IERC165 struct {
	IERC165Caller     // Read-only binding to the contract
	IERC165Transactor // Write-only binding to the contract
	IERC165Filterer   // Log filterer for contract events
}

// IERC165Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC165Session struct {
	Contract     *IERC165          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC165CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC165CallerSession struct {
	Contract *IERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IERC165TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC165TransactorSession struct {
	Contract     *IERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC165Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC165Raw struct {
	Contract *IERC165 // Generic contract binding to access the raw methods on
}

// IERC165CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC165CallerRaw struct {
	Contract *IERC165Caller // Generic read-only contract binding to access the raw methods on
}

// IERC165TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC165TransactorRaw struct {
	Contract *IERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC165 creates a new instance of IERC165, bound to a specific deployed contract.
func NewIERC165(address common.Address, backend bind.ContractBackend) (*IERC165, error) {
	contract, err := bindIERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC165{IERC165Caller: IERC165Caller{contract: contract}, IERC165Transactor: IERC165Transactor{contract: contract}, IERC165Filterer: IERC165Filterer{contract: contract}}, nil
}

// NewIERC165Caller creates a new read-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Caller(address common.Address, caller bind.ContractCaller) (*IERC165Caller, error) {
	contract, err := bindIERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Caller{contract: contract}, nil
}

// NewIERC165Transactor creates a new write-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC165Transactor, error) {
	contract, err := bindIERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Transactor{contract: contract}, nil
}

// NewIERC165Filterer creates a new log filterer instance of IERC165, bound to a specific deployed contract.
func NewIERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC165Filterer, error) {
	contract, err := bindIERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC165Filterer{contract: contract}, nil
}

// bindIERC165 binds a generic wrapper to an already deployed contract.
func bindIERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC165MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.IERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IERC165.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// IERC20MetaData contains all meta data concerning the IERC20 contract.
var IERC20MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetaData.ABI instead.
var IERC20ABI = IERC20MetaData.ABI

// IERC20 is an auto generated Go binding around an Ethereum contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataMetaData contains all meta data concerning the IERC20Metadata contract.
var IERC20MetadataMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20MetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetadataMetaData.ABI instead.
var IERC20MetadataABI = IERC20MetadataMetaData.ABI

// IERC20Metadata is an auto generated Go binding around an Ethereum contract.
type IERC20Metadata struct {
	IERC20MetadataCaller     // Read-only binding to the contract
	IERC20MetadataTransactor // Write-only binding to the contract
	IERC20MetadataFilterer   // Log filterer for contract events
}

// IERC20MetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MetadataSession struct {
	Contract     *IERC20Metadata   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MetadataCallerSession struct {
	Contract *IERC20MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IERC20MetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MetadataTransactorSession struct {
	Contract     *IERC20MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IERC20MetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MetadataRaw struct {
	Contract *IERC20Metadata // Generic contract binding to access the raw methods on
}

// IERC20MetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MetadataCallerRaw struct {
	Contract *IERC20MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactorRaw struct {
	Contract *IERC20MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Metadata creates a new instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20Metadata(address common.Address, backend bind.ContractBackend) (*IERC20Metadata, error) {
	contract, err := bindIERC20Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Metadata{IERC20MetadataCaller: IERC20MetadataCaller{contract: contract}, IERC20MetadataTransactor: IERC20MetadataTransactor{contract: contract}, IERC20MetadataFilterer: IERC20MetadataFilterer{contract: contract}}, nil
}

// NewIERC20MetadataCaller creates a new read-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataCaller(address common.Address, caller bind.ContractCaller) (*IERC20MetadataCaller, error) {
	contract, err := bindIERC20Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataCaller{contract: contract}, nil
}

// NewIERC20MetadataTransactor creates a new write-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MetadataTransactor, error) {
	contract, err := bindIERC20Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransactor{contract: contract}, nil
}

// NewIERC20MetadataFilterer creates a new log filterer instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MetadataFilterer, error) {
	contract, err := bindIERC20Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataFilterer{contract: contract}, nil
}

// bindIERC20Metadata binds a generic wrapper to an already deployed contract.
func bindIERC20Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.IERC20MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCallerSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// IERC20MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Metadata contract.
type IERC20MetadataApprovalIterator struct {
	Event *IERC20MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataApproval represents a Approval event raised by the IERC20Metadata contract.
type IERC20MetadataApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MetadataApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataApprovalIterator{contract: _IERC20Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MetadataApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataApproval)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseApproval(log types.Log) (*IERC20MetadataApproval, error) {
	event := new(IERC20MetadataApproval)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Metadata contract.
type IERC20MetadataTransferIterator struct {
	Event *IERC20MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataTransfer represents a Transfer event raised by the IERC20Metadata contract.
type IERC20MetadataTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MetadataTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransferIterator{contract: _IERC20Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MetadataTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataTransfer)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseTransfer(log types.Log) (*IERC20MetadataTransfer, error) {
	event := new(IERC20MetadataTransfer)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MinimalMetaData contains all meta data concerning the IERC20Minimal contract.
var IERC20MinimalMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20MinimalABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MinimalMetaData.ABI instead.
var IERC20MinimalABI = IERC20MinimalMetaData.ABI

// IERC20Minimal is an auto generated Go binding around an Ethereum contract.
type IERC20Minimal struct {
	IERC20MinimalCaller     // Read-only binding to the contract
	IERC20MinimalTransactor // Write-only binding to the contract
	IERC20MinimalFilterer   // Log filterer for contract events
}

// IERC20MinimalCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MinimalCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MinimalTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MinimalFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MinimalSession struct {
	Contract     *IERC20Minimal    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MinimalCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MinimalCallerSession struct {
	Contract *IERC20MinimalCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// IERC20MinimalTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MinimalTransactorSession struct {
	Contract     *IERC20MinimalTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// IERC20MinimalRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MinimalRaw struct {
	Contract *IERC20Minimal // Generic contract binding to access the raw methods on
}

// IERC20MinimalCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MinimalCallerRaw struct {
	Contract *IERC20MinimalCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MinimalTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MinimalTransactorRaw struct {
	Contract *IERC20MinimalTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Minimal creates a new instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20Minimal(address common.Address, backend bind.ContractBackend) (*IERC20Minimal, error) {
	contract, err := bindIERC20Minimal(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Minimal{IERC20MinimalCaller: IERC20MinimalCaller{contract: contract}, IERC20MinimalTransactor: IERC20MinimalTransactor{contract: contract}, IERC20MinimalFilterer: IERC20MinimalFilterer{contract: contract}}, nil
}

// NewIERC20MinimalCaller creates a new read-only instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalCaller(address common.Address, caller bind.ContractCaller) (*IERC20MinimalCaller, error) {
	contract, err := bindIERC20Minimal(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalCaller{contract: contract}, nil
}

// NewIERC20MinimalTransactor creates a new write-only instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MinimalTransactor, error) {
	contract, err := bindIERC20Minimal(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalTransactor{contract: contract}, nil
}

// NewIERC20MinimalFilterer creates a new log filterer instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MinimalFilterer, error) {
	contract, err := bindIERC20Minimal(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalFilterer{contract: contract}, nil
}

// bindIERC20Minimal binds a generic wrapper to an already deployed contract.
func bindIERC20Minimal(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MinimalMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Minimal *IERC20MinimalRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Minimal.Contract.IERC20MinimalCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Minimal *IERC20MinimalRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.IERC20MinimalTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Minimal *IERC20MinimalRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.IERC20MinimalTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Minimal *IERC20MinimalCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Minimal.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Minimal *IERC20MinimalTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Minimal *IERC20MinimalTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Minimal.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.Allowance(&_IERC20Minimal.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.Allowance(&_IERC20Minimal.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Minimal.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.BalanceOf(&_IERC20Minimal.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.BalanceOf(&_IERC20Minimal.CallOpts, account)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Approve(&_IERC20Minimal.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Approve(&_IERC20Minimal.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) Transfer(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "transfer", recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Transfer(&_IERC20Minimal.TransactOpts, recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Transfer(&_IERC20Minimal.TransactOpts, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) TransferFrom(opts *bind.TransactOpts, sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "transferFrom", sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.TransferFrom(&_IERC20Minimal.TransactOpts, sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.TransferFrom(&_IERC20Minimal.TransactOpts, sender, recipient, amount)
}

// IERC20MinimalApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Minimal contract.
type IERC20MinimalApprovalIterator struct {
	Event *IERC20MinimalApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MinimalApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MinimalApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MinimalApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MinimalApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MinimalApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MinimalApproval represents a Approval event raised by the IERC20Minimal contract.
type IERC20MinimalApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MinimalApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Minimal.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalApprovalIterator{contract: _IERC20Minimal.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MinimalApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Minimal.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MinimalApproval)
				if err := _IERC20Minimal.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) ParseApproval(log types.Log) (*IERC20MinimalApproval, error) {
	event := new(IERC20MinimalApproval)
	if err := _IERC20Minimal.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MinimalTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Minimal contract.
type IERC20MinimalTransferIterator struct {
	Event *IERC20MinimalTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MinimalTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MinimalTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MinimalTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MinimalTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MinimalTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MinimalTransfer represents a Transfer event raised by the IERC20Minimal contract.
type IERC20MinimalTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MinimalTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Minimal.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalTransferIterator{contract: _IERC20Minimal.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MinimalTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Minimal.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MinimalTransfer)
				if err := _IERC20Minimal.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) ParseTransfer(log types.Log) (*IERC20MinimalTransfer, error) {
	event := new(IERC20MinimalTransfer)
	if err := _IERC20Minimal.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthereumLightClientMetaData contains all meta data concerning the IEthereumLightClient contract.
var IEthereumLightClientMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"finalizedExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IEthereumLightClientABI is the input ABI used to generate the binding from.
// Deprecated: Use IEthereumLightClientMetaData.ABI instead.
var IEthereumLightClientABI = IEthereumLightClientMetaData.ABI

// IEthereumLightClient is an auto generated Go binding around an Ethereum contract.
type IEthereumLightClient struct {
	IEthereumLightClientCaller     // Read-only binding to the contract
	IEthereumLightClientTransactor // Write-only binding to the contract
	IEthereumLightClientFilterer   // Log filterer for contract events
}

// IEthereumLightClientCaller is an auto generated read-only Go binding around an Ethereum contract.
type IEthereumLightClientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IEthereumLightClientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IEthereumLightClientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IEthereumLightClientSession struct {
	Contract     *IEthereumLightClient // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IEthereumLightClientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IEthereumLightClientCallerSession struct {
	Contract *IEthereumLightClientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// IEthereumLightClientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IEthereumLightClientTransactorSession struct {
	Contract     *IEthereumLightClientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// IEthereumLightClientRaw is an auto generated low-level Go binding around an Ethereum contract.
type IEthereumLightClientRaw struct {
	Contract *IEthereumLightClient // Generic contract binding to access the raw methods on
}

// IEthereumLightClientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IEthereumLightClientCallerRaw struct {
	Contract *IEthereumLightClientCaller // Generic read-only contract binding to access the raw methods on
}

// IEthereumLightClientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IEthereumLightClientTransactorRaw struct {
	Contract *IEthereumLightClientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIEthereumLightClient creates a new instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClient(address common.Address, backend bind.ContractBackend) (*IEthereumLightClient, error) {
	contract, err := bindIEthereumLightClient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClient{IEthereumLightClientCaller: IEthereumLightClientCaller{contract: contract}, IEthereumLightClientTransactor: IEthereumLightClientTransactor{contract: contract}, IEthereumLightClientFilterer: IEthereumLightClientFilterer{contract: contract}}, nil
}

// NewIEthereumLightClientCaller creates a new read-only instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientCaller(address common.Address, caller bind.ContractCaller) (*IEthereumLightClientCaller, error) {
	contract, err := bindIEthereumLightClient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientCaller{contract: contract}, nil
}

// NewIEthereumLightClientTransactor creates a new write-only instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientTransactor(address common.Address, transactor bind.ContractTransactor) (*IEthereumLightClientTransactor, error) {
	contract, err := bindIEthereumLightClient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientTransactor{contract: contract}, nil
}

// NewIEthereumLightClientFilterer creates a new log filterer instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientFilterer(address common.Address, filterer bind.ContractFilterer) (*IEthereumLightClientFilterer, error) {
	contract, err := bindIEthereumLightClient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientFilterer{contract: contract}, nil
}

// bindIEthereumLightClient binds a generic wrapper to an already deployed contract.
func bindIEthereumLightClient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IEthereumLightClientMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthereumLightClient *IEthereumLightClientRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthereumLightClient.Contract.IEthereumLightClientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthereumLightClient *IEthereumLightClientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.IEthereumLightClientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthereumLightClient *IEthereumLightClientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.IEthereumLightClientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthereumLightClient *IEthereumLightClientCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthereumLightClient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthereumLightClient *IEthereumLightClientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthereumLightClient *IEthereumLightClientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.contract.Transact(opts, method, params...)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCaller) FinalizedExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IEthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCallerSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCaller) OptimisticExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IEthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCallerSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// IFeesMetaData contains all meta data concerning the IFees contract.
var IFeesMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeCannotBeFetched\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeController\",\"type\":\"address\"}],\"name\":\"ProtocolFeeControllerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hookFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protocolFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IFeesABI is the input ABI used to generate the binding from.
// Deprecated: Use IFeesMetaData.ABI instead.
var IFeesABI = IFeesMetaData.ABI

// IFees is an auto generated Go binding around an Ethereum contract.
type IFees struct {
	IFeesCaller     // Read-only binding to the contract
	IFeesTransactor // Write-only binding to the contract
	IFeesFilterer   // Log filterer for contract events
}

// IFeesCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFeesCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFeesTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFeesFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFeesSession struct {
	Contract     *IFees            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeesCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFeesCallerSession struct {
	Contract *IFeesCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IFeesTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFeesTransactorSession struct {
	Contract     *IFeesTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeesRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFeesRaw struct {
	Contract *IFees // Generic contract binding to access the raw methods on
}

// IFeesCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFeesCallerRaw struct {
	Contract *IFeesCaller // Generic read-only contract binding to access the raw methods on
}

// IFeesTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFeesTransactorRaw struct {
	Contract *IFeesTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFees creates a new instance of IFees, bound to a specific deployed contract.
func NewIFees(address common.Address, backend bind.ContractBackend) (*IFees, error) {
	contract, err := bindIFees(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFees{IFeesCaller: IFeesCaller{contract: contract}, IFeesTransactor: IFeesTransactor{contract: contract}, IFeesFilterer: IFeesFilterer{contract: contract}}, nil
}

// NewIFeesCaller creates a new read-only instance of IFees, bound to a specific deployed contract.
func NewIFeesCaller(address common.Address, caller bind.ContractCaller) (*IFeesCaller, error) {
	contract, err := bindIFees(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFeesCaller{contract: contract}, nil
}

// NewIFeesTransactor creates a new write-only instance of IFees, bound to a specific deployed contract.
func NewIFeesTransactor(address common.Address, transactor bind.ContractTransactor) (*IFeesTransactor, error) {
	contract, err := bindIFees(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFeesTransactor{contract: contract}, nil
}

// NewIFeesFilterer creates a new log filterer instance of IFees, bound to a specific deployed contract.
func NewIFeesFilterer(address common.Address, filterer bind.ContractFilterer) (*IFeesFilterer, error) {
	contract, err := bindIFees(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFeesFilterer{contract: contract}, nil
}

// bindIFees binds a generic wrapper to an already deployed contract.
func bindIFees(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IFeesMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFees *IFeesRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFees.Contract.IFeesCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFees *IFeesRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFees.Contract.IFeesTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFees *IFeesRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFees.Contract.IFeesTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFees *IFeesCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFees.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFees *IFeesTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFees.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFees *IFeesTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFees.Contract.contract.Transact(opts, method, params...)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesCaller) MINPROTOCOLFEEDENOMINATOR(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "MIN_PROTOCOL_FEE_DENOMINATOR")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IFees.Contract.MINPROTOCOLFEEDENOMINATOR(&_IFees.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesCallerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IFees.Contract.MINPROTOCOLFEEDENOMINATOR(&_IFees.CallOpts)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesCaller) HookFeesAccrued(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "hookFeesAccrued", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IFees.Contract.HookFeesAccrued(&_IFees.CallOpts, arg0, arg1)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesCallerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IFees.Contract.HookFeesAccrued(&_IFees.CallOpts, arg0, arg1)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesCaller) ProtocolFeesAccrued(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "protocolFeesAccrued", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IFees.Contract.ProtocolFeesAccrued(&_IFees.CallOpts, arg0)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesCallerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IFees.Contract.ProtocolFeesAccrued(&_IFees.CallOpts, arg0)
}

// IFeesProtocolFeeControllerUpdatedIterator is returned from FilterProtocolFeeControllerUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeControllerUpdated events raised by the IFees contract.
type IFeesProtocolFeeControllerUpdatedIterator struct {
	Event *IFeesProtocolFeeControllerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFeesProtocolFeeControllerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFeesProtocolFeeControllerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFeesProtocolFeeControllerUpdated represents a ProtocolFeeControllerUpdated event raised by the IFees contract.
type IFeesProtocolFeeControllerUpdated struct {
	ProtocolFeeController common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeControllerUpdated is a free log retrieval operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) FilterProtocolFeeControllerUpdated(opts *bind.FilterOpts) (*IFeesProtocolFeeControllerUpdatedIterator, error) {

	logs, sub, err := _IFees.contract.FilterLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return &IFeesProtocolFeeControllerUpdatedIterator{contract: _IFees.contract, event: "ProtocolFeeControllerUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeControllerUpdated is a free log subscription operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) WatchProtocolFeeControllerUpdated(opts *bind.WatchOpts, sink chan<- *IFeesProtocolFeeControllerUpdated) (event.Subscription, error) {

	logs, sub, err := _IFees.contract.WatchLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFeesProtocolFeeControllerUpdated)
				if err := _IFees.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeControllerUpdated is a log parse operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) ParseProtocolFeeControllerUpdated(log types.Log) (*IFeesProtocolFeeControllerUpdated, error) {
	event := new(IFeesProtocolFeeControllerUpdated)
	if err := _IFees.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IHookFeeManagerMetaData contains all meta data concerning the IHookFeeManager contract.
var IHookFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"getHookFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IHookFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IHookFeeManagerMetaData.ABI instead.
var IHookFeeManagerABI = IHookFeeManagerMetaData.ABI

// IHookFeeManager is an auto generated Go binding around an Ethereum contract.
type IHookFeeManager struct {
	IHookFeeManagerCaller     // Read-only binding to the contract
	IHookFeeManagerTransactor // Write-only binding to the contract
	IHookFeeManagerFilterer   // Log filterer for contract events
}

// IHookFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IHookFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IHookFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IHookFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IHookFeeManagerSession struct {
	Contract     *IHookFeeManager  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHookFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IHookFeeManagerCallerSession struct {
	Contract *IHookFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IHookFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IHookFeeManagerTransactorSession struct {
	Contract     *IHookFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IHookFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IHookFeeManagerRaw struct {
	Contract *IHookFeeManager // Generic contract binding to access the raw methods on
}

// IHookFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IHookFeeManagerCallerRaw struct {
	Contract *IHookFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IHookFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IHookFeeManagerTransactorRaw struct {
	Contract *IHookFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIHookFeeManager creates a new instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManager(address common.Address, backend bind.ContractBackend) (*IHookFeeManager, error) {
	contract, err := bindIHookFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManager{IHookFeeManagerCaller: IHookFeeManagerCaller{contract: contract}, IHookFeeManagerTransactor: IHookFeeManagerTransactor{contract: contract}, IHookFeeManagerFilterer: IHookFeeManagerFilterer{contract: contract}}, nil
}

// NewIHookFeeManagerCaller creates a new read-only instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*IHookFeeManagerCaller, error) {
	contract, err := bindIHookFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerCaller{contract: contract}, nil
}

// NewIHookFeeManagerTransactor creates a new write-only instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IHookFeeManagerTransactor, error) {
	contract, err := bindIHookFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerTransactor{contract: contract}, nil
}

// NewIHookFeeManagerFilterer creates a new log filterer instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IHookFeeManagerFilterer, error) {
	contract, err := bindIHookFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerFilterer{contract: contract}, nil
}

// bindIHookFeeManager binds a generic wrapper to an already deployed contract.
func bindIHookFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IHookFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHookFeeManager *IHookFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHookFeeManager.Contract.IHookFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHookFeeManager *IHookFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.IHookFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHookFeeManager *IHookFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.IHookFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHookFeeManager *IHookFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHookFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHookFeeManager *IHookFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHookFeeManager *IHookFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerCaller) GetHookFees(opts *bind.CallOpts, key PoolKey) (*big.Int, error) {
	var out []interface{}
	err := _IHookFeeManager.contract.Call(opts, &out, "getHookFees", key)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerSession) GetHookFees(key PoolKey) (*big.Int, error) {
	return _IHookFeeManager.Contract.GetHookFees(&_IHookFeeManager.CallOpts, key)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerCallerSession) GetHookFees(key PoolKey) (*big.Int, error) {
	return _IHookFeeManager.Contract.GetHookFees(&_IHookFeeManager.CallOpts, key)
}

// IHooksMetaData contains all meta data concerning the IHooks contract.
var IHooksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IHooksABI is the input ABI used to generate the binding from.
// Deprecated: Use IHooksMetaData.ABI instead.
var IHooksABI = IHooksMetaData.ABI

// IHooks is an auto generated Go binding around an Ethereum contract.
type IHooks struct {
	IHooksCaller     // Read-only binding to the contract
	IHooksTransactor // Write-only binding to the contract
	IHooksFilterer   // Log filterer for contract events
}

// IHooksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IHooksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IHooksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IHooksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IHooksSession struct {
	Contract     *IHooks           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHooksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IHooksCallerSession struct {
	Contract *IHooksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IHooksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IHooksTransactorSession struct {
	Contract     *IHooksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHooksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IHooksRaw struct {
	Contract *IHooks // Generic contract binding to access the raw methods on
}

// IHooksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IHooksCallerRaw struct {
	Contract *IHooksCaller // Generic read-only contract binding to access the raw methods on
}

// IHooksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IHooksTransactorRaw struct {
	Contract *IHooksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIHooks creates a new instance of IHooks, bound to a specific deployed contract.
func NewIHooks(address common.Address, backend bind.ContractBackend) (*IHooks, error) {
	contract, err := bindIHooks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IHooks{IHooksCaller: IHooksCaller{contract: contract}, IHooksTransactor: IHooksTransactor{contract: contract}, IHooksFilterer: IHooksFilterer{contract: contract}}, nil
}

// NewIHooksCaller creates a new read-only instance of IHooks, bound to a specific deployed contract.
func NewIHooksCaller(address common.Address, caller bind.ContractCaller) (*IHooksCaller, error) {
	contract, err := bindIHooks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IHooksCaller{contract: contract}, nil
}

// NewIHooksTransactor creates a new write-only instance of IHooks, bound to a specific deployed contract.
func NewIHooksTransactor(address common.Address, transactor bind.ContractTransactor) (*IHooksTransactor, error) {
	contract, err := bindIHooks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IHooksTransactor{contract: contract}, nil
}

// NewIHooksFilterer creates a new log filterer instance of IHooks, bound to a specific deployed contract.
func NewIHooksFilterer(address common.Address, filterer bind.ContractFilterer) (*IHooksFilterer, error) {
	contract, err := bindIHooks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IHooksFilterer{contract: contract}, nil
}

// bindIHooks binds a generic wrapper to an already deployed contract.
func bindIHooks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IHooksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHooks *IHooksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHooks.Contract.IHooksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHooks *IHooksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHooks.Contract.IHooksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHooks *IHooksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHooks.Contract.IHooksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHooks *IHooksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHooks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHooks *IHooksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHooks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHooks *IHooksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHooks.Contract.contract.Transact(opts, method, params...)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterDonate(opts *bind.TransactOpts, sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterDonate", sender, key, amount0, amount1, hookData)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterInitialize(opts *bind.TransactOpts, sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterInitialize", sender, key, sqrtPriceX96, tick, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, tick, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, tick, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterModifyPosition(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterModifyPosition", sender, key, params, delta, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterModifyPosition(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterModifyPosition(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterSwap(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterSwap", sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterSwap(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterSwap(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeDonate(opts *bind.TransactOpts, sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeDonate", sender, key, amount0, amount1, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeInitialize(opts *bind.TransactOpts, sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeInitialize", sender, key, sqrtPriceX96, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeModifyPosition(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeModifyPosition", sender, key, params, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeModifyPosition(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeModifyPosition(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeSwap(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeSwap", sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeSwap(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeSwap(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// IMessageBridgeMetaData contains all meta data concerning the IMessageBridge contract.
var IMessageBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"MessageCallReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MessageExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"accountProof\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"storageProof\",\"type\":\"bytes[]\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"lightClients\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IMessageBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use IMessageBridgeMetaData.ABI instead.
var IMessageBridgeABI = IMessageBridgeMetaData.ABI

// IMessageBridge is an auto generated Go binding around an Ethereum contract.
type IMessageBridge struct {
	IMessageBridgeCaller     // Read-only binding to the contract
	IMessageBridgeTransactor // Write-only binding to the contract
	IMessageBridgeFilterer   // Log filterer for contract events
}

// IMessageBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IMessageBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IMessageBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IMessageBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IMessageBridgeSession struct {
	Contract     *IMessageBridge   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IMessageBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IMessageBridgeCallerSession struct {
	Contract *IMessageBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IMessageBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IMessageBridgeTransactorSession struct {
	Contract     *IMessageBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IMessageBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IMessageBridgeRaw struct {
	Contract *IMessageBridge // Generic contract binding to access the raw methods on
}

// IMessageBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IMessageBridgeCallerRaw struct {
	Contract *IMessageBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// IMessageBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IMessageBridgeTransactorRaw struct {
	Contract *IMessageBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIMessageBridge creates a new instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridge(address common.Address, backend bind.ContractBackend) (*IMessageBridge, error) {
	contract, err := bindIMessageBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IMessageBridge{IMessageBridgeCaller: IMessageBridgeCaller{contract: contract}, IMessageBridgeTransactor: IMessageBridgeTransactor{contract: contract}, IMessageBridgeFilterer: IMessageBridgeFilterer{contract: contract}}, nil
}

// NewIMessageBridgeCaller creates a new read-only instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeCaller(address common.Address, caller bind.ContractCaller) (*IMessageBridgeCaller, error) {
	contract, err := bindIMessageBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeCaller{contract: contract}, nil
}

// NewIMessageBridgeTransactor creates a new write-only instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*IMessageBridgeTransactor, error) {
	contract, err := bindIMessageBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeTransactor{contract: contract}, nil
}

// NewIMessageBridgeFilterer creates a new log filterer instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*IMessageBridgeFilterer, error) {
	contract, err := bindIMessageBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeFilterer{contract: contract}, nil
}

// bindIMessageBridge binds a generic wrapper to an already deployed contract.
func bindIMessageBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IMessageBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageBridge *IMessageBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageBridge.Contract.IMessageBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageBridge *IMessageBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageBridge.Contract.IMessageBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageBridge *IMessageBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageBridge.Contract.IMessageBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageBridge *IMessageBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageBridge *IMessageBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageBridge *IMessageBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageBridge.Contract.contract.Transact(opts, method, params...)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeCaller) GetExecutionStateRootAndSlot(opts *bind.CallOpts, chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IMessageBridge.contract.Call(opts, &out, "getExecutionStateRootAndSlot", chainId)

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeSession) GetExecutionStateRootAndSlot(chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IMessageBridge.Contract.GetExecutionStateRootAndSlot(&_IMessageBridge.CallOpts, chainId)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeCallerSession) GetExecutionStateRootAndSlot(chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IMessageBridge.Contract.GetExecutionStateRootAndSlot(&_IMessageBridge.CallOpts, chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeCaller) LightClients(opts *bind.CallOpts, chainId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _IMessageBridge.contract.Call(opts, &out, "lightClients", chainId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeSession) LightClients(chainId *big.Int) (common.Address, error) {
	return _IMessageBridge.Contract.LightClients(&_IMessageBridge.CallOpts, chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeCallerSession) LightClients(chainId *big.Int) (common.Address, error) {
	return _IMessageBridge.Contract.LightClients(&_IMessageBridge.CallOpts, chainId)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.contract.Transact(opts, "executeMessage", srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeSession) ExecuteMessage(srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.ExecuteMessage(&_IMessageBridge.TransactOpts, srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeTransactorSession) ExecuteMessage(srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.ExecuteMessage(&_IMessageBridge.TransactOpts, srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeTransactor) SendMessage(opts *bind.TransactOpts, dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.contract.Transact(opts, "sendMessage", dstChainId, receiver, message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeSession) SendMessage(dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.SendMessage(&_IMessageBridge.TransactOpts, dstChainId, receiver, message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeTransactorSession) SendMessage(dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.SendMessage(&_IMessageBridge.TransactOpts, dstChainId, receiver, message)
}

// IMessageBridgeMessageCallRevertedIterator is returned from FilterMessageCallReverted and is used to iterate over the raw logs and unpacked data for MessageCallReverted events raised by the IMessageBridge contract.
type IMessageBridgeMessageCallRevertedIterator struct {
	Event *IMessageBridgeMessageCallReverted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageCallRevertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageCallReverted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageCallReverted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageCallRevertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageCallRevertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageCallReverted represents a MessageCallReverted event raised by the IMessageBridge contract.
type IMessageBridgeMessageCallReverted struct {
	MessageId [32]byte
	Reason    string
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMessageCallReverted is a free log retrieval operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageCallReverted(opts *bind.FilterOpts) (*IMessageBridgeMessageCallRevertedIterator, error) {

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageCallRevertedIterator{contract: _IMessageBridge.contract, event: "MessageCallReverted", logs: logs, sub: sub}, nil
}

// WatchMessageCallReverted is a free log subscription operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageCallReverted(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageCallReverted) (event.Subscription, error) {

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageCallReverted)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageCallReverted is a log parse operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageCallReverted(log types.Log) (*IMessageBridgeMessageCallReverted, error) {
	event := new(IMessageBridgeMessageCallReverted)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageBridgeMessageExecutedIterator is returned from FilterMessageExecuted and is used to iterate over the raw logs and unpacked data for MessageExecuted events raised by the IMessageBridge contract.
type IMessageBridgeMessageExecutedIterator struct {
	Event *IMessageBridgeMessageExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageExecuted represents a MessageExecuted event raised by the IMessageBridge contract.
type IMessageBridgeMessageExecuted struct {
	MessageId  [32]byte
	Nonce      *big.Int
	SrcChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Success    bool
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageExecuted is a free log retrieval operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageExecuted(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*IMessageBridgeMessageExecutedIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageExecutedIterator{contract: _IMessageBridge.contract, event: "MessageExecuted", logs: logs, sub: sub}, nil
}

// WatchMessageExecuted is a free log subscription operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageExecuted(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageExecuted, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageExecuted)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageExecuted is a log parse operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageExecuted(log types.Log) (*IMessageBridgeMessageExecuted, error) {
	event := new(IMessageBridgeMessageExecuted)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageBridgeMessageSentIterator is returned from FilterMessageSent and is used to iterate over the raw logs and unpacked data for MessageSent events raised by the IMessageBridge contract.
type IMessageBridgeMessageSentIterator struct {
	Event *IMessageBridgeMessageSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageSent represents a MessageSent event raised by the IMessageBridge contract.
type IMessageBridgeMessageSent struct {
	MessageId  [32]byte
	Nonce      *big.Int
	DstChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageSent is a free log retrieval operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageSent(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*IMessageBridgeMessageSentIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageSentIterator{contract: _IMessageBridge.contract, event: "MessageSent", logs: logs, sub: sub}, nil
}

// WatchMessageSent is a free log subscription operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageSent(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageSent, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageSent)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageSent is a log parse operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageSent(log types.Log) (*IMessageBridgeMessageSent, error) {
	event := new(IMessageBridgeMessageSent)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageReceiverAppMetaData contains all meta data concerning the IMessageReceiverApp contract.
var IMessageReceiverAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IMessageReceiverAppABI is the input ABI used to generate the binding from.
// Deprecated: Use IMessageReceiverAppMetaData.ABI instead.
var IMessageReceiverAppABI = IMessageReceiverAppMetaData.ABI

// IMessageReceiverApp is an auto generated Go binding around an Ethereum contract.
type IMessageReceiverApp struct {
	IMessageReceiverAppCaller     // Read-only binding to the contract
	IMessageReceiverAppTransactor // Write-only binding to the contract
	IMessageReceiverAppFilterer   // Log filterer for contract events
}

// IMessageReceiverAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type IMessageReceiverAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IMessageReceiverAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IMessageReceiverAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IMessageReceiverAppSession struct {
	Contract     *IMessageReceiverApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IMessageReceiverAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IMessageReceiverAppCallerSession struct {
	Contract *IMessageReceiverAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// IMessageReceiverAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IMessageReceiverAppTransactorSession struct {
	Contract     *IMessageReceiverAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// IMessageReceiverAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type IMessageReceiverAppRaw struct {
	Contract *IMessageReceiverApp // Generic contract binding to access the raw methods on
}

// IMessageReceiverAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IMessageReceiverAppCallerRaw struct {
	Contract *IMessageReceiverAppCaller // Generic read-only contract binding to access the raw methods on
}

// IMessageReceiverAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IMessageReceiverAppTransactorRaw struct {
	Contract *IMessageReceiverAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIMessageReceiverApp creates a new instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverApp(address common.Address, backend bind.ContractBackend) (*IMessageReceiverApp, error) {
	contract, err := bindIMessageReceiverApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverApp{IMessageReceiverAppCaller: IMessageReceiverAppCaller{contract: contract}, IMessageReceiverAppTransactor: IMessageReceiverAppTransactor{contract: contract}, IMessageReceiverAppFilterer: IMessageReceiverAppFilterer{contract: contract}}, nil
}

// NewIMessageReceiverAppCaller creates a new read-only instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppCaller(address common.Address, caller bind.ContractCaller) (*IMessageReceiverAppCaller, error) {
	contract, err := bindIMessageReceiverApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppCaller{contract: contract}, nil
}

// NewIMessageReceiverAppTransactor creates a new write-only instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppTransactor(address common.Address, transactor bind.ContractTransactor) (*IMessageReceiverAppTransactor, error) {
	contract, err := bindIMessageReceiverApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppTransactor{contract: contract}, nil
}

// NewIMessageReceiverAppFilterer creates a new log filterer instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppFilterer(address common.Address, filterer bind.ContractFilterer) (*IMessageReceiverAppFilterer, error) {
	contract, err := bindIMessageReceiverApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppFilterer{contract: contract}, nil
}

// bindIMessageReceiverApp binds a generic wrapper to an already deployed contract.
func bindIMessageReceiverApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IMessageReceiverAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageReceiverApp *IMessageReceiverAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageReceiverApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageReceiverApp *IMessageReceiverAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageReceiverApp *IMessageReceiverAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.contract.Transact(opts, method, params...)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppTransactor) ExecuteMessage(opts *bind.TransactOpts, _srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.contract.Transact(opts, "executeMessage", _srcChainId, _sender, _message, _executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppSession) ExecuteMessage(_srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.ExecuteMessage(&_IMessageReceiverApp.TransactOpts, _srcChainId, _sender, _message, _executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppTransactorSession) ExecuteMessage(_srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.ExecuteMessage(&_IMessageReceiverApp.TransactOpts, _srcChainId, _sender, _message, _executor)
}

// IPeggedTokenMetaData contains all meta data concerning the IPeggedToken contract.
var IPeggedTokenMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IPeggedTokenABI is the input ABI used to generate the binding from.
// Deprecated: Use IPeggedTokenMetaData.ABI instead.
var IPeggedTokenABI = IPeggedTokenMetaData.ABI

// IPeggedToken is an auto generated Go binding around an Ethereum contract.
type IPeggedToken struct {
	IPeggedTokenCaller     // Read-only binding to the contract
	IPeggedTokenTransactor // Write-only binding to the contract
	IPeggedTokenFilterer   // Log filterer for contract events
}

// IPeggedTokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPeggedTokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPeggedTokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPeggedTokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPeggedTokenSession struct {
	Contract     *IPeggedToken     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPeggedTokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPeggedTokenCallerSession struct {
	Contract *IPeggedTokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IPeggedTokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPeggedTokenTransactorSession struct {
	Contract     *IPeggedTokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IPeggedTokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPeggedTokenRaw struct {
	Contract *IPeggedToken // Generic contract binding to access the raw methods on
}

// IPeggedTokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPeggedTokenCallerRaw struct {
	Contract *IPeggedTokenCaller // Generic read-only contract binding to access the raw methods on
}

// IPeggedTokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPeggedTokenTransactorRaw struct {
	Contract *IPeggedTokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPeggedToken creates a new instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedToken(address common.Address, backend bind.ContractBackend) (*IPeggedToken, error) {
	contract, err := bindIPeggedToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPeggedToken{IPeggedTokenCaller: IPeggedTokenCaller{contract: contract}, IPeggedTokenTransactor: IPeggedTokenTransactor{contract: contract}, IPeggedTokenFilterer: IPeggedTokenFilterer{contract: contract}}, nil
}

// NewIPeggedTokenCaller creates a new read-only instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenCaller(address common.Address, caller bind.ContractCaller) (*IPeggedTokenCaller, error) {
	contract, err := bindIPeggedToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenCaller{contract: contract}, nil
}

// NewIPeggedTokenTransactor creates a new write-only instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*IPeggedTokenTransactor, error) {
	contract, err := bindIPeggedToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenTransactor{contract: contract}, nil
}

// NewIPeggedTokenFilterer creates a new log filterer instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*IPeggedTokenFilterer, error) {
	contract, err := bindIPeggedToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenFilterer{contract: contract}, nil
}

// bindIPeggedToken binds a generic wrapper to an already deployed contract.
func bindIPeggedToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IPeggedTokenMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPeggedToken *IPeggedTokenRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPeggedToken.Contract.IPeggedTokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPeggedToken *IPeggedTokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPeggedToken.Contract.IPeggedTokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPeggedToken *IPeggedTokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPeggedToken.Contract.IPeggedTokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPeggedToken *IPeggedTokenCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPeggedToken.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPeggedToken *IPeggedTokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPeggedToken.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPeggedToken *IPeggedTokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPeggedToken.Contract.contract.Transact(opts, method, params...)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactor) BurnFrom(opts *bind.TransactOpts, _from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.contract.Transact(opts, "burnFrom", _from, _amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenSession) BurnFrom(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.BurnFrom(&_IPeggedToken.TransactOpts, _from, _amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactorSession) BurnFrom(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.BurnFrom(&_IPeggedToken.TransactOpts, _from, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactor) Mint(opts *bind.TransactOpts, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.contract.Transact(opts, "mint", _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.Mint(&_IPeggedToken.TransactOpts, _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactorSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.Mint(&_IPeggedToken.TransactOpts, _to, _amount)
}

// IPoolManagerMetaData contains all meta data concerning the IPoolManager contract.
var IPoolManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"CurrenciesInitializedOutOfOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CurrencyNotSettled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"LockedBy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxCurrenciesTouched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManagerToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeCannotBeFetched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TickSpacingTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TickSpacingTooSmall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"name\":\"HookFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"name\":\"ModifyPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeController\",\"type\":\"address\"}],\"name\":\"ProtocolFeeControllerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount0\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount1\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"currencyDelta\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"donate\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nSlots\",\"type\":\"uint256\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"}],\"internalType\":\"structPosition.Info\",\"name\":\"position\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getSlot0\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hookFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"length\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"nonzeroDeltaCount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"modifyPosition\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protocolFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"reservesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setHookFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IPoolManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IPoolManagerMetaData.ABI instead.
var IPoolManagerABI = IPoolManagerMetaData.ABI

// IPoolManager is an auto generated Go binding around an Ethereum contract.
type IPoolManager struct {
	IPoolManagerCaller     // Read-only binding to the contract
	IPoolManagerTransactor // Write-only binding to the contract
	IPoolManagerFilterer   // Log filterer for contract events
}

// IPoolManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPoolManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPoolManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPoolManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPoolManagerSession struct {
	Contract     *IPoolManager     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPoolManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPoolManagerCallerSession struct {
	Contract *IPoolManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IPoolManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPoolManagerTransactorSession struct {
	Contract     *IPoolManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IPoolManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPoolManagerRaw struct {
	Contract *IPoolManager // Generic contract binding to access the raw methods on
}

// IPoolManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPoolManagerCallerRaw struct {
	Contract *IPoolManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IPoolManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPoolManagerTransactorRaw struct {
	Contract *IPoolManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPoolManager creates a new instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManager(address common.Address, backend bind.ContractBackend) (*IPoolManager, error) {
	contract, err := bindIPoolManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPoolManager{IPoolManagerCaller: IPoolManagerCaller{contract: contract}, IPoolManagerTransactor: IPoolManagerTransactor{contract: contract}, IPoolManagerFilterer: IPoolManagerFilterer{contract: contract}}, nil
}

// NewIPoolManagerCaller creates a new read-only instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerCaller(address common.Address, caller bind.ContractCaller) (*IPoolManagerCaller, error) {
	contract, err := bindIPoolManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerCaller{contract: contract}, nil
}

// NewIPoolManagerTransactor creates a new write-only instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IPoolManagerTransactor, error) {
	contract, err := bindIPoolManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransactor{contract: contract}, nil
}

// NewIPoolManagerFilterer creates a new log filterer instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IPoolManagerFilterer, error) {
	contract, err := bindIPoolManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerFilterer{contract: contract}, nil
}

// bindIPoolManager binds a generic wrapper to an already deployed contract.
func bindIPoolManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IPoolManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPoolManager *IPoolManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPoolManager.Contract.IPoolManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPoolManager *IPoolManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPoolManager.Contract.IPoolManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPoolManager *IPoolManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPoolManager.Contract.IPoolManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPoolManager *IPoolManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPoolManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPoolManager *IPoolManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPoolManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPoolManager *IPoolManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPoolManager.Contract.contract.Transact(opts, method, params...)
}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCaller) MAXTICKSPACING(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MAX_TICK_SPACING")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerSession) MAXTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MAXTICKSPACING(&_IPoolManager.CallOpts)
}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCallerSession) MAXTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MAXTICKSPACING(&_IPoolManager.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerCaller) MINPROTOCOLFEEDENOMINATOR(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MIN_PROTOCOL_FEE_DENOMINATOR")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IPoolManager.Contract.MINPROTOCOLFEEDENOMINATOR(&_IPoolManager.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerCallerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IPoolManager.Contract.MINPROTOCOLFEEDENOMINATOR(&_IPoolManager.CallOpts)
}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCaller) MINTICKSPACING(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MIN_TICK_SPACING")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerSession) MINTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MINTICKSPACING(&_IPoolManager.CallOpts)
}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCallerSession) MINTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MINTICKSPACING(&_IPoolManager.CallOpts)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) BalanceOf(opts *bind.CallOpts, account common.Address, id *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "balanceOf", account, id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.BalanceOf(&_IPoolManager.CallOpts, account, id)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.BalanceOf(&_IPoolManager.CallOpts, account, id)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerCaller) BalanceOfBatch(opts *bind.CallOpts, accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "balanceOfBatch", accounts, ids)

	if err != nil {
		return *new([]*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)

	return out0, err

}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IPoolManager.Contract.BalanceOfBatch(&_IPoolManager.CallOpts, accounts, ids)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerCallerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IPoolManager.Contract.BalanceOfBatch(&_IPoolManager.CallOpts, accounts, ids)
}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerCaller) CurrencyDelta(opts *bind.CallOpts, locker common.Address, currency common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "currencyDelta", locker, currency)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerSession) CurrencyDelta(locker common.Address, currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.CurrencyDelta(&_IPoolManager.CallOpts, locker, currency)
}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerCallerSession) CurrencyDelta(locker common.Address, currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.CurrencyDelta(&_IPoolManager.CallOpts, locker, currency)
}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerCaller) Extsload(opts *bind.CallOpts, slot [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "extsload", slot)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerSession) Extsload(slot [32]byte) ([32]byte, error) {
	return _IPoolManager.Contract.Extsload(&_IPoolManager.CallOpts, slot)
}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerCallerSession) Extsload(slot [32]byte) ([32]byte, error) {
	return _IPoolManager.Contract.Extsload(&_IPoolManager.CallOpts, slot)
}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerCaller) Extsload0(opts *bind.CallOpts, slot [32]byte, nSlots *big.Int) ([]byte, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "extsload0", slot, nSlots)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerSession) Extsload0(slot [32]byte, nSlots *big.Int) ([]byte, error) {
	return _IPoolManager.Contract.Extsload0(&_IPoolManager.CallOpts, slot, nSlots)
}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerCallerSession) Extsload0(slot [32]byte, nSlots *big.Int) ([]byte, error) {
	return _IPoolManager.Contract.Extsload0(&_IPoolManager.CallOpts, slot, nSlots)
}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCaller) GetLiquidity(opts *bind.CallOpts, id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLiquidity", id, owner, tickLower, tickUpper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerSession) GetLiquidity(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCallerSession) GetLiquidity(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCaller) GetLiquidity0(opts *bind.CallOpts, id [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLiquidity0", id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerSession) GetLiquidity0(id [32]byte) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity0(&_IPoolManager.CallOpts, id)
}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCallerSession) GetLiquidity0(id [32]byte) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity0(&_IPoolManager.CallOpts, id)
}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerCaller) GetLock(opts *bind.CallOpts, i *big.Int) (common.Address, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLock", i)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerSession) GetLock(i *big.Int) (common.Address, error) {
	return _IPoolManager.Contract.GetLock(&_IPoolManager.CallOpts, i)
}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerCallerSession) GetLock(i *big.Int) (common.Address, error) {
	return _IPoolManager.Contract.GetLock(&_IPoolManager.CallOpts, i)
}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerCaller) GetPosition(opts *bind.CallOpts, id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getPosition", id, owner, tickLower, tickUpper)

	if err != nil {
		return *new(PositionInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(PositionInfo)).(*PositionInfo)

	return out0, err

}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerSession) GetPosition(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	return _IPoolManager.Contract.GetPosition(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerCallerSession) GetPosition(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	return _IPoolManager.Contract.GetPosition(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerCaller) GetSlot0(opts *bind.CallOpts, id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getSlot0", id)

	outstruct := new(struct {
		SqrtPriceX96 *big.Int
		Tick         *big.Int
		ProtocolFees *big.Int
		HookFees     *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.SqrtPriceX96 = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.Tick = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.ProtocolFees = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.HookFees = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerSession) GetSlot0(id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	return _IPoolManager.Contract.GetSlot0(&_IPoolManager.CallOpts, id)
}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerCallerSession) GetSlot0(id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	return _IPoolManager.Contract.GetSlot0(&_IPoolManager.CallOpts, id)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) HookFeesAccrued(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "hookFeesAccrued", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.HookFeesAccrued(&_IPoolManager.CallOpts, arg0, arg1)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.HookFeesAccrued(&_IPoolManager.CallOpts, arg0, arg1)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerCaller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "isApprovedForAll", account, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IPoolManager.Contract.IsApprovedForAll(&_IPoolManager.CallOpts, account, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerCallerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IPoolManager.Contract.IsApprovedForAll(&_IPoolManager.CallOpts, account, operator)
}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerCaller) LockData(opts *bind.CallOpts) (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "lockData")

	outstruct := new(struct {
		Length            *big.Int
		NonzeroDeltaCount *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Length = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.NonzeroDeltaCount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerSession) LockData() (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	return _IPoolManager.Contract.LockData(&_IPoolManager.CallOpts)
}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerCallerSession) LockData() (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	return _IPoolManager.Contract.LockData(&_IPoolManager.CallOpts)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) ProtocolFeesAccrued(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "protocolFeesAccrued", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ProtocolFeesAccrued(&_IPoolManager.CallOpts, arg0)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ProtocolFeesAccrued(&_IPoolManager.CallOpts, arg0)
}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) ReservesOf(opts *bind.CallOpts, currency common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "reservesOf", currency)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) ReservesOf(currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ReservesOf(&_IPoolManager.CallOpts, currency)
}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) ReservesOf(currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ReservesOf(&_IPoolManager.CallOpts, currency)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IPoolManager.Contract.SupportsInterface(&_IPoolManager.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IPoolManager.Contract.SupportsInterface(&_IPoolManager.CallOpts, interfaceId)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) Donate(opts *bind.TransactOpts, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "donate", key, amount0, amount1, hookData)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) Donate(key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Donate(&_IPoolManager.TransactOpts, key, amount0, amount1, hookData)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) Donate(key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Donate(&_IPoolManager.TransactOpts, key, amount0, amount1, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerTransactor) Initialize(opts *bind.TransactOpts, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "initialize", key, sqrtPriceX96, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerSession) Initialize(key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Initialize(&_IPoolManager.TransactOpts, key, sqrtPriceX96, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerTransactorSession) Initialize(key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Initialize(&_IPoolManager.TransactOpts, key, sqrtPriceX96, hookData)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerTransactor) Lock(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "lock", data)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerSession) Lock(data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Lock(&_IPoolManager.TransactOpts, data)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerTransactorSession) Lock(data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Lock(&_IPoolManager.TransactOpts, data)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactor) Mint(opts *bind.TransactOpts, token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "mint", token, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerSession) Mint(token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Mint(&_IPoolManager.TransactOpts, token, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactorSession) Mint(token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Mint(&_IPoolManager.TransactOpts, token, to, amount)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) ModifyPosition(opts *bind.TransactOpts, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "modifyPosition", key, params, hookData)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) ModifyPosition(key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.ModifyPosition(&_IPoolManager.TransactOpts, key, params, hookData)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) ModifyPosition(key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.ModifyPosition(&_IPoolManager.TransactOpts, key, params, hookData)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactor) SafeBatchTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "safeBatchTransferFrom", from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeBatchTransferFrom(&_IPoolManager.TransactOpts, from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeBatchTransferFrom(&_IPoolManager.TransactOpts, from, to, ids, amounts, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "safeTransferFrom", from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeTransferFrom(&_IPoolManager.TransactOpts, from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeTransferFrom(&_IPoolManager.TransactOpts, from, to, id, amount, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetApprovalForAll(&_IPoolManager.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetApprovalForAll(&_IPoolManager.TransactOpts, operator, approved)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactor) SetHookFees(opts *bind.TransactOpts, key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setHookFees", key)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerSession) SetHookFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetHookFees(&_IPoolManager.TransactOpts, key)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetHookFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetHookFees(&_IPoolManager.TransactOpts, key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactor) SetProtocolFees(opts *bind.TransactOpts, key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setProtocolFees", key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerSession) SetProtocolFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetProtocolFees(&_IPoolManager.TransactOpts, key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetProtocolFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetProtocolFees(&_IPoolManager.TransactOpts, key)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerTransactor) Settle(opts *bind.TransactOpts, token common.Address) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "settle", token)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerSession) Settle(token common.Address) (*types.Transaction, error) {
	return _IPoolManager.Contract.Settle(&_IPoolManager.TransactOpts, token)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerTransactorSession) Settle(token common.Address) (*types.Transaction, error) {
	return _IPoolManager.Contract.Settle(&_IPoolManager.TransactOpts, token)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) Swap(opts *bind.TransactOpts, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "swap", key, params, hookData)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) Swap(key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Swap(&_IPoolManager.TransactOpts, key, params, hookData)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) Swap(key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Swap(&_IPoolManager.TransactOpts, key, params, hookData)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactor) Take(opts *bind.TransactOpts, currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "take", currency, to, amount)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerSession) Take(currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Take(&_IPoolManager.TransactOpts, currency, to, amount)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactorSession) Take(currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Take(&_IPoolManager.TransactOpts, currency, to, amount)
}

// IPoolManagerApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IPoolManager contract.
type IPoolManagerApprovalForAllIterator struct {
	Event *IPoolManagerApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerApprovalForAll represents a ApprovalForAll event raised by the IPoolManager contract.
type IPoolManagerApprovalForAll struct {
	Account  common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (*IPoolManagerApprovalForAllIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerApprovalForAllIterator{contract: _IPoolManager.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IPoolManagerApprovalForAll, account []common.Address, operator []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerApprovalForAll)
				if err := _IPoolManager.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) ParseApprovalForAll(log types.Log) (*IPoolManagerApprovalForAll, error) {
	event := new(IPoolManagerApprovalForAll)
	if err := _IPoolManager.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerHookFeeUpdatedIterator is returned from FilterHookFeeUpdated and is used to iterate over the raw logs and unpacked data for HookFeeUpdated events raised by the IPoolManager contract.
type IPoolManagerHookFeeUpdatedIterator struct {
	Event *IPoolManagerHookFeeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerHookFeeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerHookFeeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerHookFeeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerHookFeeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerHookFeeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerHookFeeUpdated represents a HookFeeUpdated event raised by the IPoolManager contract.
type IPoolManagerHookFeeUpdated struct {
	Id       [32]byte
	HookFees *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterHookFeeUpdated is a free log retrieval operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) FilterHookFeeUpdated(opts *bind.FilterOpts, id [][32]byte) (*IPoolManagerHookFeeUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "HookFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerHookFeeUpdatedIterator{contract: _IPoolManager.contract, event: "HookFeeUpdated", logs: logs, sub: sub}, nil
}

// WatchHookFeeUpdated is a free log subscription operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) WatchHookFeeUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerHookFeeUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "HookFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerHookFeeUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "HookFeeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHookFeeUpdated is a log parse operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) ParseHookFeeUpdated(log types.Log) (*IPoolManagerHookFeeUpdated, error) {
	event := new(IPoolManagerHookFeeUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "HookFeeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerInitializeIterator is returned from FilterInitialize and is used to iterate over the raw logs and unpacked data for Initialize events raised by the IPoolManager contract.
type IPoolManagerInitializeIterator struct {
	Event *IPoolManagerInitialize // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerInitializeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerInitialize)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerInitialize)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerInitializeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerInitializeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerInitialize represents a Initialize event raised by the IPoolManager contract.
type IPoolManagerInitialize struct {
	Id          [32]byte
	Currency0   common.Address
	Currency1   common.Address
	Fee         *big.Int
	TickSpacing *big.Int
	Hooks       common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterInitialize is a free log retrieval operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) FilterInitialize(opts *bind.FilterOpts, id [][32]byte, currency0 []common.Address, currency1 []common.Address) (*IPoolManagerInitializeIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var currency0Rule []interface{}
	for _, currency0Item := range currency0 {
		currency0Rule = append(currency0Rule, currency0Item)
	}
	var currency1Rule []interface{}
	for _, currency1Item := range currency1 {
		currency1Rule = append(currency1Rule, currency1Item)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "Initialize", idRule, currency0Rule, currency1Rule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerInitializeIterator{contract: _IPoolManager.contract, event: "Initialize", logs: logs, sub: sub}, nil
}

// WatchInitialize is a free log subscription operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) WatchInitialize(opts *bind.WatchOpts, sink chan<- *IPoolManagerInitialize, id [][32]byte, currency0 []common.Address, currency1 []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var currency0Rule []interface{}
	for _, currency0Item := range currency0 {
		currency0Rule = append(currency0Rule, currency0Item)
	}
	var currency1Rule []interface{}
	for _, currency1Item := range currency1 {
		currency1Rule = append(currency1Rule, currency1Item)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "Initialize", idRule, currency0Rule, currency1Rule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerInitialize)
				if err := _IPoolManager.contract.UnpackLog(event, "Initialize", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialize is a log parse operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) ParseInitialize(log types.Log) (*IPoolManagerInitialize, error) {
	event := new(IPoolManagerInitialize)
	if err := _IPoolManager.contract.UnpackLog(event, "Initialize", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerModifyPositionIterator is returned from FilterModifyPosition and is used to iterate over the raw logs and unpacked data for ModifyPosition events raised by the IPoolManager contract.
type IPoolManagerModifyPositionIterator struct {
	Event *IPoolManagerModifyPosition // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerModifyPositionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerModifyPosition)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerModifyPosition)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerModifyPositionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerModifyPositionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerModifyPosition represents a ModifyPosition event raised by the IPoolManager contract.
type IPoolManagerModifyPosition struct {
	Id             [32]byte
	Sender         common.Address
	TickLower      *big.Int
	TickUpper      *big.Int
	LiquidityDelta *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterModifyPosition is a free log retrieval operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) FilterModifyPosition(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*IPoolManagerModifyPositionIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ModifyPosition", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerModifyPositionIterator{contract: _IPoolManager.contract, event: "ModifyPosition", logs: logs, sub: sub}, nil
}

// WatchModifyPosition is a free log subscription operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) WatchModifyPosition(opts *bind.WatchOpts, sink chan<- *IPoolManagerModifyPosition, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ModifyPosition", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerModifyPosition)
				if err := _IPoolManager.contract.UnpackLog(event, "ModifyPosition", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseModifyPosition is a log parse operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) ParseModifyPosition(log types.Log) (*IPoolManagerModifyPosition, error) {
	event := new(IPoolManagerModifyPosition)
	if err := _IPoolManager.contract.UnpackLog(event, "ModifyPosition", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerProtocolFeeControllerUpdatedIterator is returned from FilterProtocolFeeControllerUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeControllerUpdated events raised by the IPoolManager contract.
type IPoolManagerProtocolFeeControllerUpdatedIterator struct {
	Event *IPoolManagerProtocolFeeControllerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerProtocolFeeControllerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerProtocolFeeControllerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerProtocolFeeControllerUpdated represents a ProtocolFeeControllerUpdated event raised by the IPoolManager contract.
type IPoolManagerProtocolFeeControllerUpdated struct {
	ProtocolFeeController common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeControllerUpdated is a free log retrieval operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) FilterProtocolFeeControllerUpdated(opts *bind.FilterOpts) (*IPoolManagerProtocolFeeControllerUpdatedIterator, error) {

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return &IPoolManagerProtocolFeeControllerUpdatedIterator{contract: _IPoolManager.contract, event: "ProtocolFeeControllerUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeControllerUpdated is a free log subscription operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) WatchProtocolFeeControllerUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerProtocolFeeControllerUpdated) (event.Subscription, error) {

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerProtocolFeeControllerUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeControllerUpdated is a log parse operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) ParseProtocolFeeControllerUpdated(log types.Log) (*IPoolManagerProtocolFeeControllerUpdated, error) {
	event := new(IPoolManagerProtocolFeeControllerUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerProtocolFeeUpdatedIterator is returned from FilterProtocolFeeUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeUpdated events raised by the IPoolManager contract.
type IPoolManagerProtocolFeeUpdatedIterator struct {
	Event *IPoolManagerProtocolFeeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerProtocolFeeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerProtocolFeeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerProtocolFeeUpdated represents a ProtocolFeeUpdated event raised by the IPoolManager contract.
type IPoolManagerProtocolFeeUpdated struct {
	Id           [32]byte
	ProtocolFees *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeUpdated is a free log retrieval operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) FilterProtocolFeeUpdated(opts *bind.FilterOpts, id [][32]byte) (*IPoolManagerProtocolFeeUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ProtocolFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerProtocolFeeUpdatedIterator{contract: _IPoolManager.contract, event: "ProtocolFeeUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeUpdated is a free log subscription operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) WatchProtocolFeeUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerProtocolFeeUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ProtocolFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerProtocolFeeUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeUpdated is a log parse operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) ParseProtocolFeeUpdated(log types.Log) (*IPoolManagerProtocolFeeUpdated, error) {
	event := new(IPoolManagerProtocolFeeUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the IPoolManager contract.
type IPoolManagerSwapIterator struct {
	Event *IPoolManagerSwap // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerSwapIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerSwap)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerSwap)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerSwapIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerSwapIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerSwap represents a Swap event raised by the IPoolManager contract.
type IPoolManagerSwap struct {
	Id           [32]byte
	Sender       common.Address
	Amount0      *big.Int
	Amount1      *big.Int
	SqrtPriceX96 *big.Int
	Liquidity    *big.Int
	Tick         *big.Int
	Fee          *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSwap is a free log retrieval operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) FilterSwap(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*IPoolManagerSwapIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerSwapIterator{contract: _IPoolManager.contract, event: "Swap", logs: logs, sub: sub}, nil
}

// WatchSwap is a free log subscription operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *IPoolManagerSwap, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerSwap)
				if err := _IPoolManager.contract.UnpackLog(event, "Swap", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSwap is a log parse operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) ParseSwap(log types.Log) (*IPoolManagerSwap, error) {
	event := new(IPoolManagerSwap)
	if err := _IPoolManager.contract.UnpackLog(event, "Swap", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerTransferBatchIterator is returned from FilterTransferBatch and is used to iterate over the raw logs and unpacked data for TransferBatch events raised by the IPoolManager contract.
type IPoolManagerTransferBatchIterator struct {
	Event *IPoolManagerTransferBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerTransferBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerTransferBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerTransferBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerTransferBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerTransferBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerTransferBatch represents a TransferBatch event raised by the IPoolManager contract.
type IPoolManagerTransferBatch struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Ids      []*big.Int
	Values   []*big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferBatch is a free log retrieval operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IPoolManagerTransferBatchIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransferBatchIterator{contract: _IPoolManager.contract, event: "TransferBatch", logs: logs, sub: sub}, nil
}

// WatchTransferBatch is a free log subscription operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *IPoolManagerTransferBatch, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerTransferBatch)
				if err := _IPoolManager.contract.UnpackLog(event, "TransferBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferBatch is a log parse operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) ParseTransferBatch(log types.Log) (*IPoolManagerTransferBatch, error) {
	event := new(IPoolManagerTransferBatch)
	if err := _IPoolManager.contract.UnpackLog(event, "TransferBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerTransferSingleIterator is returned from FilterTransferSingle and is used to iterate over the raw logs and unpacked data for TransferSingle events raised by the IPoolManager contract.
type IPoolManagerTransferSingleIterator struct {
	Event *IPoolManagerTransferSingle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerTransferSingleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerTransferSingle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerTransferSingle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerTransferSingleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerTransferSingleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerTransferSingle represents a TransferSingle event raised by the IPoolManager contract.
type IPoolManagerTransferSingle struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Id       *big.Int
	Value    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferSingle is a free log retrieval operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IPoolManagerTransferSingleIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransferSingleIterator{contract: _IPoolManager.contract, event: "TransferSingle", logs: logs, sub: sub}, nil
}

// WatchTransferSingle is a free log subscription operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *IPoolManagerTransferSingle, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerTransferSingle)
				if err := _IPoolManager.contract.UnpackLog(event, "TransferSingle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferSingle is a log parse operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) ParseTransferSingle(log types.Log) (*IPoolManagerTransferSingle, error) {
	event := new(IPoolManagerTransferSingle)
	if err := _IPoolManager.contract.UnpackLog(event, "TransferSingle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerURIIterator is returned from FilterURI and is used to iterate over the raw logs and unpacked data for URI events raised by the IPoolManager contract.
type IPoolManagerURIIterator struct {
	Event *IPoolManagerURI // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerURIIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerURI)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerURI)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerURIIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerURIIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerURI represents a URI event raised by the IPoolManager contract.
type IPoolManagerURI struct {
	Value string
	Id    *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterURI is a free log retrieval operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (*IPoolManagerURIIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerURIIterator{contract: _IPoolManager.contract, event: "URI", logs: logs, sub: sub}, nil
}

// WatchURI is a free log subscription operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) WatchURI(opts *bind.WatchOpts, sink chan<- *IPoolManagerURI, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerURI)
				if err := _IPoolManager.contract.UnpackLog(event, "URI", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseURI is a log parse operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) ParseURI(log types.Log) (*IPoolManagerURI, error) {
	event := new(IPoolManagerURI)
	if err := _IPoolManager.contract.UnpackLog(event, "URI", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IReceiptVerifierMetaData contains all meta data concerning the IReceiptVerifier contract.
var IReceiptVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"receiptInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceiptAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"receiptInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IReceiptVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IReceiptVerifierMetaData.ABI instead.
var IReceiptVerifierABI = IReceiptVerifierMetaData.ABI

// IReceiptVerifier is an auto generated Go binding around an Ethereum contract.
type IReceiptVerifier struct {
	IReceiptVerifierCaller     // Read-only binding to the contract
	IReceiptVerifierTransactor // Write-only binding to the contract
	IReceiptVerifierFilterer   // Log filterer for contract events
}

// IReceiptVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IReceiptVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IReceiptVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IReceiptVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IReceiptVerifierSession struct {
	Contract     *IReceiptVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IReceiptVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IReceiptVerifierCallerSession struct {
	Contract *IReceiptVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// IReceiptVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IReceiptVerifierTransactorSession struct {
	Contract     *IReceiptVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// IReceiptVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IReceiptVerifierRaw struct {
	Contract *IReceiptVerifier // Generic contract binding to access the raw methods on
}

// IReceiptVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IReceiptVerifierCallerRaw struct {
	Contract *IReceiptVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IReceiptVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IReceiptVerifierTransactorRaw struct {
	Contract *IReceiptVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIReceiptVerifier creates a new instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifier(address common.Address, backend bind.ContractBackend) (*IReceiptVerifier, error) {
	contract, err := bindIReceiptVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifier{IReceiptVerifierCaller: IReceiptVerifierCaller{contract: contract}, IReceiptVerifierTransactor: IReceiptVerifierTransactor{contract: contract}, IReceiptVerifierFilterer: IReceiptVerifierFilterer{contract: contract}}, nil
}

// NewIReceiptVerifierCaller creates a new read-only instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierCaller(address common.Address, caller bind.ContractCaller) (*IReceiptVerifierCaller, error) {
	contract, err := bindIReceiptVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierCaller{contract: contract}, nil
}

// NewIReceiptVerifierTransactor creates a new write-only instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IReceiptVerifierTransactor, error) {
	contract, err := bindIReceiptVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierTransactor{contract: contract}, nil
}

// NewIReceiptVerifierFilterer creates a new log filterer instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IReceiptVerifierFilterer, error) {
	contract, err := bindIReceiptVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierFilterer{contract: contract}, nil
}

// bindIReceiptVerifier binds a generic wrapper to an already deployed contract.
func bindIReceiptVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IReceiptVerifier *IReceiptVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IReceiptVerifier.Contract.IReceiptVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IReceiptVerifier *IReceiptVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.IReceiptVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IReceiptVerifier *IReceiptVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.IReceiptVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IReceiptVerifier *IReceiptVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IReceiptVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IReceiptVerifier *IReceiptVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IReceiptVerifier *IReceiptVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierCaller) VerifyReceipt(opts *bind.CallOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _IReceiptVerifier.contract.Call(opts, &out, "verifyReceipt", receiptRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _IReceiptVerifier.Contract.VerifyReceipt(&_IReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierCallerSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _IReceiptVerifier.Contract.VerifyReceipt(&_IReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierTransactor) VerifyReceiptAndLog(opts *bind.TransactOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.contract.Transact(opts, "verifyReceiptAndLog", receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.VerifyReceiptAndLog(&_IReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierTransactorSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.VerifyReceiptAndLog(&_IReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// ISMTMetaData contains all meta data concerning the ISMT contract.
var ISMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"commitPub\",\"type\":\"bytes32\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ISMTABI is the input ABI used to generate the binding from.
// Deprecated: Use ISMTMetaData.ABI instead.
var ISMTABI = ISMTMetaData.ABI

// ISMT is an auto generated Go binding around an Ethereum contract.
type ISMT struct {
	ISMTCaller     // Read-only binding to the contract
	ISMTTransactor // Write-only binding to the contract
	ISMTFilterer   // Log filterer for contract events
}

// ISMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISMTSession struct {
	Contract     *ISMT             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISMTCallerSession struct {
	Contract *ISMTCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ISMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISMTTransactorSession struct {
	Contract     *ISMTTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISMTRaw struct {
	Contract *ISMT // Generic contract binding to access the raw methods on
}

// ISMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISMTCallerRaw struct {
	Contract *ISMTCaller // Generic read-only contract binding to access the raw methods on
}

// ISMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISMTTransactorRaw struct {
	Contract *ISMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISMT creates a new instance of ISMT, bound to a specific deployed contract.
func NewISMT(address common.Address, backend bind.ContractBackend) (*ISMT, error) {
	contract, err := bindISMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISMT{ISMTCaller: ISMTCaller{contract: contract}, ISMTTransactor: ISMTTransactor{contract: contract}, ISMTFilterer: ISMTFilterer{contract: contract}}, nil
}

// NewISMTCaller creates a new read-only instance of ISMT, bound to a specific deployed contract.
func NewISMTCaller(address common.Address, caller bind.ContractCaller) (*ISMTCaller, error) {
	contract, err := bindISMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISMTCaller{contract: contract}, nil
}

// NewISMTTransactor creates a new write-only instance of ISMT, bound to a specific deployed contract.
func NewISMTTransactor(address common.Address, transactor bind.ContractTransactor) (*ISMTTransactor, error) {
	contract, err := bindISMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISMTTransactor{contract: contract}, nil
}

// NewISMTFilterer creates a new log filterer instance of ISMT, bound to a specific deployed contract.
func NewISMTFilterer(address common.Address, filterer bind.ContractFilterer) (*ISMTFilterer, error) {
	contract, err := bindISMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISMTFilterer{contract: contract}, nil
}

// bindISMT binds a generic wrapper to an already deployed contract.
func bindISMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISMT *ISMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISMT.Contract.ISMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISMT *ISMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISMT.Contract.ISMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISMT *ISMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISMT.Contract.ISMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISMT *ISMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISMT *ISMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISMT *ISMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISMT.Contract.contract.Transact(opts, method, params...)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _ISMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _ISMT.Contract.IsSmtRootValid(&_ISMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _ISMT.Contract.IsSmtRootValid(&_ISMT.CallOpts, chainId, smtRoot)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_ISMT *ISMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_ISMT *ISMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.Contract.UpdateRoot(&_ISMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_ISMT *ISMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.Contract.UpdateRoot(&_ISMT.TransactOpts, chainId, u)
}

// ISigsVerifierMetaData contains all meta data concerning the ISigsVerifier contract.
var ISigsVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"verifySigs\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// ISigsVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ISigsVerifierMetaData.ABI instead.
var ISigsVerifierABI = ISigsVerifierMetaData.ABI

// ISigsVerifier is an auto generated Go binding around an Ethereum contract.
type ISigsVerifier struct {
	ISigsVerifierCaller     // Read-only binding to the contract
	ISigsVerifierTransactor // Write-only binding to the contract
	ISigsVerifierFilterer   // Log filterer for contract events
}

// ISigsVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISigsVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISigsVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISigsVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISigsVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISigsVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISigsVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISigsVerifierSession struct {
	Contract     *ISigsVerifier    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISigsVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISigsVerifierCallerSession struct {
	Contract *ISigsVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ISigsVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISigsVerifierTransactorSession struct {
	Contract     *ISigsVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ISigsVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISigsVerifierRaw struct {
	Contract *ISigsVerifier // Generic contract binding to access the raw methods on
}

// ISigsVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISigsVerifierCallerRaw struct {
	Contract *ISigsVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ISigsVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISigsVerifierTransactorRaw struct {
	Contract *ISigsVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISigsVerifier creates a new instance of ISigsVerifier, bound to a specific deployed contract.
func NewISigsVerifier(address common.Address, backend bind.ContractBackend) (*ISigsVerifier, error) {
	contract, err := bindISigsVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISigsVerifier{ISigsVerifierCaller: ISigsVerifierCaller{contract: contract}, ISigsVerifierTransactor: ISigsVerifierTransactor{contract: contract}, ISigsVerifierFilterer: ISigsVerifierFilterer{contract: contract}}, nil
}

// NewISigsVerifierCaller creates a new read-only instance of ISigsVerifier, bound to a specific deployed contract.
func NewISigsVerifierCaller(address common.Address, caller bind.ContractCaller) (*ISigsVerifierCaller, error) {
	contract, err := bindISigsVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISigsVerifierCaller{contract: contract}, nil
}

// NewISigsVerifierTransactor creates a new write-only instance of ISigsVerifier, bound to a specific deployed contract.
func NewISigsVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ISigsVerifierTransactor, error) {
	contract, err := bindISigsVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISigsVerifierTransactor{contract: contract}, nil
}

// NewISigsVerifierFilterer creates a new log filterer instance of ISigsVerifier, bound to a specific deployed contract.
func NewISigsVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ISigsVerifierFilterer, error) {
	contract, err := bindISigsVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISigsVerifierFilterer{contract: contract}, nil
}

// bindISigsVerifier binds a generic wrapper to an already deployed contract.
func bindISigsVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISigsVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISigsVerifier *ISigsVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISigsVerifier.Contract.ISigsVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISigsVerifier *ISigsVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISigsVerifier.Contract.ISigsVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISigsVerifier *ISigsVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISigsVerifier.Contract.ISigsVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISigsVerifier *ISigsVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISigsVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISigsVerifier *ISigsVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISigsVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISigsVerifier *ISigsVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISigsVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySigs is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_ISigsVerifier *ISigsVerifierCaller) VerifySigs(opts *bind.CallOpts, _msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	var out []interface{}
	err := _ISigsVerifier.contract.Call(opts, &out, "verifySigs", _msg, _sigs, _signers, _powers)

	if err != nil {
		return err
	}

	return err

}

// VerifySigs is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_ISigsVerifier *ISigsVerifierSession) VerifySigs(_msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _ISigsVerifier.Contract.VerifySigs(&_ISigsVerifier.CallOpts, _msg, _sigs, _signers, _powers)
}

// VerifySigs is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_ISigsVerifier *ISigsVerifierCallerSession) VerifySigs(_msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _ISigsVerifier.Contract.VerifySigs(&_ISigsVerifier.CallOpts, _msg, _sigs, _signers, _powers)
}

// ISlotValueVerifierMetaData contains all meta data concerning the ISlotValueVerifier contract.
var ISlotValueVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifySlotValue\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"}],\"internalType\":\"structISlotValueVerifier.SlotInfo\",\"name\":\"slotInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// ISlotValueVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ISlotValueVerifierMetaData.ABI instead.
var ISlotValueVerifierABI = ISlotValueVerifierMetaData.ABI

// ISlotValueVerifier is an auto generated Go binding around an Ethereum contract.
type ISlotValueVerifier struct {
	ISlotValueVerifierCaller     // Read-only binding to the contract
	ISlotValueVerifierTransactor // Write-only binding to the contract
	ISlotValueVerifierFilterer   // Log filterer for contract events
}

// ISlotValueVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISlotValueVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISlotValueVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISlotValueVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISlotValueVerifierSession struct {
	Contract     *ISlotValueVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ISlotValueVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISlotValueVerifierCallerSession struct {
	Contract *ISlotValueVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ISlotValueVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISlotValueVerifierTransactorSession struct {
	Contract     *ISlotValueVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ISlotValueVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISlotValueVerifierRaw struct {
	Contract *ISlotValueVerifier // Generic contract binding to access the raw methods on
}

// ISlotValueVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISlotValueVerifierCallerRaw struct {
	Contract *ISlotValueVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ISlotValueVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISlotValueVerifierTransactorRaw struct {
	Contract *ISlotValueVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISlotValueVerifier creates a new instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifier(address common.Address, backend bind.ContractBackend) (*ISlotValueVerifier, error) {
	contract, err := bindISlotValueVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifier{ISlotValueVerifierCaller: ISlotValueVerifierCaller{contract: contract}, ISlotValueVerifierTransactor: ISlotValueVerifierTransactor{contract: contract}, ISlotValueVerifierFilterer: ISlotValueVerifierFilterer{contract: contract}}, nil
}

// NewISlotValueVerifierCaller creates a new read-only instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierCaller(address common.Address, caller bind.ContractCaller) (*ISlotValueVerifierCaller, error) {
	contract, err := bindISlotValueVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierCaller{contract: contract}, nil
}

// NewISlotValueVerifierTransactor creates a new write-only instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ISlotValueVerifierTransactor, error) {
	contract, err := bindISlotValueVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierTransactor{contract: contract}, nil
}

// NewISlotValueVerifierFilterer creates a new log filterer instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ISlotValueVerifierFilterer, error) {
	contract, err := bindISlotValueVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierFilterer{contract: contract}, nil
}

// bindISlotValueVerifier binds a generic wrapper to an already deployed contract.
func bindISlotValueVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISlotValueVerifier *ISlotValueVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISlotValueVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISlotValueVerifier *ISlotValueVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISlotValueVerifier *ISlotValueVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierCaller) VerifySlotValue(opts *bind.CallOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	var out []interface{}
	err := _ISlotValueVerifier.contract.Call(opts, &out, "verifySlotValue", chainId, proofData, blkVerifyInfo)

	if err != nil {
		return *new(ISlotValueVerifierSlotInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ISlotValueVerifierSlotInfo)).(*ISlotValueVerifierSlotInfo)

	return out0, err

}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _ISlotValueVerifier.Contract.VerifySlotValue(&_ISlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierCallerSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _ISlotValueVerifier.Contract.VerifySlotValue(&_ISlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// ITxVerifierMetaData contains all meta data concerning the ITxVerifier contract.
var ITxVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"txInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTxAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ITxVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ITxVerifierMetaData.ABI instead.
var ITxVerifierABI = ITxVerifierMetaData.ABI

// ITxVerifier is an auto generated Go binding around an Ethereum contract.
type ITxVerifier struct {
	ITxVerifierCaller     // Read-only binding to the contract
	ITxVerifierTransactor // Write-only binding to the contract
	ITxVerifierFilterer   // Log filterer for contract events
}

// ITxVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ITxVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ITxVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ITxVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ITxVerifierSession struct {
	Contract     *ITxVerifier      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ITxVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ITxVerifierCallerSession struct {
	Contract *ITxVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ITxVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ITxVerifierTransactorSession struct {
	Contract     *ITxVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ITxVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ITxVerifierRaw struct {
	Contract *ITxVerifier // Generic contract binding to access the raw methods on
}

// ITxVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ITxVerifierCallerRaw struct {
	Contract *ITxVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ITxVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ITxVerifierTransactorRaw struct {
	Contract *ITxVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewITxVerifier creates a new instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifier(address common.Address, backend bind.ContractBackend) (*ITxVerifier, error) {
	contract, err := bindITxVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ITxVerifier{ITxVerifierCaller: ITxVerifierCaller{contract: contract}, ITxVerifierTransactor: ITxVerifierTransactor{contract: contract}, ITxVerifierFilterer: ITxVerifierFilterer{contract: contract}}, nil
}

// NewITxVerifierCaller creates a new read-only instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierCaller(address common.Address, caller bind.ContractCaller) (*ITxVerifierCaller, error) {
	contract, err := bindITxVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierCaller{contract: contract}, nil
}

// NewITxVerifierTransactor creates a new write-only instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ITxVerifierTransactor, error) {
	contract, err := bindITxVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierTransactor{contract: contract}, nil
}

// NewITxVerifierFilterer creates a new log filterer instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ITxVerifierFilterer, error) {
	contract, err := bindITxVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierFilterer{contract: contract}, nil
}

// bindITxVerifier binds a generic wrapper to an already deployed contract.
func bindITxVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ITxVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITxVerifier *ITxVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITxVerifier.Contract.ITxVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITxVerifier *ITxVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITxVerifier.Contract.ITxVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITxVerifier *ITxVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITxVerifier.Contract.ITxVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITxVerifier *ITxVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITxVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITxVerifier *ITxVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITxVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITxVerifier *ITxVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITxVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierCaller) VerifyTx(opts *bind.CallOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _ITxVerifier.contract.Call(opts, &out, "verifyTx", txRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _ITxVerifier.Contract.VerifyTx(&_ITxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierCallerSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _ITxVerifier.Contract.VerifyTx(&_ITxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierTransactor) VerifyTxAndLog(opts *bind.TransactOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.contract.Transact(opts, "verifyTxAndLog", txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.Contract.VerifyTxAndLog(&_ITxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierTransactorSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.Contract.VerifyTxAndLog(&_ITxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// IUniswapSumVolumeMetaData contains all meta data concerning the IUniswapSumVolume contract.
var IUniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IUniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use IUniswapSumVolumeMetaData.ABI instead.
var IUniswapSumVolumeABI = IUniswapSumVolumeMetaData.ABI

// IUniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type IUniswapSumVolume struct {
	IUniswapSumVolumeCaller     // Read-only binding to the contract
	IUniswapSumVolumeTransactor // Write-only binding to the contract
	IUniswapSumVolumeFilterer   // Log filterer for contract events
}

// IUniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IUniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IUniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IUniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IUniswapSumVolumeSession struct {
	Contract     *IUniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IUniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IUniswapSumVolumeCallerSession struct {
	Contract *IUniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IUniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IUniswapSumVolumeTransactorSession struct {
	Contract     *IUniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IUniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IUniswapSumVolumeRaw struct {
	Contract *IUniswapSumVolume // Generic contract binding to access the raw methods on
}

// IUniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IUniswapSumVolumeCallerRaw struct {
	Contract *IUniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// IUniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IUniswapSumVolumeTransactorRaw struct {
	Contract *IUniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIUniswapSumVolume creates a new instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*IUniswapSumVolume, error) {
	contract, err := bindIUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolume{IUniswapSumVolumeCaller: IUniswapSumVolumeCaller{contract: contract}, IUniswapSumVolumeTransactor: IUniswapSumVolumeTransactor{contract: contract}, IUniswapSumVolumeFilterer: IUniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewIUniswapSumVolumeCaller creates a new read-only instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*IUniswapSumVolumeCaller, error) {
	contract, err := bindIUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeCaller{contract: contract}, nil
}

// NewIUniswapSumVolumeTransactor creates a new write-only instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*IUniswapSumVolumeTransactor, error) {
	contract, err := bindIUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeTransactor{contract: contract}, nil
}

// NewIUniswapSumVolumeFilterer creates a new log filterer instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*IUniswapSumVolumeFilterer, error) {
	contract, err := bindIUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeFilterer{contract: contract}, nil
}

// bindIUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindIUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IUniswapSumVolume *IUniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IUniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IUniswapSumVolume *IUniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IUniswapSumVolume *IUniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IUniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _IUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_IUniswapSumVolume.CallOpts, swapper)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _IUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_IUniswapSumVolume.CallOpts, swapper)
}

// IVerifierMetaData contains all meta data concerning the IVerifier contract.
var IVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[10]\",\"name\":\"input\",\"type\":\"uint256[10]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IVerifierMetaData.ABI instead.
var IVerifierABI = IVerifierMetaData.ABI

// IVerifier is an auto generated Go binding around an Ethereum contract.
type IVerifier struct {
	IVerifierCaller     // Read-only binding to the contract
	IVerifierTransactor // Write-only binding to the contract
	IVerifierFilterer   // Log filterer for contract events
}

// IVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IVerifierSession struct {
	Contract     *IVerifier        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IVerifierCallerSession struct {
	Contract *IVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IVerifierTransactorSession struct {
	Contract     *IVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IVerifierRaw struct {
	Contract *IVerifier // Generic contract binding to access the raw methods on
}

// IVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IVerifierCallerRaw struct {
	Contract *IVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IVerifierTransactorRaw struct {
	Contract *IVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIVerifier creates a new instance of IVerifier, bound to a specific deployed contract.
func NewIVerifier(address common.Address, backend bind.ContractBackend) (*IVerifier, error) {
	contract, err := bindIVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IVerifier{IVerifierCaller: IVerifierCaller{contract: contract}, IVerifierTransactor: IVerifierTransactor{contract: contract}, IVerifierFilterer: IVerifierFilterer{contract: contract}}, nil
}

// NewIVerifierCaller creates a new read-only instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierCaller(address common.Address, caller bind.ContractCaller) (*IVerifierCaller, error) {
	contract, err := bindIVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IVerifierCaller{contract: contract}, nil
}

// NewIVerifierTransactor creates a new write-only instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IVerifierTransactor, error) {
	contract, err := bindIVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IVerifierTransactor{contract: contract}, nil
}

// NewIVerifierFilterer creates a new log filterer instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IVerifierFilterer, error) {
	contract, err := bindIVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IVerifierFilterer{contract: contract}, nil
}

// bindIVerifier binds a generic wrapper to an already deployed contract.
func bindIVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IVerifier *IVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IVerifier.Contract.IVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IVerifier *IVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IVerifier.Contract.IVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IVerifier *IVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IVerifier.Contract.IVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IVerifier *IVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IVerifier *IVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IVerifier *IVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyProof is a free data retrieval call binding the contract method 0x9d210a18.
//
// Solidity: function verifyProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[10] input) view returns(bool r)
func (_IVerifier *IVerifierCaller) VerifyProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [10]*big.Int) (bool, error) {
	var out []interface{}
	err := _IVerifier.contract.Call(opts, &out, "verifyProof", a, b, c, commit, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyProof is a free data retrieval call binding the contract method 0x9d210a18.
//
// Solidity: function verifyProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[10] input) view returns(bool r)
func (_IVerifier *IVerifierSession) VerifyProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [10]*big.Int) (bool, error) {
	return _IVerifier.Contract.VerifyProof(&_IVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyProof is a free data retrieval call binding the contract method 0x9d210a18.
//
// Solidity: function verifyProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[10] input) view returns(bool r)
func (_IVerifier *IVerifierCallerSession) VerifyProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [10]*big.Int) (bool, error) {
	return _IVerifier.Contract.VerifyProof(&_IVerifier.CallOpts, a, b, c, commit, input)
}

// IZkpVerifierMetaData contains all meta data concerning the IZkpVerifier contract.
var IZkpVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"verifyRaw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IZkpVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IZkpVerifierMetaData.ABI instead.
var IZkpVerifierABI = IZkpVerifierMetaData.ABI

// IZkpVerifier is an auto generated Go binding around an Ethereum contract.
type IZkpVerifier struct {
	IZkpVerifierCaller     // Read-only binding to the contract
	IZkpVerifierTransactor // Write-only binding to the contract
	IZkpVerifierFilterer   // Log filterer for contract events
}

// IZkpVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IZkpVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IZkpVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IZkpVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IZkpVerifierSession struct {
	Contract     *IZkpVerifier     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IZkpVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IZkpVerifierCallerSession struct {
	Contract *IZkpVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IZkpVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IZkpVerifierTransactorSession struct {
	Contract     *IZkpVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IZkpVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IZkpVerifierRaw struct {
	Contract *IZkpVerifier // Generic contract binding to access the raw methods on
}

// IZkpVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IZkpVerifierCallerRaw struct {
	Contract *IZkpVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IZkpVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IZkpVerifierTransactorRaw struct {
	Contract *IZkpVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIZkpVerifier creates a new instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifier(address common.Address, backend bind.ContractBackend) (*IZkpVerifier, error) {
	contract, err := bindIZkpVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifier{IZkpVerifierCaller: IZkpVerifierCaller{contract: contract}, IZkpVerifierTransactor: IZkpVerifierTransactor{contract: contract}, IZkpVerifierFilterer: IZkpVerifierFilterer{contract: contract}}, nil
}

// NewIZkpVerifierCaller creates a new read-only instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierCaller(address common.Address, caller bind.ContractCaller) (*IZkpVerifierCaller, error) {
	contract, err := bindIZkpVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierCaller{contract: contract}, nil
}

// NewIZkpVerifierTransactor creates a new write-only instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IZkpVerifierTransactor, error) {
	contract, err := bindIZkpVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierTransactor{contract: contract}, nil
}

// NewIZkpVerifierFilterer creates a new log filterer instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IZkpVerifierFilterer, error) {
	contract, err := bindIZkpVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierFilterer{contract: contract}, nil
}

// bindIZkpVerifier binds a generic wrapper to an already deployed contract.
func bindIZkpVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IZkpVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IZkpVerifier *IZkpVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IZkpVerifier.Contract.IZkpVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IZkpVerifier *IZkpVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.IZkpVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IZkpVerifier *IZkpVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.IZkpVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IZkpVerifier *IZkpVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IZkpVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IZkpVerifier *IZkpVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IZkpVerifier *IZkpVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierCaller) VerifyRaw(opts *bind.CallOpts, proofData []byte) (bool, error) {
	var out []interface{}
	err := _IZkpVerifier.contract.Call(opts, &out, "verifyRaw", proofData)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierSession) VerifyRaw(proofData []byte) (bool, error) {
	return _IZkpVerifier.Contract.VerifyRaw(&_IZkpVerifier.CallOpts, proofData)
}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierCallerSession) VerifyRaw(proofData []byte) (bool, error) {
	return _IZkpVerifier.Contract.VerifyRaw(&_IZkpVerifier.CallOpts, proofData)
}

// LightClientStoreMetaData contains all meta data concerning the LightClientStore contract.
var LightClientStoreMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"bestValidUpdate\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkEpochs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkVersions\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkVerifier\",\"outputs\":[{\"internalType\":\"contractIBeaconVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// LightClientStoreABI is the input ABI used to generate the binding from.
// Deprecated: Use LightClientStoreMetaData.ABI instead.
var LightClientStoreABI = LightClientStoreMetaData.ABI

// LightClientStore is an auto generated Go binding around an Ethereum contract.
type LightClientStore struct {
	LightClientStoreCaller     // Read-only binding to the contract
	LightClientStoreTransactor // Write-only binding to the contract
	LightClientStoreFilterer   // Log filterer for contract events
}

// LightClientStoreCaller is an auto generated read-only Go binding around an Ethereum contract.
type LightClientStoreCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreTransactor is an auto generated write-only Go binding around an Ethereum contract.
type LightClientStoreTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type LightClientStoreFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type LightClientStoreSession struct {
	Contract     *LightClientStore // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// LightClientStoreCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type LightClientStoreCallerSession struct {
	Contract *LightClientStoreCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// LightClientStoreTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type LightClientStoreTransactorSession struct {
	Contract     *LightClientStoreTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// LightClientStoreRaw is an auto generated low-level Go binding around an Ethereum contract.
type LightClientStoreRaw struct {
	Contract *LightClientStore // Generic contract binding to access the raw methods on
}

// LightClientStoreCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type LightClientStoreCallerRaw struct {
	Contract *LightClientStoreCaller // Generic read-only contract binding to access the raw methods on
}

// LightClientStoreTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type LightClientStoreTransactorRaw struct {
	Contract *LightClientStoreTransactor // Generic write-only contract binding to access the raw methods on
}

// NewLightClientStore creates a new instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStore(address common.Address, backend bind.ContractBackend) (*LightClientStore, error) {
	contract, err := bindLightClientStore(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &LightClientStore{LightClientStoreCaller: LightClientStoreCaller{contract: contract}, LightClientStoreTransactor: LightClientStoreTransactor{contract: contract}, LightClientStoreFilterer: LightClientStoreFilterer{contract: contract}}, nil
}

// NewLightClientStoreCaller creates a new read-only instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreCaller(address common.Address, caller bind.ContractCaller) (*LightClientStoreCaller, error) {
	contract, err := bindLightClientStore(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreCaller{contract: contract}, nil
}

// NewLightClientStoreTransactor creates a new write-only instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreTransactor(address common.Address, transactor bind.ContractTransactor) (*LightClientStoreTransactor, error) {
	contract, err := bindLightClientStore(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreTransactor{contract: contract}, nil
}

// NewLightClientStoreFilterer creates a new log filterer instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreFilterer(address common.Address, filterer bind.ContractFilterer) (*LightClientStoreFilterer, error) {
	contract, err := bindLightClientStore(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreFilterer{contract: contract}, nil
}

// bindLightClientStore binds a generic wrapper to an already deployed contract.
func bindLightClientStore(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := LightClientStoreMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LightClientStore *LightClientStoreRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _LightClientStore.Contract.LightClientStoreCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LightClientStore *LightClientStoreRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LightClientStore.Contract.LightClientStoreTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LightClientStore *LightClientStoreRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LightClientStore.Contract.LightClientStoreTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LightClientStore *LightClientStoreCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _LightClientStore.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LightClientStore *LightClientStoreTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LightClientStore.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LightClientStore *LightClientStoreTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LightClientStore.Contract.contract.Transact(opts, method, params...)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreCaller) BestValidUpdate(opts *bind.CallOpts) (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "bestValidUpdate")

	outstruct := new(struct {
		AttestedHeader                    HeaderWithExecution
		FinalizedHeader                   HeaderWithExecution
		NextSyncCommitteeRoot             [32]byte
		NextSyncCommitteePoseidonRoot     [32]byte
		NextSyncCommitteeRootMappingProof IBeaconVerifierProof
		SyncAggregate                     SyncAggregate
		SignatureSlot                     uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.AttestedHeader = *abi.ConvertType(out[0], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.FinalizedHeader = *abi.ConvertType(out[1], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.NextSyncCommitteeRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteePoseidonRoot = *abi.ConvertType(out[3], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteeRootMappingProof = *abi.ConvertType(out[4], new(IBeaconVerifierProof)).(*IBeaconVerifierProof)
	outstruct.SyncAggregate = *abi.ConvertType(out[5], new(SyncAggregate)).(*SyncAggregate)
	outstruct.SignatureSlot = *abi.ConvertType(out[6], new(uint64)).(*uint64)

	return *outstruct, err

}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _LightClientStore.Contract.BestValidUpdate(&_LightClientStore.CallOpts)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreCallerSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _LightClientStore.Contract.BestValidUpdate(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) CurrentSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "currentSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) CurrentSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "currentSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) FinalizedExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "finalizedExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.FinalizedExecutionStateRoot(&_LightClientStore.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.FinalizedExecutionStateRoot(&_LightClientStore.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) FinalizedSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "finalizedSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreSession) FinalizedSlot() (uint64, error) {
	return _LightClientStore.Contract.FinalizedSlot(&_LightClientStore.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) FinalizedSlot() (uint64, error) {
	return _LightClientStore.Contract.FinalizedSlot(&_LightClientStore.CallOpts)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) ForkEpochs(opts *bind.CallOpts, arg0 *big.Int) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "forkEpochs", arg0)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _LightClientStore.Contract.ForkEpochs(&_LightClientStore.CallOpts, arg0)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _LightClientStore.Contract.ForkEpochs(&_LightClientStore.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreCaller) ForkVersions(opts *bind.CallOpts, arg0 *big.Int) ([4]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "forkVersions", arg0)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _LightClientStore.Contract.ForkVersions(&_LightClientStore.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreCallerSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _LightClientStore.Contract.ForkVersions(&_LightClientStore.CallOpts, arg0)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) NextSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "nextSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) NextSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "nextSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) OptimisticExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "optimisticExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.OptimisticExecutionStateRoot(&_LightClientStore.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.OptimisticExecutionStateRoot(&_LightClientStore.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) OptimisticSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "optimisticSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreSession) OptimisticSlot() (uint64, error) {
	return _LightClientStore.Contract.OptimisticSlot(&_LightClientStore.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) OptimisticSlot() (uint64, error) {
	return _LightClientStore.Contract.OptimisticSlot(&_LightClientStore.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreCaller) ZkVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "zkVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreSession) ZkVerifier() (common.Address, error) {
	return _LightClientStore.Contract.ZkVerifier(&_LightClientStore.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreCallerSession) ZkVerifier() (common.Address, error) {
	return _LightClientStore.Contract.ZkVerifier(&_LightClientStore.CallOpts)
}

// MerkleProofTreeMetaData contains all meta data concerning the MerkleProofTree contract.
var MerkleProofTreeMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212209b7c71a1f5c58712f919595af724b4f341c4079f1bdfcf25619fecbde1c3cf6964736f6c63430008140033",
}

// MerkleProofTreeABI is the input ABI used to generate the binding from.
// Deprecated: Use MerkleProofTreeMetaData.ABI instead.
var MerkleProofTreeABI = MerkleProofTreeMetaData.ABI

// MerkleProofTreeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MerkleProofTreeMetaData.Bin instead.
var MerkleProofTreeBin = MerkleProofTreeMetaData.Bin

// DeployMerkleProofTree deploys a new Ethereum contract, binding an instance of MerkleProofTree to it.
func DeployMerkleProofTree(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MerkleProofTree, error) {
	parsed, err := MerkleProofTreeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MerkleProofTreeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MerkleProofTree{MerkleProofTreeCaller: MerkleProofTreeCaller{contract: contract}, MerkleProofTreeTransactor: MerkleProofTreeTransactor{contract: contract}, MerkleProofTreeFilterer: MerkleProofTreeFilterer{contract: contract}}, nil
}

// MerkleProofTree is an auto generated Go binding around an Ethereum contract.
type MerkleProofTree struct {
	MerkleProofTreeCaller     // Read-only binding to the contract
	MerkleProofTreeTransactor // Write-only binding to the contract
	MerkleProofTreeFilterer   // Log filterer for contract events
}

// MerkleProofTreeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MerkleProofTreeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MerkleProofTreeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MerkleProofTreeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MerkleProofTreeSession struct {
	Contract     *MerkleProofTree  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MerkleProofTreeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MerkleProofTreeCallerSession struct {
	Contract *MerkleProofTreeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// MerkleProofTreeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MerkleProofTreeTransactorSession struct {
	Contract     *MerkleProofTreeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// MerkleProofTreeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MerkleProofTreeRaw struct {
	Contract *MerkleProofTree // Generic contract binding to access the raw methods on
}

// MerkleProofTreeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MerkleProofTreeCallerRaw struct {
	Contract *MerkleProofTreeCaller // Generic read-only contract binding to access the raw methods on
}

// MerkleProofTreeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MerkleProofTreeTransactorRaw struct {
	Contract *MerkleProofTreeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMerkleProofTree creates a new instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTree(address common.Address, backend bind.ContractBackend) (*MerkleProofTree, error) {
	contract, err := bindMerkleProofTree(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTree{MerkleProofTreeCaller: MerkleProofTreeCaller{contract: contract}, MerkleProofTreeTransactor: MerkleProofTreeTransactor{contract: contract}, MerkleProofTreeFilterer: MerkleProofTreeFilterer{contract: contract}}, nil
}

// NewMerkleProofTreeCaller creates a new read-only instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeCaller(address common.Address, caller bind.ContractCaller) (*MerkleProofTreeCaller, error) {
	contract, err := bindMerkleProofTree(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeCaller{contract: contract}, nil
}

// NewMerkleProofTreeTransactor creates a new write-only instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeTransactor(address common.Address, transactor bind.ContractTransactor) (*MerkleProofTreeTransactor, error) {
	contract, err := bindMerkleProofTree(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeTransactor{contract: contract}, nil
}

// NewMerkleProofTreeFilterer creates a new log filterer instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeFilterer(address common.Address, filterer bind.ContractFilterer) (*MerkleProofTreeFilterer, error) {
	contract, err := bindMerkleProofTree(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeFilterer{contract: contract}, nil
}

// bindMerkleProofTree binds a generic wrapper to an already deployed contract.
func bindMerkleProofTree(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MerkleProofTreeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProofTree *MerkleProofTreeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MerkleProofTree.Contract.MerkleProofTreeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProofTree *MerkleProofTreeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.MerkleProofTreeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProofTree *MerkleProofTreeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.MerkleProofTreeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProofTree *MerkleProofTreeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MerkleProofTree.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProofTree *MerkleProofTreeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProofTree *MerkleProofTreeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.contract.Transact(opts, method, params...)
}

// MessageAppMetaData contains all meta data concerning the MessageApp contract.
var MessageAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageAppMetaData.ABI instead.
var MessageAppABI = MessageAppMetaData.ABI

// MessageApp is an auto generated Go binding around an Ethereum contract.
type MessageApp struct {
	MessageAppCaller     // Read-only binding to the contract
	MessageAppTransactor // Write-only binding to the contract
	MessageAppFilterer   // Log filterer for contract events
}

// MessageAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageAppSession struct {
	Contract     *MessageApp       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageAppCallerSession struct {
	Contract *MessageAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// MessageAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageAppTransactorSession struct {
	Contract     *MessageAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MessageAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageAppRaw struct {
	Contract *MessageApp // Generic contract binding to access the raw methods on
}

// MessageAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageAppCallerRaw struct {
	Contract *MessageAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageAppTransactorRaw struct {
	Contract *MessageAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageApp creates a new instance of MessageApp, bound to a specific deployed contract.
func NewMessageApp(address common.Address, backend bind.ContractBackend) (*MessageApp, error) {
	contract, err := bindMessageApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageApp{MessageAppCaller: MessageAppCaller{contract: contract}, MessageAppTransactor: MessageAppTransactor{contract: contract}, MessageAppFilterer: MessageAppFilterer{contract: contract}}, nil
}

// NewMessageAppCaller creates a new read-only instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppCaller(address common.Address, caller bind.ContractCaller) (*MessageAppCaller, error) {
	contract, err := bindMessageApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageAppCaller{contract: contract}, nil
}

// NewMessageAppTransactor creates a new write-only instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageAppTransactor, error) {
	contract, err := bindMessageApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageAppTransactor{contract: contract}, nil
}

// NewMessageAppFilterer creates a new log filterer instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageAppFilterer, error) {
	contract, err := bindMessageApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageAppFilterer{contract: contract}, nil
}

// bindMessageApp binds a generic wrapper to an already deployed contract.
func bindMessageApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageApp *MessageAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageApp.Contract.MessageAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageApp *MessageAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageApp.Contract.MessageAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageApp *MessageAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageApp.Contract.MessageAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageApp *MessageAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageApp *MessageAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageApp *MessageAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppSession) MessageBridge() (common.Address, error) {
	return _MessageApp.Contract.MessageBridge(&_MessageApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageApp.Contract.MessageBridge(&_MessageApp.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.Contract.ExecuteMessage(&_MessageApp.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.Contract.ExecuteMessage(&_MessageApp.TransactOpts, srcChainId, sender, message, executor)
}

// MessageBridgeMetaData contains all meta data concerning the MessageBridge contract.
var MessageBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"MessageCallReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MessageExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_accountProof\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_storageProof\",\"type\":\"bytes[]\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_zkProofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"executeMessageWithZkProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"}],\"name\":\"getExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lightClients\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preExecuteMessageGasUsage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"receivedMessages\",\"outputs\":[{\"internalType\":\"enumIMessageBridge.MessageStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteMessageBridgeHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteMessageBridges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sentMessages\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"name\":\"setLightClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usage\",\"type\":\"uint256\"}],\"name\":\"setPreExecuteMessageGasUsage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_remoteMessageBridge\",\"type\":\"address\"}],\"name\":\"setRemoteMessageBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_slotValueVerifier\",\"type\":\"address\"}],\"name\":\"setSlotValueVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461005d5760015f8181558154336001600160a01b0319821681179093556001600160a01b0316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3611f1c90816100628239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c80630bbd09ab14610144578063127387081461013f578063456cb9f61461013a5780634586f331146101355780634f256d8114610130578063584e45e11461012b57806363c6ccb2146101265780636b217c0d146101215780636e98da7d1461011c578063715018a614610117578063735267cf146101125780638da5cb5b1461010d578063903e4d1e14610108578063970b324014610103578063975f5e1f146100fe578063affed0e0146100f9578063b90b8352146100f4578063f2fde38b146100ef5763f69f8151146100ea575f80fd5b61089c565b6107f1565b610704565b6106dd565b61066a565b61063d565b610600565b6105da565b610593565b610531565b6104f2565b6104c5565b61049f565b610482565b6103e3565b610389565b610365565b61029e565b6101c6565b67ffffffffffffffff81160361015b57565b5f80fd5b6024359061016c82610149565b565b602435906001600160a01b038216820361015b57565b604435906001600160a01b038216820361015b57565b606435906001600160a01b038216820361015b57565b600435906001600160a01b038216820361015b57565b3461015b57604036600319011261015b576004356101e381610149565b67ffffffffffffffff6101f461016e565b9161020b6001600160a01b03600154163314610c32565b165f81815260066020526040812080546001600160a01b0319166001600160a01b0385161790559160405160208101916bffffffffffffffffffffffff199060601b1682526014815261025d81610c91565b5190209082526007602052604082205580f35b9181601f8401121561015b5782359167ffffffffffffffff831161015b576020838186019501011161015b57565b3461015b5760e036600319011261015b576004356102bb81610149565b6102c361015f565b906102cc610184565b916102d561019a565b67ffffffffffffffff929060843584811161015b576102f8903690600401610270565b60a49291923586811161015b57610313903690600401610270565b93909260c43597881161015b5761034f9861033561033d993690600401610270565b989097610b27565b60405190151581529081906020820190565b0390f35b602090600319011261015b5760043590565b3461015b5761037336610353565b5f526007602052602060405f2054604051908152f35b3461015b5761039736610353565b6103ad6001600160a01b03600154163314610c32565b600955005b9181601f8401121561015b5782359167ffffffffffffffff831161015b576020808501948460051b01011161015b57565b3461015b5760e036600319011261015b5760043561040081610149565b61040861015f565b90610411610184565b9161041a61019a565b67ffffffffffffffff929060843584811161015b5761043d903690600401610270565b60a49291923586811161015b576104589036906004016103b2565b93909260c43597881161015b5761034f9861047a61033d9936906004016103b2565b9890976109a2565b3461015b575f36600319011261015b576020600954604051908152f35b3461015b575f36600319011261015b5760206001600160a01b0360085416604051908152f35b3461015b576104d336610353565b5f52600660205260206001600160a01b0360405f205416604051908152f35b3461015b57602036600319011261015b57604067ffffffffffffffff61052260043561051d81610149565b610cdf565b83519182529091166020820152f35b3461015b575f8060031936011261059057806001546001600160a01b03196001600160a01b03821691610565338414610c32565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b3461015b57602036600319011261015b576105ac6101b0565b6001600160a01b03906105c482600154163314610c32565b166001600160a01b031960085416176008555f80f35b3461015b575f36600319011261015b5760206001600160a01b0360015416604051908152f35b3461015b57602036600319011261015b5767ffffffffffffffff60043561062681610149565b165f526002602052602060405f2054604051908152f35b3461015b5761064b36610353565b5f52600560205260206001600160a01b0360405f205416604051908152f35b3461015b57604036600319011261015b576106db60043561068a81610149565b61069261016e565b67ffffffffffffffff6001600160a01b03926106b384600154163314610c32565b165f5260056020521660405f20906001600160a01b03166001600160a01b0319825416179055565b005b3461015b575f36600319011261015b57602067ffffffffffffffff60035416604051908152f35b3461015b57606036600319011261015b5760043561072181610149565b61072961016e565b67ffffffffffffffff60443581811161015b5761074a903690600401610270565b82600354169361076182848887461685338b6118c2565b945f5260026020528460405f205583600354169384146107ec5761034f956107d97fd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc5669387956107cb6001890167ffffffffffffffff1667ffffffffffffffff196003541617600355565b60405194859433908661091a565b0390a36040519081529081906020820190565b6108e6565b3461015b57602036600319011261015b5761080a6101b0565b6001600160a01b0361082181600154163314610c32565b811615610831576106db90611e9f565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461015b57602036600319011261015b576004355f52600460205260ff60405f20541660405160038210156108d2576020918152f35b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b908060209392818452848401375f828201840152601f01601f1916010190565b9091610953959367ffffffffffffffff6080941683526001600160a01b03809216602084015216604082015281606082015201916108fa565b90565b1561095d57565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b92959093969194976109b860025f541415610956565b60025f556109ca898989898989610d70565b9a90936109d686610cdf565b50938415610abc57610ab29c610a598795610aa795610a9b610a81610a7b610a69610a648f8b610aad9f8c610a50610aa29f94610a5f9f610a5994610a2b610a24610a5f99610a3894610e8d565b3691610ef6565b6020815191012014611074565b67ffffffffffffffff165f52600760205260405f2090565b54923691610f9c565b90611789565b611af9565b611b1f565b610a7660048251146110e6565b611158565b51611c14565b610a8e610a248486610e8d565b6020815191012014610f2c565b3691610f9c565b611c14565b1461101c565b611450565b9061016c60015f55565b60405162461bcd60e51b815260206004820152602d60248201527f4d6573736167654272696467653a20657865637574696f6e207374617465207260448201527f6f6f74206e6f7420666f756e64000000000000000000000000000000000000006064820152608490fd5b929590939691949760c090610b4060025f541415610956565b60025f55610b528a8a8a8a8a8a610d70565b939094610b76610b6a6008546001600160a01b031690565b6001600160a01b031690565b91610b986040519e8f9586948594630b885e5360e01b86528c60048701611212565b03915afa988915610c2d57610ab299610aad926020925f92610bf9575b50610bc590606083015114611248565b610bd48460808301511461129e565b0151610bf28467ffffffffffffffff165f52600760205260405f2090565b54146112f6565b610bc5919250610c1f9060c03d8111610c26575b610c178183610cb2565b810190611199565b9190610bb5565b503d610c0d565b610cd4565b15610c3957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff821117610cad57604052565b610c7d565b90601f8019910116810190811067ffffffffffffffff821117610cad57604052565b6040513d5f823e3d90fd5b9067ffffffffffffffff5f92168252600560205260406004816001600160a01b0381862054168151928380926321d362d360e11b82525afa938415610c2d5780928195610d2e575b5050509190565b919450915083813d8111610d69575b610d478183610cb2565b8101031261059057506020825192015191610d6183610149565b5f8080610d27565b503d610d3d565b610d8b94929196959367ffffffffffffffff461692886118c2565b91825f52600460205260ff60405f20541660038110156108d257610e0e576040519081610dd4602082019283602060029193929367ffffffffffffffff60408201951681520152565b0391610de8601f1993848101835282610cb2565b51902060408051602081019283529281018352909190610e089082610cb2565b51902090565b60405162461bcd60e51b815260206004820152602760248201527f4d6573736167654272696467653a206d65737361676520616c7265616479206560448201527f78656375746564000000000000000000000000000000000000000000000000006064820152608490fd5b634e487b7160e01b5f52603260045260245ffd5b9015610ec857803590601e198136030182121561015b57019081359167ffffffffffffffff831161015b57602001823603811361015b579190565b610e79565b6040519061016c82610c91565b67ffffffffffffffff8111610cad57601f01601f191660200190565b929192610f0282610eda565b91610f106040519384610cb2565b82948184528183011161015b578281602093845f960137010152565b15610f3357565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20696e76616c69642073746f7261676520726044820152621bdbdd60ea1b6064820152608490fd5b67ffffffffffffffff8111610cad5760051b60200190565b92919092610fa984610f84565b91610fb76040519384610cb2565b829480845260208094019060051b83019282841161015b5780915b848310610fe157505050505050565b823567ffffffffffffffff811161015b57820184601f8201121561015b5786916110118683858095359101610ef6565b815201920191610fd2565b1561102357565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20696e76616c6964206d65737361676520686044820152620c2e6d60eb1b6064820152608490fd5b1561107b57565b60405162461bcd60e51b815260206004820152602960248201527f4d6573736167654272696467653a20696e76616c6964206163636f756e74207060448201527f726f6f6620726f6f7400000000000000000000000000000000000000000000006064820152608490fd5b156110ed57565b60405162461bcd60e51b815260206004820152602f60248201527f4d6573736167654272696467653a20696e76616c6964206163636f756e74206460448201527f65636f6465642066726f6d20524c5000000000000000000000000000000000006064820152608490fd5b805160021015610ec85760600190565b805115610ec85760200190565b805160011015610ec85760400190565b8051821015610ec85760209160051b010190565b908160c091031261015b576040519060c082019082821067ffffffffffffffff831117610cad5760a09160405280516111d181610149565b835260208101516020840152604081015160408401526060810151606084015260808101516080840152015163ffffffff8116810361015b5760a082015290565b9391610953959367ffffffffffffffff61123a931686526060602087015260608601916108fa565b9260408185039101526108fa565b1561124f57565b60405162461bcd60e51b815260206004820152602160248201527f4d6573736167654272696467653a20736c6f74206b6579206e6f74206d6174636044820152600d60fb1b6064820152608490fd5b156112a557565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20736c6f742076616c7565206e6f74206d616044820152620e8c6d60eb1b6064820152608490fd5b156112fd57565b60405162461bcd60e51b815260206004820152602560248201527f4d6573736167654272696467653a2073726320636f6e7472616374206e6f742060448201527f6d617463680000000000000000000000000000000000000000000000000000006064820152608490fd5b939260609367ffffffffffffffff6113a1939897981686526001600160a01b0380941660208701526080604087015260808601916108fa565b9416910152565b3d156113d2573d906113b982610eda565b916113c76040519384610cb2565b82523d5f602084013e565b606090565b9081602091031261015b5751801515810361015b5790565b9060038110156108d25760ff80198354169116179055565b9490916114489367ffffffffffffffff608096949998991687526001600160a01b03809216602088015216604086015260a0606086015260a08501916108fa565b931515910152565b939590949291925f604051905f8060208401632bb2568560e21b8152611490856114828d8a8a8d339360248701611368565b03601f198101875286610cb2565b5a945190828d5af1916114a16113a8565b9215611532575050927fbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d9492611522926114ed8660208067ffffffffffffffff995183010191016113d7565b998a935b84156115285761151460015b61150f8c5f52600460205260405f2090565b6113ef565b604051978897169a87611407565b0390a390565b61151460026114fd565b92819967ffffffffffffffff966115717fbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d99979495611522978c611614565b6114f1565b60bf198101919082116107ec57565b607f198101919082116107ec57565b60200390602082116107ec57565b5f198101919082116107ec57565b60f6198101919082116107ec57565b60b6198101919082116107ec57565b5f5b8381106115df5750505f910152565b81810151838201526020016115d0565b90602091611608815180928185528580860191016115ce565b601f01601f1916010190565b905a60095445034581116107ec5782109182611688575b50506116865761165b7fc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e92611952565b9061166582611a18565b61168160405192839283526040602084015260408301906115ef565b0390a1565bfe5b60061c101590505f8061162b565b1561169d57565b60405162461bcd60e51b815260206004820152602760248201527f4d6573736167654272696467653a2049696e76616c696420524c50206c69737460448201527f206c656e677468000000000000000000000000000000000000000000000000006064820152608490fd5b90600182018092116107ec57565b919082018092116107ec57565b5f1981146107ec5760010190565b1561173857565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a206e6f64652068617368206d69736d6174636044820152621a195960ea1b6064820152608490fd5b905f9061179581611168565b51926117a4610a648495611af9565b938451601181145f1461180e575090919293610a646117e76117e1610a7b6117a494600f886117d289611723565b98603f0360021b1c1690611185565b96611723565b956118046117f58888611185565b51918251602084012014611731565b9594939295611af9565b600261181a9114611696565b61183d61183761183261182c88611168565b51611c82565b61187d565b92611716565b9015611853575050505061182c61095391611175565b90919293610a646117e76117e1610a7b6117a494611175565b908151811015610ec8570160200190565b90815115610ec857602082015160fc1c91515f1981019081116107ec578060011b90808204600214901517156107ec576001831681018091116107ec57600190921190565b949580919660609493610e0896604051988996602088019b8c947fffffffffffffffff0000000000000000000000000000000000000000000000009586809560c01b1690526bffffffffffffffffffffffff1980928c1b1660288b01528a1b16603c89015260c01b16605087015260c01b1660588501528484013781015f83820152036040810184520182610cb2565b60448151106119cd5760048101518101906020816024840193031261015b5760248101519067ffffffffffffffff821161015b57018160438201121561015b5760248101516119a081610eda565b926119ae6040519485610cb2565b8184526044828401011161015b576109539160446020850191016115ce565b506040516119da81610c91565b601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b9060206109539281815201906115ef565b604051611a2481610c91565b600b81527f4d53473a3a41424f52543a0000000000000000000000000000000000000000006020820152600b82511015611a5c575050565b5f5b8151811015611ac357611a82611a74828561186c565b516001600160f81b03191690565b611a9f611a92611a74848661186c565b6001600160f81b03191690565b6001600160f81b031990911603611abe57611ab990611723565b611a5e565b505050565b60405162461bcd60e51b815280611add8560048301611a07565b0390fd5b60405190611aee82610c91565b5f6020838281520152565b611b01611ae1565b50602081519160405192611b1484610c91565b835201602082015290565b611b2881611bf0565b1561015b57611b3681611ccf565b611b3f81610f84565b91611b4d6040519384610cb2565b818352601f19611b5c83610f84565b015f5b818110611bd9575050611b80602080920151611b7a81611db5565b90611716565b5f905b838210611b91575050505090565b611bcd81611ba1611bd393611d30565b90611baa610ecd565b8281528187820152611bbc868a611185565b52611bc78589611185565b50611716565b91611723565b90611b83565b602090611be4611ae1565b82828801015201611b5f565b805115611c0f57602060c0910151515f1a10611c0b57600190565b5f90565b505f90565b80518015159081611c4a575b501561015b57611c2f90611c56565b90519060208110611c3e575090565b6020036101000a900490565b6021915011155f611c20565b906020820191611c668351611db5565b9251908382018092116107ec57519283039283116107ec579190565b80511561015b57611c9561095391611c56565b611ca181939293610eda565b92611caf6040519485610cb2565b818452601f19611cbe83610eda565b013660208601378360200190611e22565b805115611c0f575f9060208101908151611ce881611db5565b81018091116107ec579151905181018091116107ec5791905b828110611d0e5750905090565b611d1781611d30565b81018091116107ec57611d2a9091611723565b90611d01565b80515f1a906080821015611d45575050600190565b60b8821015611d605750611d5b61095391611585565b611708565b9060c0811015611d845760b51991600160b783602003016101000a91015104010190565b9060f8821015611d9b5750611d5b61095391611576565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015611dc657505f90565b60b881108015611dfd575b15611ddc5750600190565b60c0811015611df157611d5b610953916115bf565b611d5b610953916115b0565b5060c08110158015611dd1575060f88110611dd1565b601f81116107ec576101000a90565b929091928315611e995792915b602093848410611e6457805182528481018091116107ec579381018091116107ec5791601f1981019081116107ec5791611e2f565b9193509180611e7257505050565b611e86611e81611e8b92611594565b611e13565b6115a2565b905182518216911916179052565b50915050565b600154906001600160a01b0380911691826001600160a01b0319821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a356fea2646970667358221220c1c17d6aed0b3e87c102e99468c362280aa40753d64407692b6f5fa86d7dfbd764736f6c63430008140033",
}

// MessageBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageBridgeMetaData.ABI instead.
var MessageBridgeABI = MessageBridgeMetaData.ABI

// MessageBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MessageBridgeMetaData.Bin instead.
var MessageBridgeBin = MessageBridgeMetaData.Bin

// DeployMessageBridge deploys a new Ethereum contract, binding an instance of MessageBridge to it.
func DeployMessageBridge(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MessageBridge, error) {
	parsed, err := MessageBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MessageBridgeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MessageBridge{MessageBridgeCaller: MessageBridgeCaller{contract: contract}, MessageBridgeTransactor: MessageBridgeTransactor{contract: contract}, MessageBridgeFilterer: MessageBridgeFilterer{contract: contract}}, nil
}

// MessageBridge is an auto generated Go binding around an Ethereum contract.
type MessageBridge struct {
	MessageBridgeCaller     // Read-only binding to the contract
	MessageBridgeTransactor // Write-only binding to the contract
	MessageBridgeFilterer   // Log filterer for contract events
}

// MessageBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageBridgeSession struct {
	Contract     *MessageBridge    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageBridgeCallerSession struct {
	Contract *MessageBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// MessageBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageBridgeTransactorSession struct {
	Contract     *MessageBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// MessageBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageBridgeRaw struct {
	Contract *MessageBridge // Generic contract binding to access the raw methods on
}

// MessageBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageBridgeCallerRaw struct {
	Contract *MessageBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// MessageBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageBridgeTransactorRaw struct {
	Contract *MessageBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageBridge creates a new instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridge(address common.Address, backend bind.ContractBackend) (*MessageBridge, error) {
	contract, err := bindMessageBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageBridge{MessageBridgeCaller: MessageBridgeCaller{contract: contract}, MessageBridgeTransactor: MessageBridgeTransactor{contract: contract}, MessageBridgeFilterer: MessageBridgeFilterer{contract: contract}}, nil
}

// NewMessageBridgeCaller creates a new read-only instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeCaller(address common.Address, caller bind.ContractCaller) (*MessageBridgeCaller, error) {
	contract, err := bindMessageBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeCaller{contract: contract}, nil
}

// NewMessageBridgeTransactor creates a new write-only instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageBridgeTransactor, error) {
	contract, err := bindMessageBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeTransactor{contract: contract}, nil
}

// NewMessageBridgeFilterer creates a new log filterer instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageBridgeFilterer, error) {
	contract, err := bindMessageBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeFilterer{contract: contract}, nil
}

// bindMessageBridge binds a generic wrapper to an already deployed contract.
func bindMessageBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridge *MessageBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridge.Contract.MessageBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridge *MessageBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.Contract.MessageBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridge *MessageBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridge.Contract.MessageBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridge *MessageBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridge *MessageBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridge *MessageBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridge.Contract.contract.Transact(opts, method, params...)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeCaller) GetExecutionStateRootAndSlot(opts *bind.CallOpts, _chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "getExecutionStateRootAndSlot", _chainId)

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeSession) GetExecutionStateRootAndSlot(_chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _MessageBridge.Contract.GetExecutionStateRootAndSlot(&_MessageBridge.CallOpts, _chainId)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeCallerSession) GetExecutionStateRootAndSlot(_chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _MessageBridge.Contract.GetExecutionStateRootAndSlot(&_MessageBridge.CallOpts, _chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCaller) LightClients(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "lightClients", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeSession) LightClients(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.LightClients(&_MessageBridge.CallOpts, arg0)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) LightClients(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.LightClients(&_MessageBridge.CallOpts, arg0)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeCaller) Nonce(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "nonce")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeSession) Nonce() (uint64, error) {
	return _MessageBridge.Contract.Nonce(&_MessageBridge.CallOpts)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeCallerSession) Nonce() (uint64, error) {
	return _MessageBridge.Contract.Nonce(&_MessageBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeSession) Owner() (common.Address, error) {
	return _MessageBridge.Contract.Owner(&_MessageBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) Owner() (common.Address, error) {
	return _MessageBridge.Contract.Owner(&_MessageBridge.CallOpts)
}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeCaller) PreExecuteMessageGasUsage(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "preExecuteMessageGasUsage")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeSession) PreExecuteMessageGasUsage() (*big.Int, error) {
	return _MessageBridge.Contract.PreExecuteMessageGasUsage(&_MessageBridge.CallOpts)
}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeCallerSession) PreExecuteMessageGasUsage() (*big.Int, error) {
	return _MessageBridge.Contract.PreExecuteMessageGasUsage(&_MessageBridge.CallOpts)
}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeCaller) ReceivedMessages(opts *bind.CallOpts, arg0 [32]byte) (uint8, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "receivedMessages", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeSession) ReceivedMessages(arg0 [32]byte) (uint8, error) {
	return _MessageBridge.Contract.ReceivedMessages(&_MessageBridge.CallOpts, arg0)
}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeCallerSession) ReceivedMessages(arg0 [32]byte) (uint8, error) {
	return _MessageBridge.Contract.ReceivedMessages(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCaller) RemoteMessageBridgeHashes(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "remoteMessageBridgeHashes", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeSession) RemoteMessageBridgeHashes(arg0 *big.Int) ([32]byte, error) {
	return _MessageBridge.Contract.RemoteMessageBridgeHashes(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCallerSession) RemoteMessageBridgeHashes(arg0 *big.Int) ([32]byte, error) {
	return _MessageBridge.Contract.RemoteMessageBridgeHashes(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCaller) RemoteMessageBridges(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "remoteMessageBridges", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeSession) RemoteMessageBridges(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.RemoteMessageBridges(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) RemoteMessageBridges(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.RemoteMessageBridges(&_MessageBridge.CallOpts, arg0)
}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCaller) SentMessages(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "sentMessages", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeSession) SentMessages(arg0 uint64) ([32]byte, error) {
	return _MessageBridge.Contract.SentMessages(&_MessageBridge.CallOpts, arg0)
}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCallerSession) SentMessages(arg0 uint64) ([32]byte, error) {
	return _MessageBridge.Contract.SentMessages(&_MessageBridge.CallOpts, arg0)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeSession) SlotValueVerifier() (common.Address, error) {
	return _MessageBridge.Contract.SlotValueVerifier(&_MessageBridge.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) SlotValueVerifier() (common.Address, error) {
	return _MessageBridge.Contract.SlotValueVerifier(&_MessageBridge.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, _srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "executeMessage", _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeSession) ExecuteMessage(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessage(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeTransactorSession) ExecuteMessage(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessage(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeTransactor) ExecuteMessageWithZkProof(opts *bind.TransactOpts, _srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "executeMessageWithZkProof", _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeSession) ExecuteMessageWithZkProof(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessageWithZkProof(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeTransactorSession) ExecuteMessageWithZkProof(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessageWithZkProof(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _MessageBridge.Contract.RenounceOwnership(&_MessageBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _MessageBridge.Contract.RenounceOwnership(&_MessageBridge.TransactOpts)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeTransactor) SendMessage(opts *bind.TransactOpts, _dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "sendMessage", _dstChainId, _receiver, _message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeSession) SendMessage(_dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.SendMessage(&_MessageBridge.TransactOpts, _dstChainId, _receiver, _message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeTransactorSession) SendMessage(_dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.SendMessage(&_MessageBridge.TransactOpts, _dstChainId, _receiver, _message)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeTransactor) SetLightClient(opts *bind.TransactOpts, _chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setLightClient", _chainId, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeSession) SetLightClient(_chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetLightClient(&_MessageBridge.TransactOpts, _chainId, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetLightClient(_chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetLightClient(&_MessageBridge.TransactOpts, _chainId, _lightClient)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeTransactor) SetPreExecuteMessageGasUsage(opts *bind.TransactOpts, _usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setPreExecuteMessageGasUsage", _usage)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeSession) SetPreExecuteMessageGasUsage(_usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetPreExecuteMessageGasUsage(&_MessageBridge.TransactOpts, _usage)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetPreExecuteMessageGasUsage(_usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetPreExecuteMessageGasUsage(&_MessageBridge.TransactOpts, _usage)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeTransactor) SetRemoteMessageBridge(opts *bind.TransactOpts, _chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setRemoteMessageBridge", _chainId, _remoteMessageBridge)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeSession) SetRemoteMessageBridge(_chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetRemoteMessageBridge(&_MessageBridge.TransactOpts, _chainId, _remoteMessageBridge)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetRemoteMessageBridge(_chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetRemoteMessageBridge(&_MessageBridge.TransactOpts, _chainId, _remoteMessageBridge)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeTransactor) SetSlotValueVerifier(opts *bind.TransactOpts, _slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setSlotValueVerifier", _slotValueVerifier)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeSession) SetSlotValueVerifier(_slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetSlotValueVerifier(&_MessageBridge.TransactOpts, _slotValueVerifier)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetSlotValueVerifier(_slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetSlotValueVerifier(&_MessageBridge.TransactOpts, _slotValueVerifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.TransferOwnership(&_MessageBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.TransferOwnership(&_MessageBridge.TransactOpts, newOwner)
}

// MessageBridgeMessageCallRevertedIterator is returned from FilterMessageCallReverted and is used to iterate over the raw logs and unpacked data for MessageCallReverted events raised by the MessageBridge contract.
type MessageBridgeMessageCallRevertedIterator struct {
	Event *MessageBridgeMessageCallReverted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageCallRevertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageCallReverted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageCallReverted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageCallRevertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageCallRevertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageCallReverted represents a MessageCallReverted event raised by the MessageBridge contract.
type MessageBridgeMessageCallReverted struct {
	MessageId [32]byte
	Reason    string
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMessageCallReverted is a free log retrieval operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageCallReverted(opts *bind.FilterOpts) (*MessageBridgeMessageCallRevertedIterator, error) {

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageCallRevertedIterator{contract: _MessageBridge.contract, event: "MessageCallReverted", logs: logs, sub: sub}, nil
}

// WatchMessageCallReverted is a free log subscription operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageCallReverted(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageCallReverted) (event.Subscription, error) {

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageCallReverted)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageCallReverted is a log parse operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageCallReverted(log types.Log) (*MessageBridgeMessageCallReverted, error) {
	event := new(MessageBridgeMessageCallReverted)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeMessageExecutedIterator is returned from FilterMessageExecuted and is used to iterate over the raw logs and unpacked data for MessageExecuted events raised by the MessageBridge contract.
type MessageBridgeMessageExecutedIterator struct {
	Event *MessageBridgeMessageExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageExecuted represents a MessageExecuted event raised by the MessageBridge contract.
type MessageBridgeMessageExecuted struct {
	MessageId  [32]byte
	Nonce      *big.Int
	SrcChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Success    bool
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageExecuted is a free log retrieval operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageExecuted(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*MessageBridgeMessageExecutedIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageExecutedIterator{contract: _MessageBridge.contract, event: "MessageExecuted", logs: logs, sub: sub}, nil
}

// WatchMessageExecuted is a free log subscription operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageExecuted(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageExecuted, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageExecuted)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageExecuted is a log parse operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageExecuted(log types.Log) (*MessageBridgeMessageExecuted, error) {
	event := new(MessageBridgeMessageExecuted)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeMessageSentIterator is returned from FilterMessageSent and is used to iterate over the raw logs and unpacked data for MessageSent events raised by the MessageBridge contract.
type MessageBridgeMessageSentIterator struct {
	Event *MessageBridgeMessageSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageSent represents a MessageSent event raised by the MessageBridge contract.
type MessageBridgeMessageSent struct {
	MessageId  [32]byte
	Nonce      *big.Int
	DstChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageSent is a free log retrieval operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageSent(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*MessageBridgeMessageSentIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageSentIterator{contract: _MessageBridge.contract, event: "MessageSent", logs: logs, sub: sub}, nil
}

// WatchMessageSent is a free log subscription operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageSent(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageSent, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageSent)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageSent is a log parse operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageSent(log types.Log) (*MessageBridgeMessageSent, error) {
	event := new(MessageBridgeMessageSent)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MessageBridge contract.
type MessageBridgeOwnershipTransferredIterator struct {
	Event *MessageBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the MessageBridge contract.
type MessageBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MessageBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeOwnershipTransferredIterator{contract: _MessageBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MessageBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeOwnershipTransferred)
				if err := _MessageBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*MessageBridgeOwnershipTransferred, error) {
	event := new(MessageBridgeOwnershipTransferred)
	if err := _MessageBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeAddressMetaData contains all meta data concerning the MessageBridgeAddress contract.
var MessageBridgeAddressMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageBridgeAddressABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageBridgeAddressMetaData.ABI instead.
var MessageBridgeAddressABI = MessageBridgeAddressMetaData.ABI

// MessageBridgeAddress is an auto generated Go binding around an Ethereum contract.
type MessageBridgeAddress struct {
	MessageBridgeAddressCaller     // Read-only binding to the contract
	MessageBridgeAddressTransactor // Write-only binding to the contract
	MessageBridgeAddressFilterer   // Log filterer for contract events
}

// MessageBridgeAddressCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageBridgeAddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageBridgeAddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageBridgeAddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageBridgeAddressSession struct {
	Contract     *MessageBridgeAddress // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MessageBridgeAddressCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageBridgeAddressCallerSession struct {
	Contract *MessageBridgeAddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// MessageBridgeAddressTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageBridgeAddressTransactorSession struct {
	Contract     *MessageBridgeAddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// MessageBridgeAddressRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageBridgeAddressRaw struct {
	Contract *MessageBridgeAddress // Generic contract binding to access the raw methods on
}

// MessageBridgeAddressCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageBridgeAddressCallerRaw struct {
	Contract *MessageBridgeAddressCaller // Generic read-only contract binding to access the raw methods on
}

// MessageBridgeAddressTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageBridgeAddressTransactorRaw struct {
	Contract *MessageBridgeAddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageBridgeAddress creates a new instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddress(address common.Address, backend bind.ContractBackend) (*MessageBridgeAddress, error) {
	contract, err := bindMessageBridgeAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddress{MessageBridgeAddressCaller: MessageBridgeAddressCaller{contract: contract}, MessageBridgeAddressTransactor: MessageBridgeAddressTransactor{contract: contract}, MessageBridgeAddressFilterer: MessageBridgeAddressFilterer{contract: contract}}, nil
}

// NewMessageBridgeAddressCaller creates a new read-only instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressCaller(address common.Address, caller bind.ContractCaller) (*MessageBridgeAddressCaller, error) {
	contract, err := bindMessageBridgeAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressCaller{contract: contract}, nil
}

// NewMessageBridgeAddressTransactor creates a new write-only instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageBridgeAddressTransactor, error) {
	contract, err := bindMessageBridgeAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressTransactor{contract: contract}, nil
}

// NewMessageBridgeAddressFilterer creates a new log filterer instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageBridgeAddressFilterer, error) {
	contract, err := bindMessageBridgeAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressFilterer{contract: contract}, nil
}

// bindMessageBridgeAddress binds a generic wrapper to an already deployed contract.
func bindMessageBridgeAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageBridgeAddressMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridgeAddress *MessageBridgeAddressCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridgeAddress.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridgeAddress *MessageBridgeAddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridgeAddress *MessageBridgeAddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridgeAddress.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressSession) MessageBridge() (common.Address, error) {
	return _MessageBridgeAddress.Contract.MessageBridge(&_MessageBridgeAddress.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressCallerSession) MessageBridge() (common.Address, error) {
	return _MessageBridgeAddress.Contract.MessageBridge(&_MessageBridgeAddress.CallOpts)
}

// MessageReceiverAppMetaData contains all meta data concerning the MessageReceiverApp contract.
var MessageReceiverAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageReceiverAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageReceiverAppMetaData.ABI instead.
var MessageReceiverAppABI = MessageReceiverAppMetaData.ABI

// MessageReceiverApp is an auto generated Go binding around an Ethereum contract.
type MessageReceiverApp struct {
	MessageReceiverAppCaller     // Read-only binding to the contract
	MessageReceiverAppTransactor // Write-only binding to the contract
	MessageReceiverAppFilterer   // Log filterer for contract events
}

// MessageReceiverAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageReceiverAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageReceiverAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageReceiverAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageReceiverAppSession struct {
	Contract     *MessageReceiverApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// MessageReceiverAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageReceiverAppCallerSession struct {
	Contract *MessageReceiverAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// MessageReceiverAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageReceiverAppTransactorSession struct {
	Contract     *MessageReceiverAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// MessageReceiverAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageReceiverAppRaw struct {
	Contract *MessageReceiverApp // Generic contract binding to access the raw methods on
}

// MessageReceiverAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageReceiverAppCallerRaw struct {
	Contract *MessageReceiverAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageReceiverAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageReceiverAppTransactorRaw struct {
	Contract *MessageReceiverAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageReceiverApp creates a new instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverApp(address common.Address, backend bind.ContractBackend) (*MessageReceiverApp, error) {
	contract, err := bindMessageReceiverApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverApp{MessageReceiverAppCaller: MessageReceiverAppCaller{contract: contract}, MessageReceiverAppTransactor: MessageReceiverAppTransactor{contract: contract}, MessageReceiverAppFilterer: MessageReceiverAppFilterer{contract: contract}}, nil
}

// NewMessageReceiverAppCaller creates a new read-only instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppCaller(address common.Address, caller bind.ContractCaller) (*MessageReceiverAppCaller, error) {
	contract, err := bindMessageReceiverApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppCaller{contract: contract}, nil
}

// NewMessageReceiverAppTransactor creates a new write-only instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageReceiverAppTransactor, error) {
	contract, err := bindMessageReceiverApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppTransactor{contract: contract}, nil
}

// NewMessageReceiverAppFilterer creates a new log filterer instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageReceiverAppFilterer, error) {
	contract, err := bindMessageReceiverApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppFilterer{contract: contract}, nil
}

// bindMessageReceiverApp binds a generic wrapper to an already deployed contract.
func bindMessageReceiverApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageReceiverAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageReceiverApp *MessageReceiverAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageReceiverApp.Contract.MessageReceiverAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageReceiverApp *MessageReceiverAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.MessageReceiverAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageReceiverApp *MessageReceiverAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.MessageReceiverAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageReceiverApp *MessageReceiverAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageReceiverApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageReceiverApp *MessageReceiverAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageReceiverApp *MessageReceiverAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageReceiverApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppSession) MessageBridge() (common.Address, error) {
	return _MessageReceiverApp.Contract.MessageBridge(&_MessageReceiverApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageReceiverApp.Contract.MessageBridge(&_MessageReceiverApp.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.ExecuteMessage(&_MessageReceiverApp.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.ExecuteMessage(&_MessageReceiverApp.TransactOpts, srcChainId, sender, message, executor)
}

// MessageSenderAppMetaData contains all meta data concerning the MessageSenderApp contract.
var MessageSenderAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageSenderAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageSenderAppMetaData.ABI instead.
var MessageSenderAppABI = MessageSenderAppMetaData.ABI

// MessageSenderApp is an auto generated Go binding around an Ethereum contract.
type MessageSenderApp struct {
	MessageSenderAppCaller     // Read-only binding to the contract
	MessageSenderAppTransactor // Write-only binding to the contract
	MessageSenderAppFilterer   // Log filterer for contract events
}

// MessageSenderAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageSenderAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageSenderAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageSenderAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageSenderAppSession struct {
	Contract     *MessageSenderApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageSenderAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageSenderAppCallerSession struct {
	Contract *MessageSenderAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// MessageSenderAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageSenderAppTransactorSession struct {
	Contract     *MessageSenderAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// MessageSenderAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageSenderAppRaw struct {
	Contract *MessageSenderApp // Generic contract binding to access the raw methods on
}

// MessageSenderAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageSenderAppCallerRaw struct {
	Contract *MessageSenderAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageSenderAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageSenderAppTransactorRaw struct {
	Contract *MessageSenderAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageSenderApp creates a new instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderApp(address common.Address, backend bind.ContractBackend) (*MessageSenderApp, error) {
	contract, err := bindMessageSenderApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageSenderApp{MessageSenderAppCaller: MessageSenderAppCaller{contract: contract}, MessageSenderAppTransactor: MessageSenderAppTransactor{contract: contract}, MessageSenderAppFilterer: MessageSenderAppFilterer{contract: contract}}, nil
}

// NewMessageSenderAppCaller creates a new read-only instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppCaller(address common.Address, caller bind.ContractCaller) (*MessageSenderAppCaller, error) {
	contract, err := bindMessageSenderApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppCaller{contract: contract}, nil
}

// NewMessageSenderAppTransactor creates a new write-only instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageSenderAppTransactor, error) {
	contract, err := bindMessageSenderApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppTransactor{contract: contract}, nil
}

// NewMessageSenderAppFilterer creates a new log filterer instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageSenderAppFilterer, error) {
	contract, err := bindMessageSenderApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppFilterer{contract: contract}, nil
}

// bindMessageSenderApp binds a generic wrapper to an already deployed contract.
func bindMessageSenderApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageSenderAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageSenderApp *MessageSenderAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageSenderApp.Contract.MessageSenderAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageSenderApp *MessageSenderAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.MessageSenderAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageSenderApp *MessageSenderAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.MessageSenderAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageSenderApp *MessageSenderAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageSenderApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageSenderApp *MessageSenderAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageSenderApp *MessageSenderAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageSenderApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppSession) MessageBridge() (common.Address, error) {
	return _MessageSenderApp.Contract.MessageBridge(&_MessageSenderApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageSenderApp.Contract.MessageBridge(&_MessageSenderApp.CallOpts)
}

// MintableERC20MetaData contains all meta data concerning the MintableERC20 contract.
var MintableERC20MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6040608081523462000424576200131d803803806200001e8162000428565b9283398101608082820312620004245781516001600160401b039290838111620004245782620000509183016200044e565b92602092838301519082821162000424576200006e9184016200044e565b858301519260ff84168403620004245760600151948051928084116200032f5760038054946001938487811c9716801562000419575b8988101462000405578190601f97888111620003b2575b5089908883116001146200034f575f9262000343575b50505f1982841b1c191690841b1781555b83519182116200032f5760049384548481811c9116801562000324575b898210146200031157868111620002c9575b50879086841160011462000262579383949184925f9562000256575b50501b925f19911b1c19161781555b600554865193336001600160a01b0383167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a360ff60a01b60a09190911b1660ff60a01b19339081166001600160a81b0319939093169290921717600555600680546001600160a01b031916821790551562000219575050507fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef5f91620001e884600254620004be565b60025533835282815284832062000201858254620004be565b905584519384523393a351610e3c9081620004e18239f35b9260649362461bcd60e51b845283015260248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152fd5b015193505f806200012d565b9190601f19841692865f52848a5f20945f5b8c89838310620002b1575050501062000297575b50505050811b0181556200013c565b01519060f8845f19921b161c191690555f80808062000288565b86860151895590970196948501948893500162000274565b855f52885f208780860160051c8201928b871062000307575b0160051c019085905b828110620002fb57505062000111565b5f8155018590620002eb565b92508192620002e2565b602286634e487b7160e01b5f525260245ffd5b90607f1690620000ff565b634e487b7160e01b5f52604160045260245ffd5b015190505f80620000d1565b90869350601f19831691855f528b5f20925f5b8d8282106200039b575050841162000383575b505050811b018155620000e2565b01515f1983861b60f8161c191690555f808062000375565b8385015186558a9790950194938401930162000362565b909150835f52895f208880850160051c8201928c8610620003fb575b918891869594930160051c01915b828110620003ec575050620000bb565b5f8155859450889101620003dc565b92508192620003ce565b634e487b7160e01b5f52602260045260245ffd5b96607f1696620000a4565b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176200032f57604052565b919080601f84011215620004245782516001600160401b0381116200032f5760209062000484601f8201601f1916830162000428565b9281845282828701011162000424575f5b818110620004aa5750825f9394955001015290565b858101830151848201840152820162000495565b91908201809211620004cc57565b634e487b7160e01b5f52601160045260245ffdfe608060409080825260049182361015610016575f80fd5b5f92833560e01c92836306fdde03146107f25750826307546172146107ca578263095ea7b3146107a057826318160ddd1461078157826323b872dd14610744578263313ce5671461071f57826339509351146106d057826340c10f19146105b157826342966c681461059357826370a082311461055d578263715018a6146104f157826379cc6790146104be5782638da5cb5b1461049657826395d89b4114610377578263a457c2d7146102bb578263a9059cbb1461028a578263dd62ed3e1461023d578263f2fde38b1461014b57505063fca3b5aa146100f5575f80fd5b346101485760203660031901126101485761010e610911565b6001600160a01b039061012682600554163314610941565b1673ffffffffffffffffffffffffffffffffffffffff19600654161760065580f35b80fd5b9091503461023957602036600319011261023957610167610911565b90600554906001600160a01b0380831693610183338614610941565b169384156101d057505073ffffffffffffffffffffffffffffffffffffffff191682176005557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b8382346102865780600319360112610286578060209261025b610911565b61026361092b565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b8382346102865780600319360112610286576020906102b46102aa610911565b60243590336109ad565b5160018152f35b83346101485782600319360112610148576102d4610911565b91836024359233815260016020528181206001600160a01b038616825260205220549082821061030e576020856102b48585038733610b50565b608490602086519162461bcd60e51b8352820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152fd5b838234610286578160031936011261028657805190828454600181811c9080831692831561048c575b60209384841081146104795783885290811561045d5750600114610408575b505050829003601f01601f191682019267ffffffffffffffff8411838510176103f557508291826103f19252826108ca565b0390f35b634e487b7160e01b815260418552602490fd5b8787529192508591837f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b5b83851061044957505050508301018580806103bf565b805488860183015293019284908201610433565b60ff1916878501525050151560051b84010190508580806103bf565b634e487b7160e01b895260228a52602489fd5b91607f16916103a0565b8382346102865781600319360112610286576020906001600160a01b03600554169051908152f35b83823461028657366003190112610148576104ee6104da610911565b602435906104e9823383610c4e565b610ce2565b80f35b83346101485780600319360112610148578060055473ffffffffffffffffffffffffffffffffffffffff196001600160a01b03821691610532338414610941565b166005557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b83823461028657602036600319011261028657806020926001600160a01b03610584610911565b16815280845220549051908152f35b839034610286576020366003190112610286576104ee903533610ce2565b9150346102395780600319360112610239576105cb610911565b90602435916001600160a01b039081600654163303610682571692831561064057506020827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9261061f879560025461098c565b60025585855284835280852061063683825461098c565b905551908152a380f35b6020606492519162461bcd60e51b8352820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152fd5b825162461bcd60e51b8152602081870152602260248201527f4d696e7461626c653a2063616c6c6572206973206e6f7420746865206d696e7460448201526132b960f11b6064820152608490fd5b8382346102865780600319360112610286576102b46020926107186106f3610911565b91338152600186528481206001600160a01b038416825286528460243591205461098c565b9033610b50565b83823461028657816003193601126102865760209060ff60055460a01c169051908152f35b838234610286576060366003190112610286576020906102b4610765610911565b61076d61092b565b6044359161077c833383610c4e565b6109ad565b8382346102865781600319360112610286576020906002549051908152f35b8382346102865780600319360112610286576020906102b46107c0610911565b6024359033610b50565b8382346102865781600319360112610286576020906001600160a01b03600654169051908152f35b8491923461023957826003193601126102395782600354600181811c908083169283156108c0575b60209384841081146104795783885290811561045d575060011461086a57505050829003601f01601f191682019267ffffffffffffffff8411838510176103f557508291826103f19252826108ca565b600387529192508591837fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b5b8385106108ac57505050508301018580806103bf565b805488860183015293019284908201610896565b91607f169161081a565b602080825282518183018190529093925f5b8281106108fd57505060409293505f838284010152601f8019910116010190565b8181018601518482016040015285016108dc565b600435906001600160a01b038216820361092757565b5f80fd5b602435906001600160a01b038216820361092757565b1561094857565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b9190820180921161099957565b634e487b7160e01b5f52601160045260245ffd5b6001600160a01b03809116918215610ae55716918215610a94575f82815280602052604081205491808310610a2957604082827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef958760209652828652038282205586815220610a1e82825461098c565b9055604051908152a3565b60405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608490fd5b60405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608490fd5b60405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b03809116918215610bfd5716918215610bad5760207f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591835f526001825260405f20855f5282528060405f2055604051908152a3565b60405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608490fd5b60405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608490fd5b906001600160a01b038083165f52600160205260405f209082165f5260205260405f2054925f198403610c82575b50505050565b808410610c9d57610c94930391610b50565b5f808080610c7c565b60405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606490fd5b6001600160a01b03168015610db7575f91818352826020526040832054818110610d6757819083855284602052036040842055600254818103908111610d53577fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91602091600255604051908152a3565b634e487b7160e01b84526011600452602484fd5b60405162461bcd60e51b815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e604482015261636560f01b6064820152608490fd5b60405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f206164647265736044820152607360f81b6064820152608490fdfea2646970667358221220983a8fb28f08fc947d7b469640fa09935042e34240614ac4744a9c6c80580e4064736f6c63430008140033",
}

// MintableERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use MintableERC20MetaData.ABI instead.
var MintableERC20ABI = MintableERC20MetaData.ABI

// MintableERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MintableERC20MetaData.Bin instead.
var MintableERC20Bin = MintableERC20MetaData.Bin

// DeployMintableERC20 deploys a new Ethereum contract, binding an instance of MintableERC20 to it.
func DeployMintableERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string, decimals_ uint8, initialSupply_ *big.Int) (common.Address, *types.Transaction, *MintableERC20, error) {
	parsed, err := MintableERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MintableERC20Bin), backend, name_, symbol_, decimals_, initialSupply_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MintableERC20{MintableERC20Caller: MintableERC20Caller{contract: contract}, MintableERC20Transactor: MintableERC20Transactor{contract: contract}, MintableERC20Filterer: MintableERC20Filterer{contract: contract}}, nil
}

// MintableERC20 is an auto generated Go binding around an Ethereum contract.
type MintableERC20 struct {
	MintableERC20Caller     // Read-only binding to the contract
	MintableERC20Transactor // Write-only binding to the contract
	MintableERC20Filterer   // Log filterer for contract events
}

// MintableERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type MintableERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type MintableERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MintableERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MintableERC20Session struct {
	Contract     *MintableERC20    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MintableERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MintableERC20CallerSession struct {
	Contract *MintableERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// MintableERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MintableERC20TransactorSession struct {
	Contract     *MintableERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// MintableERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type MintableERC20Raw struct {
	Contract *MintableERC20 // Generic contract binding to access the raw methods on
}

// MintableERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MintableERC20CallerRaw struct {
	Contract *MintableERC20Caller // Generic read-only contract binding to access the raw methods on
}

// MintableERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MintableERC20TransactorRaw struct {
	Contract *MintableERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewMintableERC20 creates a new instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20(address common.Address, backend bind.ContractBackend) (*MintableERC20, error) {
	contract, err := bindMintableERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MintableERC20{MintableERC20Caller: MintableERC20Caller{contract: contract}, MintableERC20Transactor: MintableERC20Transactor{contract: contract}, MintableERC20Filterer: MintableERC20Filterer{contract: contract}}, nil
}

// NewMintableERC20Caller creates a new read-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Caller(address common.Address, caller bind.ContractCaller) (*MintableERC20Caller, error) {
	contract, err := bindMintableERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Caller{contract: contract}, nil
}

// NewMintableERC20Transactor creates a new write-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*MintableERC20Transactor, error) {
	contract, err := bindMintableERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Transactor{contract: contract}, nil
}

// NewMintableERC20Filterer creates a new log filterer instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*MintableERC20Filterer, error) {
	contract, err := bindMintableERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Filterer{contract: contract}, nil
}

// bindMintableERC20 binds a generic wrapper to an already deployed contract.
func bindMintableERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MintableERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.MintableERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20Session) Decimals() (uint8, error) {
	return _MintableERC20.Contract.Decimals(&_MintableERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20CallerSession) Decimals() (uint8, error) {
	return _MintableERC20.Contract.Decimals(&_MintableERC20.CallOpts)
}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20Caller) Minter(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "minter")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20Session) Minter() (common.Address, error) {
	return _MintableERC20.Contract.Minter(&_MintableERC20.CallOpts)
}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20CallerSession) Minter() (common.Address, error) {
	return _MintableERC20.Contract.Minter(&_MintableERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20Session) Name() (string, error) {
	return _MintableERC20.Contract.Name(&_MintableERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20CallerSession) Name() (string, error) {
	return _MintableERC20.Contract.Name(&_MintableERC20.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20Session) Owner() (common.Address, error) {
	return _MintableERC20.Contract.Owner(&_MintableERC20.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20CallerSession) Owner() (common.Address, error) {
	return _MintableERC20.Contract.Owner(&_MintableERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20Session) Symbol() (string, error) {
	return _MintableERC20.Contract.Symbol(&_MintableERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20CallerSession) Symbol() (string, error) {
	return _MintableERC20.Contract.Symbol(&_MintableERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Session) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) Burn(amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Burn(&_MintableERC20.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Burn(&_MintableERC20.TransactOpts, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "burnFrom", account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.BurnFrom(&_MintableERC20.TransactOpts, account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.BurnFrom(&_MintableERC20.TransactOpts, account, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.DecreaseAllowance(&_MintableERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.DecreaseAllowance(&_MintableERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.IncreaseAllowance(&_MintableERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.IncreaseAllowance(&_MintableERC20.TransactOpts, spender, addedValue)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) Mint(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "mint", to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, to, amount)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20Session) RenounceOwnership() (*types.Transaction, error) {
	return _MintableERC20.Contract.RenounceOwnership(&_MintableERC20.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _MintableERC20.Contract.RenounceOwnership(&_MintableERC20.TransactOpts)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20Transactor) SetMinter(opts *bind.TransactOpts, minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "setMinter", minter_)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20Session) SetMinter(minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.SetMinter(&_MintableERC20.TransactOpts, minter_)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20TransactorSession) SetMinter(minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.SetMinter(&_MintableERC20.TransactOpts, minter_)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, from, to, amount)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferOwnership(&_MintableERC20.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferOwnership(&_MintableERC20.TransactOpts, newOwner)
}

// MintableERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the MintableERC20 contract.
type MintableERC20ApprovalIterator struct {
	Event *MintableERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20Approval represents a Approval event raised by the MintableERC20 contract.
type MintableERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*MintableERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20ApprovalIterator{contract: _MintableERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *MintableERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20Approval)
				if err := _MintableERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) ParseApproval(log types.Log) (*MintableERC20Approval, error) {
	event := new(MintableERC20Approval)
	if err := _MintableERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MintableERC20OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MintableERC20 contract.
type MintableERC20OwnershipTransferredIterator struct {
	Event *MintableERC20OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20OwnershipTransferred represents a OwnershipTransferred event raised by the MintableERC20 contract.
type MintableERC20OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MintableERC20OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20OwnershipTransferredIterator{contract: _MintableERC20.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MintableERC20OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20OwnershipTransferred)
				if err := _MintableERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) ParseOwnershipTransferred(log types.Log) (*MintableERC20OwnershipTransferred, error) {
	event := new(MintableERC20OwnershipTransferred)
	if err := _MintableERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MintableERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the MintableERC20 contract.
type MintableERC20TransferIterator struct {
	Event *MintableERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20Transfer represents a Transfer event raised by the MintableERC20 contract.
type MintableERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*MintableERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20TransferIterator{contract: _MintableERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *MintableERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20Transfer)
				if err := _MintableERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) ParseTransfer(log types.Log) (*MintableERC20Transfer, error) {
	event := new(MintableERC20Transfer)
	if err := _MintableERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MockUniswapSumVolumeMetaData contains all meta data concerning the MockUniswapSumVolume contract.
var MockUniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x60808060405234601457609390816100198239f35b5f80fdfe60808060405260043610156011575f80fd5b5f90813560e01c63950650c1146025575f80fd5b34605957602036600319011260595760043573ffffffffffffffffffffffffffffffffffffffff8116036059576020918152f35b5080fdfea2646970667358221220da66c5d3d84bff56e94d50ad610722623d166ec268729a86915d3273b3f5795164736f6c63430008140033",
}

// MockUniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use MockUniswapSumVolumeMetaData.ABI instead.
var MockUniswapSumVolumeABI = MockUniswapSumVolumeMetaData.ABI

// MockUniswapSumVolumeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MockUniswapSumVolumeMetaData.Bin instead.
var MockUniswapSumVolumeBin = MockUniswapSumVolumeMetaData.Bin

// DeployMockUniswapSumVolume deploys a new Ethereum contract, binding an instance of MockUniswapSumVolume to it.
func DeployMockUniswapSumVolume(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MockUniswapSumVolume, error) {
	parsed, err := MockUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MockUniswapSumVolumeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MockUniswapSumVolume{MockUniswapSumVolumeCaller: MockUniswapSumVolumeCaller{contract: contract}, MockUniswapSumVolumeTransactor: MockUniswapSumVolumeTransactor{contract: contract}, MockUniswapSumVolumeFilterer: MockUniswapSumVolumeFilterer{contract: contract}}, nil
}

// MockUniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type MockUniswapSumVolume struct {
	MockUniswapSumVolumeCaller     // Read-only binding to the contract
	MockUniswapSumVolumeTransactor // Write-only binding to the contract
	MockUniswapSumVolumeFilterer   // Log filterer for contract events
}

// MockUniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MockUniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MockUniswapSumVolumeSession struct {
	Contract     *MockUniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MockUniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MockUniswapSumVolumeCallerSession struct {
	Contract *MockUniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// MockUniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MockUniswapSumVolumeTransactorSession struct {
	Contract     *MockUniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// MockUniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MockUniswapSumVolumeRaw struct {
	Contract *MockUniswapSumVolume // Generic contract binding to access the raw methods on
}

// MockUniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeCallerRaw struct {
	Contract *MockUniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// MockUniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeTransactorRaw struct {
	Contract *MockUniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMockUniswapSumVolume creates a new instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*MockUniswapSumVolume, error) {
	contract, err := bindMockUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolume{MockUniswapSumVolumeCaller: MockUniswapSumVolumeCaller{contract: contract}, MockUniswapSumVolumeTransactor: MockUniswapSumVolumeTransactor{contract: contract}, MockUniswapSumVolumeFilterer: MockUniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewMockUniswapSumVolumeCaller creates a new read-only instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*MockUniswapSumVolumeCaller, error) {
	contract, err := bindMockUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeCaller{contract: contract}, nil
}

// NewMockUniswapSumVolumeTransactor creates a new write-only instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*MockUniswapSumVolumeTransactor, error) {
	contract, err := bindMockUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeTransactor{contract: contract}, nil
}

// NewMockUniswapSumVolumeFilterer creates a new log filterer instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*MockUniswapSumVolumeFilterer, error) {
	contract, err := bindMockUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeFilterer{contract: contract}, nil
}

// bindMockUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindMockUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MockUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MockUniswapSumVolume *MockUniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MockUniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MockUniswapSumVolume *MockUniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MockUniswapSumVolume *MockUniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MockUniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeSession) GetAttestedSwapSumVolume(arg0 common.Address) (*big.Int, error) {
	return _MockUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_MockUniswapSumVolume.CallOpts, arg0)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(arg0 common.Address) (*big.Int, error) {
	return _MockUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_MockUniswapSumVolume.CallOpts, arg0)
}

// MsgLibMetaData contains all meta data concerning the MsgLib contract.
var MsgLibMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220c9716a9564bad8f3c124e07035a775480e03d4d70aebff25dd082b62e8b44b0b64736f6c63430008140033",
}

// MsgLibABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgLibMetaData.ABI instead.
var MsgLibABI = MsgLibMetaData.ABI

// MsgLibBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgLibMetaData.Bin instead.
var MsgLibBin = MsgLibMetaData.Bin

// DeployMsgLib deploys a new Ethereum contract, binding an instance of MsgLib to it.
func DeployMsgLib(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MsgLib, error) {
	parsed, err := MsgLibMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgLibBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgLib{MsgLibCaller: MsgLibCaller{contract: contract}, MsgLibTransactor: MsgLibTransactor{contract: contract}, MsgLibFilterer: MsgLibFilterer{contract: contract}}, nil
}

// MsgLib is an auto generated Go binding around an Ethereum contract.
type MsgLib struct {
	MsgLibCaller     // Read-only binding to the contract
	MsgLibTransactor // Write-only binding to the contract
	MsgLibFilterer   // Log filterer for contract events
}

// MsgLibCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgLibCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgLibTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgLibFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgLibSession struct {
	Contract     *MsgLib           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgLibCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgLibCallerSession struct {
	Contract *MsgLibCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MsgLibTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgLibTransactorSession struct {
	Contract     *MsgLibTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgLibRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgLibRaw struct {
	Contract *MsgLib // Generic contract binding to access the raw methods on
}

// MsgLibCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgLibCallerRaw struct {
	Contract *MsgLibCaller // Generic read-only contract binding to access the raw methods on
}

// MsgLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgLibTransactorRaw struct {
	Contract *MsgLibTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgLib creates a new instance of MsgLib, bound to a specific deployed contract.
func NewMsgLib(address common.Address, backend bind.ContractBackend) (*MsgLib, error) {
	contract, err := bindMsgLib(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgLib{MsgLibCaller: MsgLibCaller{contract: contract}, MsgLibTransactor: MsgLibTransactor{contract: contract}, MsgLibFilterer: MsgLibFilterer{contract: contract}}, nil
}

// NewMsgLibCaller creates a new read-only instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibCaller(address common.Address, caller bind.ContractCaller) (*MsgLibCaller, error) {
	contract, err := bindMsgLib(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgLibCaller{contract: contract}, nil
}

// NewMsgLibTransactor creates a new write-only instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgLibTransactor, error) {
	contract, err := bindMsgLib(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgLibTransactor{contract: contract}, nil
}

// NewMsgLibFilterer creates a new log filterer instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgLibFilterer, error) {
	contract, err := bindMsgLib(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgLibFilterer{contract: contract}, nil
}

// bindMsgLib binds a generic wrapper to an already deployed contract.
func bindMsgLib(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgLibMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgLib *MsgLibRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgLib.Contract.MsgLibCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgLib *MsgLibRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgLib.Contract.MsgLibTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgLib *MsgLibRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgLib.Contract.MsgLibTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgLib *MsgLibCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgLib.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgLib *MsgLibTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgLib.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgLib *MsgLibTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgLib.Contract.contract.Transact(opts, method, params...)
}

// MsgReceiverMetaData contains all meta data concerning the MsgReceiver contract.
var MsgReceiverMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_senderChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_senderContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msg\",\"type\":\"bytes\"}],\"name\":\"MsgReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"recvMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senderChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senderContractHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100f5576001600160401b0390601f61063f38819003918201601f1916830191848311848410176100e1578084926060946040528339810103126100f55780516001600160a01b039190828116908190036100f5576020820151918483168093036100f5576040015192831683036100f557600280546001600160a01b0319169190911790555f80546001600160401b0319169190911790556040805160609290921b6001600160601b0319166020830190815260148352908201929091908311818410176100e1578260405251902060015561054590816100fa8239f35b634e487b7160e01b5f52604160045260245ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c90816351a973e91461047c5750806363c6ccb21461045657806373008938146104395763faf6e9ec14610048575f80fd5b3461040e5760a036600319011261040e5760043567ffffffffffffffff8116810361040e576001600160a01b03602435166024350361040e5760443567ffffffffffffffff811161040e576100a190369060040161049f565b9160643567ffffffffffffffff811161040e576100c290369060040161049f565b60843567ffffffffffffffff811161040e576100e290369060040161049f565b9190926040519067ffffffffffffffff86166020830152600160408301526040825281606081011067ffffffffffffffff6060840111176104125760608201604052815160208301206080830152602060608301526060820160a083011067ffffffffffffffff60a084011117610412576101fd9488938860a0858160c097016040526101b1603482606081015160808201209a808b8301976bffffffffffffffffffffffff1960243560601b16895260d484013781015f60d4820152036014810185850152018383016104cd565b015190209561020f6001600160a01b03600254169367ffffffffffffffff5f5416926040519a8b9788968796630b885e5360e01b885260048801526060602488015260648701916104ef565b848103600319016044860152916104ef565b03915afa92831561042e575f93610370575b5060608301510361032b576080820151036102e65760200151600154036102a15761029c67ffffffffffffffff927f0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394946040519485941684526001600160a01b036024351660208501526060604085015260608401916104ef565b0390a1005b60405162461bcd60e51b815260206004820152601960248201527f73656e64657220636f6e7472616374206e6f74206d61746368000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601460248201527f736c6f742076616c7565206e6f74206d617463680000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f736c6f74206b6579206e6f74206d6174636800000000000000000000000000006044820152606490fd5b90925060c0813d60c011610426575b8161038c60c093836104cd565b8101031261040e576040519060c0820182811067ffffffffffffffff8211176104125760405280519067ffffffffffffffff8216820361040e5760a091835260208101516020840152604081015160408401526060810151606084015260808101516080840152015163ffffffff8116810361040e5760a0820152915f610221565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b3d915061037f565b6040513d5f823e3d90fd5b3461040e575f36600319011261040e576020600154604051908152f35b3461040e575f36600319011261040e5760206001600160a01b0360025416604051908152f35b3461040e575f36600319011261040e5760209067ffffffffffffffff5f54168152f35b9181601f8401121561040e5782359167ffffffffffffffff831161040e576020838186019501011161040e57565b90601f8019910116810190811067ffffffffffffffff82111761041257604052565b908060209392818452848401375f828201840152601f01601f191601019056fea2646970667358221220e1b8d054ca93193910908fa1583e7800c7548bca2d9c4785f65a8a9a900175ec64736f6c63430008140033",
}

// MsgReceiverABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgReceiverMetaData.ABI instead.
var MsgReceiverABI = MsgReceiverMetaData.ABI

// MsgReceiverBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgReceiverMetaData.Bin instead.
var MsgReceiverBin = MsgReceiverMetaData.Bin

// DeployMsgReceiver deploys a new Ethereum contract, binding an instance of MsgReceiver to it.
func DeployMsgReceiver(auth *bind.TransactOpts, backend bind.ContractBackend, _verifier common.Address, _senderChainId uint64, _senderContract common.Address) (common.Address, *types.Transaction, *MsgReceiver, error) {
	parsed, err := MsgReceiverMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgReceiverBin), backend, _verifier, _senderChainId, _senderContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgReceiver{MsgReceiverCaller: MsgReceiverCaller{contract: contract}, MsgReceiverTransactor: MsgReceiverTransactor{contract: contract}, MsgReceiverFilterer: MsgReceiverFilterer{contract: contract}}, nil
}

// MsgReceiver is an auto generated Go binding around an Ethereum contract.
type MsgReceiver struct {
	MsgReceiverCaller     // Read-only binding to the contract
	MsgReceiverTransactor // Write-only binding to the contract
	MsgReceiverFilterer   // Log filterer for contract events
}

// MsgReceiverCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgReceiverSession struct {
	Contract     *MsgReceiver      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgReceiverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgReceiverCallerSession struct {
	Contract *MsgReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// MsgReceiverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgReceiverTransactorSession struct {
	Contract     *MsgReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// MsgReceiverRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgReceiverRaw struct {
	Contract *MsgReceiver // Generic contract binding to access the raw methods on
}

// MsgReceiverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgReceiverCallerRaw struct {
	Contract *MsgReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// MsgReceiverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgReceiverTransactorRaw struct {
	Contract *MsgReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgReceiver creates a new instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiver(address common.Address, backend bind.ContractBackend) (*MsgReceiver, error) {
	contract, err := bindMsgReceiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgReceiver{MsgReceiverCaller: MsgReceiverCaller{contract: contract}, MsgReceiverTransactor: MsgReceiverTransactor{contract: contract}, MsgReceiverFilterer: MsgReceiverFilterer{contract: contract}}, nil
}

// NewMsgReceiverCaller creates a new read-only instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverCaller(address common.Address, caller bind.ContractCaller) (*MsgReceiverCaller, error) {
	contract, err := bindMsgReceiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverCaller{contract: contract}, nil
}

// NewMsgReceiverTransactor creates a new write-only instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgReceiverTransactor, error) {
	contract, err := bindMsgReceiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverTransactor{contract: contract}, nil
}

// NewMsgReceiverFilterer creates a new log filterer instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgReceiverFilterer, error) {
	contract, err := bindMsgReceiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverFilterer{contract: contract}, nil
}

// bindMsgReceiver binds a generic wrapper to an already deployed contract.
func bindMsgReceiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgReceiverMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgReceiver *MsgReceiverRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgReceiver.Contract.MsgReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgReceiver *MsgReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgReceiver.Contract.MsgReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgReceiver *MsgReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgReceiver.Contract.MsgReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgReceiver *MsgReceiverCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgReceiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgReceiver *MsgReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgReceiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgReceiver *MsgReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgReceiver.Contract.contract.Transact(opts, method, params...)
}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverCaller) SenderChainId(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "senderChainId")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverSession) SenderChainId() (uint64, error) {
	return _MsgReceiver.Contract.SenderChainId(&_MsgReceiver.CallOpts)
}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverCallerSession) SenderChainId() (uint64, error) {
	return _MsgReceiver.Contract.SenderChainId(&_MsgReceiver.CallOpts)
}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverCaller) SenderContractHash(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "senderContractHash")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverSession) SenderContractHash() ([32]byte, error) {
	return _MsgReceiver.Contract.SenderContractHash(&_MsgReceiver.CallOpts)
}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverCallerSession) SenderContractHash() ([32]byte, error) {
	return _MsgReceiver.Contract.SenderContractHash(&_MsgReceiver.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverSession) SlotValueVerifier() (common.Address, error) {
	return _MsgReceiver.Contract.SlotValueVerifier(&_MsgReceiver.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverCallerSession) SlotValueVerifier() (common.Address, error) {
	return _MsgReceiver.Contract.SlotValueVerifier(&_MsgReceiver.CallOpts)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverTransactor) RecvMsg(opts *bind.TransactOpts, _nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.contract.Transact(opts, "recvMsg", _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverSession) RecvMsg(_nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.Contract.RecvMsg(&_MsgReceiver.TransactOpts, _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverTransactorSession) RecvMsg(_nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.Contract.RecvMsg(&_MsgReceiver.TransactOpts, _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// MsgReceiverMsgReceivedIterator is returned from FilterMsgReceived and is used to iterate over the raw logs and unpacked data for MsgReceived events raised by the MsgReceiver contract.
type MsgReceiverMsgReceivedIterator struct {
	Event *MsgReceiverMsgReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MsgReceiverMsgReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MsgReceiverMsgReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MsgReceiverMsgReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MsgReceiverMsgReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MsgReceiverMsgReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MsgReceiverMsgReceived represents a MsgReceived event raised by the MsgReceiver contract.
type MsgReceiverMsgReceived struct {
	Nonce  uint64
	Sender common.Address
	Msg    []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMsgReceived is a free log retrieval operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) FilterMsgReceived(opts *bind.FilterOpts) (*MsgReceiverMsgReceivedIterator, error) {

	logs, sub, err := _MsgReceiver.contract.FilterLogs(opts, "MsgReceived")
	if err != nil {
		return nil, err
	}
	return &MsgReceiverMsgReceivedIterator{contract: _MsgReceiver.contract, event: "MsgReceived", logs: logs, sub: sub}, nil
}

// WatchMsgReceived is a free log subscription operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) WatchMsgReceived(opts *bind.WatchOpts, sink chan<- *MsgReceiverMsgReceived) (event.Subscription, error) {

	logs, sub, err := _MsgReceiver.contract.WatchLogs(opts, "MsgReceived")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MsgReceiverMsgReceived)
				if err := _MsgReceiver.contract.UnpackLog(event, "MsgReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMsgReceived is a log parse operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) ParseMsgReceived(log types.Log) (*MsgReceiverMsgReceived, error) {
	event := new(MsgReceiverMsgReceived)
	if err := _MsgReceiver.contract.UnpackLog(event, "MsgReceived", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MsgSenderMetaData contains all meta data concerning the MsgSender contract.
var MsgSenderMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msg\",\"type\":\"bytes\"}],\"name\":\"MsgSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"}],\"name\":\"sendMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608080604052346100165761022a908161001b8239f35b5f80fdfe6080604081815260049182361015610015575f80fd5b5f92833560e01c918263737a3ca4146100aa57508163958c3b8d1461006c575063affed0e014610043575f80fd5b3461006857816003193601126100685767ffffffffffffffff60209254169051908152f35b5080fd5b9050346100a65760203660031901126100a6573567ffffffffffffffff81168091036100a657828291602094526001845220549051908152f35b8280fd5b849084346100a65760203660031901126100a657833567ffffffffffffffff918282116101f057366023830112156101f05781860135928084116101ec57602483019260248536920101116101ec57906053939291602086013360601b8152848460348901378685810189603482015203601481018852601f199687910116870196808810838911176101d9578784525190208188541688526001602052828820558654818116918083146101c657948796939460607ff6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda999685849560809a6001601f9901169067ffffffffffffffff1916178d558852336020890152870152816060870152868601378785828601015201168101030190a180f35b634e487b7160e01b895260118a52602489fd5b634e487b7160e01b895260418a52602489fd5b8580fd5b8480fdfea264697066735822122093beededc040b8b2e2c1f9b5ffe852e2b5f0cbc708ad83231bf86c156306597964736f6c63430008140033",
}

// MsgSenderABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgSenderMetaData.ABI instead.
var MsgSenderABI = MsgSenderMetaData.ABI

// MsgSenderBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgSenderMetaData.Bin instead.
var MsgSenderBin = MsgSenderMetaData.Bin

// DeployMsgSender deploys a new Ethereum contract, binding an instance of MsgSender to it.
func DeployMsgSender(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MsgSender, error) {
	parsed, err := MsgSenderMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgSenderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgSender{MsgSenderCaller: MsgSenderCaller{contract: contract}, MsgSenderTransactor: MsgSenderTransactor{contract: contract}, MsgSenderFilterer: MsgSenderFilterer{contract: contract}}, nil
}

// MsgSender is an auto generated Go binding around an Ethereum contract.
type MsgSender struct {
	MsgSenderCaller     // Read-only binding to the contract
	MsgSenderTransactor // Write-only binding to the contract
	MsgSenderFilterer   // Log filterer for contract events
}

// MsgSenderCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgSenderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgSenderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgSenderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgSenderSession struct {
	Contract     *MsgSender        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgSenderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgSenderCallerSession struct {
	Contract *MsgSenderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// MsgSenderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgSenderTransactorSession struct {
	Contract     *MsgSenderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// MsgSenderRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgSenderRaw struct {
	Contract *MsgSender // Generic contract binding to access the raw methods on
}

// MsgSenderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgSenderCallerRaw struct {
	Contract *MsgSenderCaller // Generic read-only contract binding to access the raw methods on
}

// MsgSenderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgSenderTransactorRaw struct {
	Contract *MsgSenderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgSender creates a new instance of MsgSender, bound to a specific deployed contract.
func NewMsgSender(address common.Address, backend bind.ContractBackend) (*MsgSender, error) {
	contract, err := bindMsgSender(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgSender{MsgSenderCaller: MsgSenderCaller{contract: contract}, MsgSenderTransactor: MsgSenderTransactor{contract: contract}, MsgSenderFilterer: MsgSenderFilterer{contract: contract}}, nil
}

// NewMsgSenderCaller creates a new read-only instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderCaller(address common.Address, caller bind.ContractCaller) (*MsgSenderCaller, error) {
	contract, err := bindMsgSender(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgSenderCaller{contract: contract}, nil
}

// NewMsgSenderTransactor creates a new write-only instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgSenderTransactor, error) {
	contract, err := bindMsgSender(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgSenderTransactor{contract: contract}, nil
}

// NewMsgSenderFilterer creates a new log filterer instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgSenderFilterer, error) {
	contract, err := bindMsgSender(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgSenderFilterer{contract: contract}, nil
}

// bindMsgSender binds a generic wrapper to an already deployed contract.
func bindMsgSender(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgSenderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgSender *MsgSenderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgSender.Contract.MsgSenderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgSender *MsgSenderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgSender.Contract.MsgSenderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgSender *MsgSenderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgSender.Contract.MsgSenderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgSender *MsgSenderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgSender.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgSender *MsgSenderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgSender.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgSender *MsgSenderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgSender.Contract.contract.Transact(opts, method, params...)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderCaller) Nonce(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MsgSender.contract.Call(opts, &out, "nonce")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderSession) Nonce() (uint64, error) {
	return _MsgSender.Contract.Nonce(&_MsgSender.CallOpts)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderCallerSession) Nonce() (uint64, error) {
	return _MsgSender.Contract.Nonce(&_MsgSender.CallOpts)
}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderCaller) Sent(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _MsgSender.contract.Call(opts, &out, "sent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderSession) Sent(arg0 uint64) ([32]byte, error) {
	return _MsgSender.Contract.Sent(&_MsgSender.CallOpts, arg0)
}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderCallerSession) Sent(arg0 uint64) ([32]byte, error) {
	return _MsgSender.Contract.Sent(&_MsgSender.CallOpts, arg0)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderTransactor) SendMsg(opts *bind.TransactOpts, _msg []byte) (*types.Transaction, error) {
	return _MsgSender.contract.Transact(opts, "sendMsg", _msg)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderSession) SendMsg(_msg []byte) (*types.Transaction, error) {
	return _MsgSender.Contract.SendMsg(&_MsgSender.TransactOpts, _msg)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderTransactorSession) SendMsg(_msg []byte) (*types.Transaction, error) {
	return _MsgSender.Contract.SendMsg(&_MsgSender.TransactOpts, _msg)
}

// MsgSenderMsgSentIterator is returned from FilterMsgSent and is used to iterate over the raw logs and unpacked data for MsgSent events raised by the MsgSender contract.
type MsgSenderMsgSentIterator struct {
	Event *MsgSenderMsgSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MsgSenderMsgSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MsgSenderMsgSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MsgSenderMsgSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MsgSenderMsgSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MsgSenderMsgSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MsgSenderMsgSent represents a MsgSent event raised by the MsgSender contract.
type MsgSenderMsgSent struct {
	Nonce  uint64
	Sender common.Address
	Msg    []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMsgSent is a free log retrieval operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) FilterMsgSent(opts *bind.FilterOpts) (*MsgSenderMsgSentIterator, error) {

	logs, sub, err := _MsgSender.contract.FilterLogs(opts, "MsgSent")
	if err != nil {
		return nil, err
	}
	return &MsgSenderMsgSentIterator{contract: _MsgSender.contract, event: "MsgSent", logs: logs, sub: sub}, nil
}

// WatchMsgSent is a free log subscription operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) WatchMsgSent(opts *bind.WatchOpts, sink chan<- *MsgSenderMsgSent) (event.Subscription, error) {

	logs, sub, err := _MsgSender.contract.WatchLogs(opts, "MsgSent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MsgSenderMsgSent)
				if err := _MsgSender.contract.UnpackLog(event, "MsgSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMsgSent is a log parse operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) ParseMsgSent(log types.Log) (*MsgSenderMsgSent, error) {
	event := new(MsgSenderMsgSent)
	if err := _MsgSender.contract.UnpackLog(event, "MsgSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MyBrevisAppMetaData contains all meta data concerning the MyBrevisApp contract.
var MyBrevisAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisRequest\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"applyBrevisOpResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"applyBrevisOpResults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opChallengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisRequest\",\"type\":\"address\"}],\"name\":\"setBrevisRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_challangeWindow\",\"type\":\"uint256\"}],\"name\":\"setOpChallengeWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a957601f61096738819003918201601f19168301916001600160401b038311848410176100ad578084926020946040528339810103126100a957516001600160a01b0390818116908190036100a9575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a360015416176001555f196002556108a590816100c28239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe604060808152600480361015610013575f80fd5b5f91823560e01c8063348016571461042057806338931a31146103f85780633bca02fc146103655780634c18293a14610336578063715018a6146102c9578063718f6ccd1461027157806379d6b6a2146102275780638da5cb5b14610201578063d5caf16f146101e2578063df40bda8146101895763f2fde38b14610096575f80fd5b34610185576020366003190112610185578135916001600160a01b0390818416809403610181578454918216926100ce338514610824565b841561011857505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8480fd5b8280fd5b5050346101de5760203660031901126101de57356001600160a01b03808216809203610185576101bd908354163314610824565b73ffffffffffffffffffffffffffffffffffffffff19600154161760015580f35b5080fd5b8382346101de57816003193601126101de576020906002549051908152f35b8382346101de57816003193601126101de576001600160a01b0360209254169051908152f35b5034610185573660031901126101de576024359067ffffffffffffffff82116101855761025691369101610576565b505061026e6001600160a01b036001541633146105a4565b80f35b5050346101de5760a03660031901126101de5760243567ffffffffffffffff9182821682036102c5576084359283116102c5576102b461026e9336908301610576565b9290916064359160443591356106ae565b8380fd5b833461033357806003193601126103335780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b03821691610309338414610824565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b5050346101de5760203660031901126101de5761035e6001600160a01b038354163314610824565b3560025580f35b5034610185573660031901126101de5767ffffffffffffffff81358181116102c5576103949036908401610541565b919092602435918211610181576103ad91369101610541565b916103c46001600160a01b036001541633146105a4565b845b8181106103d1578580f35b806103e06103f3928488610612565b506103ec818686610636565b50506105f0565b6103c6565b8382346101de57816003193601126101de576020906001600160a01b03600154169051908152f35b5050346101de5760a03660031901126101de5767ffffffffffffffff9080358281116102c5576104539036908301610541565b60249291923584811161053d5761046d9036908401610541565b604493919335868111610539576104879036908401610541565b6064358881116105355761049e9036908601610541565b929094608435908a8211610531576104b891369101610541565b9490968b5b8181106104c8578c80f35b6104d381838d610612565b35906104e081858d610612565b35918d8316830361052d5761052892610523918c8c61051b868e6105148f8f908f85809361050d92610612565b3596610612565b3594610636565b9490936106ae565b6105f0565b6104bd565b8e80fd5b8b80fd5b8980fd5b8780fd5b8580fd5b9181601f840112156105725782359167ffffffffffffffff8311610572576020808501948460051b01011161057257565b5f80fd5b9181601f840112156105725782359167ffffffffffffffff8311610572576020838186019501011161057257565b156105ab57565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c69642063616c6c65720000000000000000000000000000000000006044820152606490fd5b5f1981146105fe5760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156106225760051b0190565b634e487b7160e01b5f52603260045260245ffd5b91908110156106225760051b81013590601e198136030182121561057257019081359167ffffffffffffffff8311610572576020018236038113610572579190565b90601f8019910116810190811067ffffffffffffffff82111761069a57604052565b634e487b7160e01b5f52604160045260245ffd5b9491949392936001600160a01b036001541660025460405197889363a66f791760e01b8552600485015267ffffffffffffffff8095166024850152876044850152606484015260848301528160a460209889935afa908115610819575f916107e3575b501561079e57811161069a5760405190610734601f8201601f1916860183610678565b80825284820192368282011161057257815f9287928637830101525190200361075a5750565b6064906040519062461bcd60e51b82526004820152601660248201527f696e76616c69642063697263756974206f7574707574000000000000000000006044820152fd5b60405162461bcd60e51b815260048101869052601560248201527f64617461206e6f7420726561647920746f2075736500000000000000000000006044820152606490fd5b8681813d8311610812575b6107f88183610678565b810103126101de575190811515820361033357505f610711565b503d6107ee565b6040513d5f823e3d90fd5b1561082b57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfea26469706673582212206cb2da0fd7fd438849d58eae913e065a738f6555b0c6ca98ab0bb32d915f69c464736f6c63430008140033",
}

// MyBrevisAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MyBrevisAppMetaData.ABI instead.
var MyBrevisAppABI = MyBrevisAppMetaData.ABI

// MyBrevisAppBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MyBrevisAppMetaData.Bin instead.
var MyBrevisAppBin = MyBrevisAppMetaData.Bin

// DeployMyBrevisApp deploys a new Ethereum contract, binding an instance of MyBrevisApp to it.
func DeployMyBrevisApp(auth *bind.TransactOpts, backend bind.ContractBackend, _brevisRequest common.Address) (common.Address, *types.Transaction, *MyBrevisApp, error) {
	parsed, err := MyBrevisAppMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MyBrevisAppBin), backend, _brevisRequest)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MyBrevisApp{MyBrevisAppCaller: MyBrevisAppCaller{contract: contract}, MyBrevisAppTransactor: MyBrevisAppTransactor{contract: contract}, MyBrevisAppFilterer: MyBrevisAppFilterer{contract: contract}}, nil
}

// MyBrevisApp is an auto generated Go binding around an Ethereum contract.
type MyBrevisApp struct {
	MyBrevisAppCaller     // Read-only binding to the contract
	MyBrevisAppTransactor // Write-only binding to the contract
	MyBrevisAppFilterer   // Log filterer for contract events
}

// MyBrevisAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MyBrevisAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MyBrevisAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MyBrevisAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MyBrevisAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MyBrevisAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MyBrevisAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MyBrevisAppSession struct {
	Contract     *MyBrevisApp      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MyBrevisAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MyBrevisAppCallerSession struct {
	Contract *MyBrevisAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// MyBrevisAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MyBrevisAppTransactorSession struct {
	Contract     *MyBrevisAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// MyBrevisAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MyBrevisAppRaw struct {
	Contract *MyBrevisApp // Generic contract binding to access the raw methods on
}

// MyBrevisAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MyBrevisAppCallerRaw struct {
	Contract *MyBrevisAppCaller // Generic read-only contract binding to access the raw methods on
}

// MyBrevisAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MyBrevisAppTransactorRaw struct {
	Contract *MyBrevisAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMyBrevisApp creates a new instance of MyBrevisApp, bound to a specific deployed contract.
func NewMyBrevisApp(address common.Address, backend bind.ContractBackend) (*MyBrevisApp, error) {
	contract, err := bindMyBrevisApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MyBrevisApp{MyBrevisAppCaller: MyBrevisAppCaller{contract: contract}, MyBrevisAppTransactor: MyBrevisAppTransactor{contract: contract}, MyBrevisAppFilterer: MyBrevisAppFilterer{contract: contract}}, nil
}

// NewMyBrevisAppCaller creates a new read-only instance of MyBrevisApp, bound to a specific deployed contract.
func NewMyBrevisAppCaller(address common.Address, caller bind.ContractCaller) (*MyBrevisAppCaller, error) {
	contract, err := bindMyBrevisApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MyBrevisAppCaller{contract: contract}, nil
}

// NewMyBrevisAppTransactor creates a new write-only instance of MyBrevisApp, bound to a specific deployed contract.
func NewMyBrevisAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MyBrevisAppTransactor, error) {
	contract, err := bindMyBrevisApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MyBrevisAppTransactor{contract: contract}, nil
}

// NewMyBrevisAppFilterer creates a new log filterer instance of MyBrevisApp, bound to a specific deployed contract.
func NewMyBrevisAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MyBrevisAppFilterer, error) {
	contract, err := bindMyBrevisApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MyBrevisAppFilterer{contract: contract}, nil
}

// bindMyBrevisApp binds a generic wrapper to an already deployed contract.
func bindMyBrevisApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MyBrevisAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MyBrevisApp *MyBrevisAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MyBrevisApp.Contract.MyBrevisAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MyBrevisApp *MyBrevisAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.MyBrevisAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MyBrevisApp *MyBrevisAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.MyBrevisAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MyBrevisApp *MyBrevisAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MyBrevisApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MyBrevisApp *MyBrevisAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MyBrevisApp *MyBrevisAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_MyBrevisApp *MyBrevisAppCaller) BrevisRequest(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MyBrevisApp.contract.Call(opts, &out, "brevisRequest")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_MyBrevisApp *MyBrevisAppSession) BrevisRequest() (common.Address, error) {
	return _MyBrevisApp.Contract.BrevisRequest(&_MyBrevisApp.CallOpts)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_MyBrevisApp *MyBrevisAppCallerSession) BrevisRequest() (common.Address, error) {
	return _MyBrevisApp.Contract.BrevisRequest(&_MyBrevisApp.CallOpts)
}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_MyBrevisApp *MyBrevisAppCaller) OpChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _MyBrevisApp.contract.Call(opts, &out, "opChallengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_MyBrevisApp *MyBrevisAppSession) OpChallengeWindow() (*big.Int, error) {
	return _MyBrevisApp.Contract.OpChallengeWindow(&_MyBrevisApp.CallOpts)
}

// OpChallengeWindow is a free data retrieval call binding the contract method 0xd5caf16f.
//
// Solidity: function opChallengeWindow() view returns(uint256)
func (_MyBrevisApp *MyBrevisAppCallerSession) OpChallengeWindow() (*big.Int, error) {
	return _MyBrevisApp.Contract.OpChallengeWindow(&_MyBrevisApp.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MyBrevisApp *MyBrevisAppCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MyBrevisApp.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MyBrevisApp *MyBrevisAppSession) Owner() (common.Address, error) {
	return _MyBrevisApp.Contract.Owner(&_MyBrevisApp.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MyBrevisApp *MyBrevisAppCallerSession) Owner() (common.Address, error) {
	return _MyBrevisApp.Contract.Owner(&_MyBrevisApp.CallOpts)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) ApplyBrevisOpResult(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "applyBrevisOpResult", _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.ApplyBrevisOpResult(&_MyBrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.ApplyBrevisOpResult(&_MyBrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) ApplyBrevisOpResults(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "applyBrevisOpResults", _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.ApplyBrevisOpResults(&_MyBrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.ApplyBrevisOpResults(&_MyBrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.BrevisBatchCallback(&_MyBrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.BrevisBatchCallback(&_MyBrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.BrevisCallback(&_MyBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.BrevisCallback(&_MyBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MyBrevisApp *MyBrevisAppTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MyBrevisApp *MyBrevisAppSession) RenounceOwnership() (*types.Transaction, error) {
	return _MyBrevisApp.Contract.RenounceOwnership(&_MyBrevisApp.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _MyBrevisApp.Contract.RenounceOwnership(&_MyBrevisApp.TransactOpts)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) SetBrevisRequest(opts *bind.TransactOpts, _brevisRequest common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "setBrevisRequest", _brevisRequest)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_MyBrevisApp *MyBrevisAppSession) SetBrevisRequest(_brevisRequest common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.SetBrevisRequest(&_MyBrevisApp.TransactOpts, _brevisRequest)
}

// SetBrevisRequest is a paid mutator transaction binding the contract method 0xdf40bda8.
//
// Solidity: function setBrevisRequest(address _brevisRequest) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) SetBrevisRequest(_brevisRequest common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.SetBrevisRequest(&_MyBrevisApp.TransactOpts, _brevisRequest)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) SetOpChallengeWindow(opts *bind.TransactOpts, _challangeWindow *big.Int) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "setOpChallengeWindow", _challangeWindow)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_MyBrevisApp *MyBrevisAppSession) SetOpChallengeWindow(_challangeWindow *big.Int) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.SetOpChallengeWindow(&_MyBrevisApp.TransactOpts, _challangeWindow)
}

// SetOpChallengeWindow is a paid mutator transaction binding the contract method 0x4c18293a.
//
// Solidity: function setOpChallengeWindow(uint256 _challangeWindow) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) SetOpChallengeWindow(_challangeWindow *big.Int) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.SetOpChallengeWindow(&_MyBrevisApp.TransactOpts, _challangeWindow)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MyBrevisApp *MyBrevisAppTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MyBrevisApp *MyBrevisAppSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.TransferOwnership(&_MyBrevisApp.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MyBrevisApp *MyBrevisAppTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MyBrevisApp.Contract.TransferOwnership(&_MyBrevisApp.TransactOpts, newOwner)
}

// MyBrevisAppOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MyBrevisApp contract.
type MyBrevisAppOwnershipTransferredIterator struct {
	Event *MyBrevisAppOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MyBrevisAppOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MyBrevisAppOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MyBrevisAppOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MyBrevisAppOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MyBrevisAppOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MyBrevisAppOwnershipTransferred represents a OwnershipTransferred event raised by the MyBrevisApp contract.
type MyBrevisAppOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MyBrevisApp *MyBrevisAppFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MyBrevisAppOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MyBrevisApp.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MyBrevisAppOwnershipTransferredIterator{contract: _MyBrevisApp.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MyBrevisApp *MyBrevisAppFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MyBrevisAppOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MyBrevisApp.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MyBrevisAppOwnershipTransferred)
				if err := _MyBrevisApp.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MyBrevisApp *MyBrevisAppFilterer) ParseOwnershipTransferred(log types.Log) (*MyBrevisAppOwnershipTransferred, error) {
	event := new(MyBrevisAppOwnershipTransferred)
	if err := _MyBrevisApp.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OwnableMetaData contains all meta data concerning the Ownable contract.
var OwnableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// OwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use OwnableMetaData.ABI instead.
var OwnableABI = OwnableMetaData.ABI

// Ownable is an auto generated Go binding around an Ethereum contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PairingMetaData contains all meta data concerning the Pairing contract.
var PairingMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212208b563705db10faa7b70648630d64eb19a0d13fc28ce4200147620a782aab00b164736f6c63430008140033",
}

// PairingABI is the input ABI used to generate the binding from.
// Deprecated: Use PairingMetaData.ABI instead.
var PairingABI = PairingMetaData.ABI

// PairingBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PairingMetaData.Bin instead.
var PairingBin = PairingMetaData.Bin

// DeployPairing deploys a new Ethereum contract, binding an instance of Pairing to it.
func DeployPairing(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Pairing, error) {
	parsed, err := PairingMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PairingBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Pairing{PairingCaller: PairingCaller{contract: contract}, PairingTransactor: PairingTransactor{contract: contract}, PairingFilterer: PairingFilterer{contract: contract}}, nil
}

// Pairing is an auto generated Go binding around an Ethereum contract.
type Pairing struct {
	PairingCaller     // Read-only binding to the contract
	PairingTransactor // Write-only binding to the contract
	PairingFilterer   // Log filterer for contract events
}

// PairingCaller is an auto generated read-only Go binding around an Ethereum contract.
type PairingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PairingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PairingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PairingSession struct {
	Contract     *Pairing          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PairingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PairingCallerSession struct {
	Contract *PairingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// PairingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PairingTransactorSession struct {
	Contract     *PairingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// PairingRaw is an auto generated low-level Go binding around an Ethereum contract.
type PairingRaw struct {
	Contract *Pairing // Generic contract binding to access the raw methods on
}

// PairingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PairingCallerRaw struct {
	Contract *PairingCaller // Generic read-only contract binding to access the raw methods on
}

// PairingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PairingTransactorRaw struct {
	Contract *PairingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPairing creates a new instance of Pairing, bound to a specific deployed contract.
func NewPairing(address common.Address, backend bind.ContractBackend) (*Pairing, error) {
	contract, err := bindPairing(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pairing{PairingCaller: PairingCaller{contract: contract}, PairingTransactor: PairingTransactor{contract: contract}, PairingFilterer: PairingFilterer{contract: contract}}, nil
}

// NewPairingCaller creates a new read-only instance of Pairing, bound to a specific deployed contract.
func NewPairingCaller(address common.Address, caller bind.ContractCaller) (*PairingCaller, error) {
	contract, err := bindPairing(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PairingCaller{contract: contract}, nil
}

// NewPairingTransactor creates a new write-only instance of Pairing, bound to a specific deployed contract.
func NewPairingTransactor(address common.Address, transactor bind.ContractTransactor) (*PairingTransactor, error) {
	contract, err := bindPairing(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PairingTransactor{contract: contract}, nil
}

// NewPairingFilterer creates a new log filterer instance of Pairing, bound to a specific deployed contract.
func NewPairingFilterer(address common.Address, filterer bind.ContractFilterer) (*PairingFilterer, error) {
	contract, err := bindPairing(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PairingFilterer{contract: contract}, nil
}

// bindPairing binds a generic wrapper to an already deployed contract.
func bindPairing(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PairingMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pairing *PairingRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pairing.Contract.PairingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pairing *PairingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pairing.Contract.PairingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pairing *PairingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pairing.Contract.PairingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pairing *PairingCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pairing.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pairing *PairingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pairing.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pairing *PairingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pairing.Contract.contract.Transact(opts, method, params...)
}

// PausableMetaData contains all meta data concerning the Pausable contract.
var PausableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// PausableABI is the input ABI used to generate the binding from.
// Deprecated: Use PausableMetaData.ABI instead.
var PausableABI = PausableMetaData.ABI

// Pausable is an auto generated Go binding around an Ethereum contract.
type Pausable struct {
	PausableCaller     // Read-only binding to the contract
	PausableTransactor // Write-only binding to the contract
	PausableFilterer   // Log filterer for contract events
}

// PausableCaller is an auto generated read-only Go binding around an Ethereum contract.
type PausableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PausableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PausableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PausableSession struct {
	Contract     *Pausable         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PausableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PausableCallerSession struct {
	Contract *PausableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PausableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PausableTransactorSession struct {
	Contract     *PausableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PausableRaw is an auto generated low-level Go binding around an Ethereum contract.
type PausableRaw struct {
	Contract *Pausable // Generic contract binding to access the raw methods on
}

// PausableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PausableCallerRaw struct {
	Contract *PausableCaller // Generic read-only contract binding to access the raw methods on
}

// PausableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PausableTransactorRaw struct {
	Contract *PausableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPausable creates a new instance of Pausable, bound to a specific deployed contract.
func NewPausable(address common.Address, backend bind.ContractBackend) (*Pausable, error) {
	contract, err := bindPausable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pausable{PausableCaller: PausableCaller{contract: contract}, PausableTransactor: PausableTransactor{contract: contract}, PausableFilterer: PausableFilterer{contract: contract}}, nil
}

// NewPausableCaller creates a new read-only instance of Pausable, bound to a specific deployed contract.
func NewPausableCaller(address common.Address, caller bind.ContractCaller) (*PausableCaller, error) {
	contract, err := bindPausable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PausableCaller{contract: contract}, nil
}

// NewPausableTransactor creates a new write-only instance of Pausable, bound to a specific deployed contract.
func NewPausableTransactor(address common.Address, transactor bind.ContractTransactor) (*PausableTransactor, error) {
	contract, err := bindPausable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PausableTransactor{contract: contract}, nil
}

// NewPausableFilterer creates a new log filterer instance of Pausable, bound to a specific deployed contract.
func NewPausableFilterer(address common.Address, filterer bind.ContractFilterer) (*PausableFilterer, error) {
	contract, err := bindPausable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PausableFilterer{contract: contract}, nil
}

// bindPausable binds a generic wrapper to an already deployed contract.
func bindPausable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PausableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.PausableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transact(opts, method, params...)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Pausable.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCallerSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// PausablePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Pausable contract.
type PausablePausedIterator struct {
	Event *PausablePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausablePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausablePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausablePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausablePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausablePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausablePaused represents a Paused event raised by the Pausable contract.
type PausablePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) FilterPaused(opts *bind.FilterOpts) (*PausablePausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PausablePausedIterator{contract: _Pausable.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PausablePaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausablePaused)
				if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) ParsePaused(log types.Log) (*PausablePaused, error) {
	event := new(PausablePaused)
	if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PausableUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Pausable contract.
type PausableUnpausedIterator struct {
	Event *PausableUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausableUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausableUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausableUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausableUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausableUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausableUnpaused represents a Unpaused event raised by the Pausable contract.
type PausableUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PausableUnpausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PausableUnpausedIterator{contract: _Pausable.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PausableUnpaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausableUnpaused)
				if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) ParseUnpaused(log types.Log) (*PausableUnpaused, error) {
	event := new(PausableUnpaused)
	if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserMetaData contains all meta data concerning the Pauser contract.
var PauserMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// PauserABI is the input ABI used to generate the binding from.
// Deprecated: Use PauserMetaData.ABI instead.
var PauserABI = PauserMetaData.ABI

// Pauser is an auto generated Go binding around an Ethereum contract.
type Pauser struct {
	PauserCaller     // Read-only binding to the contract
	PauserTransactor // Write-only binding to the contract
	PauserFilterer   // Log filterer for contract events
}

// PauserCaller is an auto generated read-only Go binding around an Ethereum contract.
type PauserCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PauserTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PauserFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PauserSession struct {
	Contract     *Pauser           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PauserCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PauserCallerSession struct {
	Contract *PauserCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// PauserTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PauserTransactorSession struct {
	Contract     *PauserTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PauserRaw is an auto generated low-level Go binding around an Ethereum contract.
type PauserRaw struct {
	Contract *Pauser // Generic contract binding to access the raw methods on
}

// PauserCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PauserCallerRaw struct {
	Contract *PauserCaller // Generic read-only contract binding to access the raw methods on
}

// PauserTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PauserTransactorRaw struct {
	Contract *PauserTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPauser creates a new instance of Pauser, bound to a specific deployed contract.
func NewPauser(address common.Address, backend bind.ContractBackend) (*Pauser, error) {
	contract, err := bindPauser(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pauser{PauserCaller: PauserCaller{contract: contract}, PauserTransactor: PauserTransactor{contract: contract}, PauserFilterer: PauserFilterer{contract: contract}}, nil
}

// NewPauserCaller creates a new read-only instance of Pauser, bound to a specific deployed contract.
func NewPauserCaller(address common.Address, caller bind.ContractCaller) (*PauserCaller, error) {
	contract, err := bindPauser(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PauserCaller{contract: contract}, nil
}

// NewPauserTransactor creates a new write-only instance of Pauser, bound to a specific deployed contract.
func NewPauserTransactor(address common.Address, transactor bind.ContractTransactor) (*PauserTransactor, error) {
	contract, err := bindPauser(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PauserTransactor{contract: contract}, nil
}

// NewPauserFilterer creates a new log filterer instance of Pauser, bound to a specific deployed contract.
func NewPauserFilterer(address common.Address, filterer bind.ContractFilterer) (*PauserFilterer, error) {
	contract, err := bindPauser(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PauserFilterer{contract: contract}, nil
}

// bindPauser binds a generic wrapper to an already deployed contract.
func bindPauser(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PauserMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pauser *PauserRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pauser.Contract.PauserCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pauser *PauserRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.Contract.PauserTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pauser *PauserRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pauser.Contract.PauserTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pauser *PauserCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pauser.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pauser *PauserTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pauser *PauserTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pauser.Contract.contract.Transact(opts, method, params...)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserSession) IsPauser(account common.Address) (bool, error) {
	return _Pauser.Contract.IsPauser(&_Pauser.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserCallerSession) IsPauser(account common.Address) (bool, error) {
	return _Pauser.Contract.IsPauser(&_Pauser.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserSession) NumPausers() (*big.Int, error) {
	return _Pauser.Contract.NumPausers(&_Pauser.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserCallerSession) NumPausers() (*big.Int, error) {
	return _Pauser.Contract.NumPausers(&_Pauser.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserSession) Owner() (common.Address, error) {
	return _Pauser.Contract.Owner(&_Pauser.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserCallerSession) Owner() (common.Address, error) {
	return _Pauser.Contract.Owner(&_Pauser.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserSession) Paused() (bool, error) {
	return _Pauser.Contract.Paused(&_Pauser.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserCallerSession) Paused() (bool, error) {
	return _Pauser.Contract.Paused(&_Pauser.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _Pauser.Contract.PauserList(&_Pauser.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _Pauser.Contract.PauserList(&_Pauser.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserSession) Pausers(arg0 common.Address) (bool, error) {
	return _Pauser.Contract.Pausers(&_Pauser.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _Pauser.Contract.Pausers(&_Pauser.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPauser(&_Pauser.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPauser(&_Pauser.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPausers(&_Pauser.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPausers(&_Pauser.TransactOpts, accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserSession) Pause() (*types.Transaction, error) {
	return _Pauser.Contract.Pause(&_Pauser.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserTransactorSession) Pause() (*types.Transaction, error) {
	return _Pauser.Contract.Pause(&_Pauser.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePauser(&_Pauser.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePauser(&_Pauser.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePausers(&_Pauser.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePausers(&_Pauser.TransactOpts, accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserSession) RenouncePauser() (*types.Transaction, error) {
	return _Pauser.Contract.RenouncePauser(&_Pauser.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _Pauser.Contract.RenouncePauser(&_Pauser.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.TransferOwnership(&_Pauser.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.TransferOwnership(&_Pauser.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserSession) Unpause() (*types.Transaction, error) {
	return _Pauser.Contract.Unpause(&_Pauser.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserTransactorSession) Unpause() (*types.Transaction, error) {
	return _Pauser.Contract.Unpause(&_Pauser.TransactOpts)
}

// PauserOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Pauser contract.
type PauserOwnershipTransferredIterator struct {
	Event *PauserOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserOwnershipTransferred represents a OwnershipTransferred event raised by the Pauser contract.
type PauserOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PauserOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PauserOwnershipTransferredIterator{contract: _Pauser.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PauserOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserOwnershipTransferred)
				if err := _Pauser.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) ParseOwnershipTransferred(log types.Log) (*PauserOwnershipTransferred, error) {
	event := new(PauserOwnershipTransferred)
	if err := _Pauser.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Pauser contract.
type PauserPausedIterator struct {
	Event *PauserPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPaused represents a Paused event raised by the Pauser contract.
type PauserPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) FilterPaused(opts *bind.FilterOpts) (*PauserPausedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PauserPausedIterator{contract: _Pauser.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PauserPaused) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPaused)
				if err := _Pauser.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) ParsePaused(log types.Log) (*PauserPaused, error) {
	event := new(PauserPaused)
	if err := _Pauser.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the Pauser contract.
type PauserPauserAddedIterator struct {
	Event *PauserPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPauserAdded represents a PauserAdded event raised by the Pauser contract.
type PauserPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*PauserPauserAddedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PauserPauserAddedIterator{contract: _Pauser.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PauserPauserAdded) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPauserAdded)
				if err := _Pauser.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) ParsePauserAdded(log types.Log) (*PauserPauserAdded, error) {
	event := new(PauserPauserAdded)
	if err := _Pauser.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the Pauser contract.
type PauserPauserRemovedIterator struct {
	Event *PauserPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPauserRemoved represents a PauserRemoved event raised by the Pauser contract.
type PauserPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PauserPauserRemovedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PauserPauserRemovedIterator{contract: _Pauser.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PauserPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPauserRemoved)
				if err := _Pauser.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) ParsePauserRemoved(log types.Log) (*PauserPauserRemoved, error) {
	event := new(PauserPauserRemoved)
	if err := _Pauser.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Pauser contract.
type PauserUnpausedIterator struct {
	Event *PauserUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserUnpaused represents a Unpaused event raised by the Pauser contract.
type PauserUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PauserUnpausedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PauserUnpausedIterator{contract: _Pauser.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PauserUnpaused) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserUnpaused)
				if err := _Pauser.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) ParseUnpaused(log types.Log) (*PauserUnpaused, error) {
	event := new(PauserUnpaused)
	if err := _Pauser.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMetaData contains all meta data concerning the PegBridge contract.
var PegBridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"_messageBridge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegToken\",\"type\":\"address\"}],\"name\":\"BridgeTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegToken\",\"type\":\"address\"}],\"name\":\"BridgeTokenDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_withdrawAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pegTokens\",\"type\":\"address[]\"}],\"name\":\"deletePegTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaultTokens\",\"type\":\"address[]\"}],\"name\":\"deleteVaultTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pegToVaultTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaultTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pegTokens\",\"type\":\"address[]\"}],\"name\":\"setBridgeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_vaultChain\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setTokenVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultChain\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultToPegTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a657601f61132c38819003918201601f19168301916001600160401b038311848410176100aa578084926020946040528339810103126100a657516001600160a01b0390818116908190036100a65760018060a01b031990815f5416175f55600154903390821617600155604051913391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a361126d90816100bf8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f90813560e01c90816301e6472514610f9d5750806304a2cbd014610f235780630745fcce14610e32578063274cee3114610dfa57806332eb41f614610dd257806333a42db114610dac57806340b6cc3414610cc7578063430bf08a14610c9d578063715018a614610c3e5780637f85601314610c065780638da5cb5b14610bdf57806390fc2e2514610ba4578063a00293011461075e578063a93ce09914610644578063aec95a14146102d5578063bf4816f0146101ff578063f2fde38b146101215763fdbcd5db146100e4575f80fd5b3461011e57602036600319011261011e5760209060406001600160a01b03918261010c610ffa565b16815260048452205416604051908152f35b80fd5b503461011e57602036600319011261011e5761013b610ffa565b600154906001600160a01b0380831691610156338414611132565b16918215610194576001600160a01b03191682176001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b503461011e5761020e36611057565b90916001600160a01b039361022885600154163314611132565b61023383831461117d565b855b828110610240578680f35b8061024f6102d09286886111eb565b358761026461025f8488886111eb565b61120f565b168952600660205260408920557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d066836102a061025f8387876111eb565b6102ab83888a6111eb565b604080516001600160a01b03909316835290356020830152819081015b0390a16111c9565b610235565b503461011e57608036600319011261011e576102ef610fc9565b906102f8610fe4565b9160449283359067ffffffffffffffff90818311610640573660238401121561064057826004013582811161063c5783019060249236848401116106385761033e611010565b506001600160a01b03958688541633036105f557600754918083169116036105b25760401c85169085160361056f578260a091031261056b57610382818301611223565b94808301359061039460648501611223565b9660a46103a360848701611223565b9501359386808a169216885260209860048a526040892054908882169485156105295750604051908b8201926bffffffffffffffffffffffff199182809260601b16855288603485015260601b1660548301528860601b16606882015286607c8201523060601b609c8201526090815261041c816110ca565b5190209788815260028a5261043860ff604083205416156110e6565b88815260028a5260408120805460ff19166001179055833b1561011e576040516340c10f1960e01b81526001600160a01b038416600482015260248101869052818160448183895af1801561051e5761050f575b509083825260038a5260408220908154928684018094116104fe578b7f317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac960c08d8d8d8d8d8d8d8d8d55604051968752898701526040860152606085015260808401521660a0820152a160405160018152f35b634e487b7160e01b81526011600452fd5b610518906110a2565b5f61048c565b6040513d84823e3d90fd5b8b7f6e6f2070656720746f6b656e0000000000000000000000000000000000000000606492600c876040519462461bcd60e51b86526004860152840152820152fd5b8380fd5b60405162461bcd60e51b8152602060048201526019818401527f73656e646572206973206e6f7420746f6b656e207661756c740000000000000081880152606490fd5b60405162461bcd60e51b8152602060048201526014818601527f6e6f742066726f6d207661756c7420636861696e000000000000000000000000818a0152606490fd5b60405162461bcd60e51b815260206004820152601c818701527f63616c6c6572206973206e6f74206d6573736167652062726964676500000000818b0152606490fd5b8680fd5b8580fd5b8480fd5b503461011e5761065336611057565b91926001600160a01b039361066d85600154163314611132565b61067884821461117d565b855b818110610685578680f35b8061069761025f6107599388886111eb565b876106a661025f8487896111eb565b1689526020906004825260408a20896001600160a01b031992168282541617905560056106d761025f85888a6111eb565b928a6106e761025f878d8d6111eb565b168c52528860408b209216908254161790557feabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb91161072861025f8386886111eb565b61073661025f848a8a6111eb565b604080516001600160a01b039384168152929091166020830152819081016102c8565b61067a565b503461011e5760a036600319011261011e57610778610ffa565b9067ffffffffffffffff604435166044350361011e57610796611010565b67ffffffffffffffff6084351660843503610ba0576001600160a01b0383168252600660205260408220546024351115610b5b576001600160a01b038316825260056020526001600160a01b03604083205416928315610b16576001600160a01b0381168352600360205260408320805480602435810311610b0257602435900390556001600160a01b0360405160208101903360601b82526bffffffffffffffffffffffff19808560601b16603483015260243560488301527fffffffffffffffff000000000000000000000000000000000000000000000000908160443560c01b1660688401528660601b1660708301528060843560c01b1660848301524660c01b16608c8201523060601b6094820152608881526108b6816110ca565b5190209283855260026020526108d360ff604087205416156110e6565b838552600260205260408520600160ff198254161790556040519560208701526024356040870152168060608601523360808601528260a086015260a0855261091b856110ca565b6001600160a01b0360075460401c166001600160a01b0385541660405191635c85c1a960e11b835267ffffffffffffffff6044351660048401526024830152606060448301528651806064840152865b818110610aec57508280928189608482868383602099601f9c0101528919998a91011681010301925af1918215610ae1578692610a83575b50507f1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab2859160e091604051918683523360208401526001600160a01b03861660408401526024356060840152608083015267ffffffffffffffff6084351660a083015260c0820152a16001600160a01b0381163b15610a7f5760405163079cc67960e41b815233600482015260248035908201529083908290604490829084906001600160a01b03165af18015610a745760209350610a65575b50604051908152f35b610a6e906110a2565b82610a5c565b6040513d85823e3d90fd5b8280fd5b9091506020903d602011610ad9575b601f820116820182811067ffffffffffffffff821117610ac55760209183916040528101031261064057518160e06109a3565b634e487b7160e01b87526041600452602487fd5b3d9150610a92565b6040513d88823e3d90fd5b80602080928b010151608482870101520161096b565b634e487b7160e01b85526011600452602485fd5b60405162461bcd60e51b815260206004820152600e60248201527f6e6f207661756c7420746f6b656e0000000000000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c000000000000000000000000000000006044820152606490fd5b5080fd5b503461011e57602036600319011261011e5760209060406001600160a01b039182610bcd610ffa565b16815260058452205416604051908152f35b503461011e578060031936011261011e5760206001600160a01b0360015416604051908152f35b503461011e57602036600319011261011e5760406020916001600160a01b03610c2d610ffa565b168152600683522054604051908152f35b503461011e578060031936011261011e57806001546001600160a01b03196001600160a01b03821691610c72338414611132565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461011e578060031936011261011e5760206001600160a01b0360075460401c16604051908152f35b503461011e57602080600319360112610ba05760043567ffffffffffffffff8111610a7f57610cfa903690600401611026565b6001600160a01b0392919290610d1582600154163314611132565b845b818110610d22578580f35b807f2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1610d5561025f610da794868a6111eb565b8086168952600487526040808a2080546001600160a01b03198082169092558816808c5260058a52828c20805490921690915581516001600160a01b03938416815292166020830152819081016102c8565b610d17565b503461011e578060031936011261011e576001600160a01b036020915416604051908152f35b503461011e578060031936011261011e57602067ffffffffffffffff60075416604051908152f35b503461011e57602036600319011261011e5760406020916001600160a01b03610e21610ffa565b168152600383522054604051908152f35b503461011e57602080600319360112610ba05760043567ffffffffffffffff8111610a7f57610e65903690600401611026565b6001600160a01b0392919290610e8082600154163314611132565b845b818110610e8d578580f35b807f2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1610ec061025f610f1e94868a6111eb565b808616808a5260058089526040808c20548916808d5260048b52818d2080546001600160a01b0319908116909155938d52918a52808c20805490931690925581516001600160a01b03918216815292166020830152819081016102c8565b610e82565b503461011e57604036600319011261011e57610f3d610fc9565b610f45610fe4565b610f5b6001600160a01b03600154163314611132565b67ffffffffffffffff7bffffffffffffffffffffffffffffffffffffffff00000000000000006007549260401b1692169063ffffffff60e01b16171760075580f35b905034610ba0576020366003190112610ba05760ff604060209360043581526002855220541615158152f35b6004359067ffffffffffffffff82168203610fe057565b5f80fd5b602435906001600160a01b0382168203610fe057565b600435906001600160a01b0382168203610fe057565b606435906001600160a01b0382168203610fe057565b9181601f84011215610fe05782359167ffffffffffffffff8311610fe0576020808501948460051b010111610fe057565b6040600319820112610fe05767ffffffffffffffff91600435838111610fe0578261108491600401611026565b93909392602435918211610fe05761109e91600401611026565b9091565b67ffffffffffffffff81116110b657604052565b634e487b7160e01b5f52604160045260245ffd5b60c0810190811067ffffffffffffffff8211176110b657604052565b156110ed57565b60405162461bcd60e51b815260206004820152600d60248201527f7265636f726420657869737473000000000000000000000000000000000000006044820152606490fd5b1561113957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b1561118457565b60405162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b5f1981146111d75760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156111fb5760051b0190565b634e487b7160e01b5f52603260045260245ffd5b356001600160a01b0381168103610fe05790565b35906001600160a01b0382168203610fe05756fea2646970667358221220fb7bb39c3c5d9457bb55f0acddfa7f7badf0c4ed0aee336663eda88a0941d99d64736f6c63430008140033",
}

// PegBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use PegBridgeMetaData.ABI instead.
var PegBridgeABI = PegBridgeMetaData.ABI

// PegBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PegBridgeMetaData.Bin instead.
var PegBridgeBin = PegBridgeMetaData.Bin

// DeployPegBridge deploys a new Ethereum contract, binding an instance of PegBridge to it.
func DeployPegBridge(auth *bind.TransactOpts, backend bind.ContractBackend, _messageBridge common.Address) (common.Address, *types.Transaction, *PegBridge, error) {
	parsed, err := PegBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PegBridgeBin), backend, _messageBridge)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PegBridge{PegBridgeCaller: PegBridgeCaller{contract: contract}, PegBridgeTransactor: PegBridgeTransactor{contract: contract}, PegBridgeFilterer: PegBridgeFilterer{contract: contract}}, nil
}

// PegBridge is an auto generated Go binding around an Ethereum contract.
type PegBridge struct {
	PegBridgeCaller     // Read-only binding to the contract
	PegBridgeTransactor // Write-only binding to the contract
	PegBridgeFilterer   // Log filterer for contract events
}

// PegBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type PegBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PegBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PegBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PegBridgeSession struct {
	Contract     *PegBridge        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PegBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PegBridgeCallerSession struct {
	Contract *PegBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// PegBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PegBridgeTransactorSession struct {
	Contract     *PegBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// PegBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type PegBridgeRaw struct {
	Contract *PegBridge // Generic contract binding to access the raw methods on
}

// PegBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PegBridgeCallerRaw struct {
	Contract *PegBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// PegBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PegBridgeTransactorRaw struct {
	Contract *PegBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPegBridge creates a new instance of PegBridge, bound to a specific deployed contract.
func NewPegBridge(address common.Address, backend bind.ContractBackend) (*PegBridge, error) {
	contract, err := bindPegBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PegBridge{PegBridgeCaller: PegBridgeCaller{contract: contract}, PegBridgeTransactor: PegBridgeTransactor{contract: contract}, PegBridgeFilterer: PegBridgeFilterer{contract: contract}}, nil
}

// NewPegBridgeCaller creates a new read-only instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeCaller(address common.Address, caller bind.ContractCaller) (*PegBridgeCaller, error) {
	contract, err := bindPegBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PegBridgeCaller{contract: contract}, nil
}

// NewPegBridgeTransactor creates a new write-only instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*PegBridgeTransactor, error) {
	contract, err := bindPegBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PegBridgeTransactor{contract: contract}, nil
}

// NewPegBridgeFilterer creates a new log filterer instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*PegBridgeFilterer, error) {
	contract, err := bindPegBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PegBridgeFilterer{contract: contract}, nil
}

// bindPegBridge binds a generic wrapper to an already deployed contract.
func bindPegBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PegBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PegBridge *PegBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PegBridge.Contract.PegBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PegBridge *PegBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.Contract.PegBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PegBridge *PegBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PegBridge.Contract.PegBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PegBridge *PegBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PegBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PegBridge *PegBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PegBridge *PegBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PegBridge.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeSession) MessageBridge() (common.Address, error) {
	return _PegBridge.Contract.MessageBridge(&_PegBridge.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeCallerSession) MessageBridge() (common.Address, error) {
	return _PegBridge.Contract.MessageBridge(&_PegBridge.CallOpts)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeCaller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.MinBurn(&_PegBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeCallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.MinBurn(&_PegBridge.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeSession) Owner() (common.Address, error) {
	return _PegBridge.Contract.Owner(&_PegBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeCallerSession) Owner() (common.Address, error) {
	return _PegBridge.Contract.Owner(&_PegBridge.CallOpts)
}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCaller) PegToVaultTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "pegToVaultTokens", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeSession) PegToVaultTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.PegToVaultTokens(&_PegBridge.CallOpts, arg0)
}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCallerSession) PegToVaultTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.PegToVaultTokens(&_PegBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeSession) Records(arg0 [32]byte) (bool, error) {
	return _PegBridge.Contract.Records(&_PegBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PegBridge.Contract.Records(&_PegBridge.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeCaller) Supplies(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "supplies", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.Supplies(&_PegBridge.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeCallerSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.Supplies(&_PegBridge.CallOpts, arg0)
}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeCaller) VaultAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeSession) VaultAddress() (common.Address, error) {
	return _PegBridge.Contract.VaultAddress(&_PegBridge.CallOpts)
}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeCallerSession) VaultAddress() (common.Address, error) {
	return _PegBridge.Contract.VaultAddress(&_PegBridge.CallOpts)
}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeCaller) VaultChain(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultChain")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeSession) VaultChain() (uint64, error) {
	return _PegBridge.Contract.VaultChain(&_PegBridge.CallOpts)
}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeCallerSession) VaultChain() (uint64, error) {
	return _PegBridge.Contract.VaultChain(&_PegBridge.CallOpts)
}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCaller) VaultToPegTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultToPegTokens", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeSession) VaultToPegTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.VaultToPegTokens(&_PegBridge.CallOpts, arg0)
}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCallerSession) VaultToPegTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.VaultToPegTokens(&_PegBridge.CallOpts, arg0)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeTransactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "burn", _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.Contract.Burn(&_PegBridge.TransactOpts, _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeTransactorSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.Contract.Burn(&_PegBridge.TransactOpts, _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactor) DeletePegTokens(opts *bind.TransactOpts, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "deletePegTokens", _pegTokens)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeSession) DeletePegTokens(_pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeletePegTokens(&_PegBridge.TransactOpts, _pegTokens)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) DeletePegTokens(_pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeletePegTokens(&_PegBridge.TransactOpts, _pegTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeTransactor) DeleteVaultTokens(opts *bind.TransactOpts, _vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "deleteVaultTokens", _vaultTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeSession) DeleteVaultTokens(_vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeleteVaultTokens(&_PegBridge.TransactOpts, _vaultTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) DeleteVaultTokens(_vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeleteVaultTokens(&_PegBridge.TransactOpts, _vaultTokens)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.ExecuteMessage(&_PegBridge.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.ExecuteMessage(&_PegBridge.TransactOpts, srcChainId, sender, message, executor)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _PegBridge.Contract.RenounceOwnership(&_PegBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _PegBridge.Contract.RenounceOwnership(&_PegBridge.TransactOpts)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactor) SetBridgeTokens(opts *bind.TransactOpts, _vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setBridgeTokens", _vaultTokens, _pegTokens)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeSession) SetBridgeTokens(_vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetBridgeTokens(&_PegBridge.TransactOpts, _vaultTokens, _pegTokens)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) SetBridgeTokens(_vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetBridgeTokens(&_PegBridge.TransactOpts, _vaultTokens, _pegTokens)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeTransactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.Contract.SetMinBurn(&_PegBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeTransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.Contract.SetMinBurn(&_PegBridge.TransactOpts, _tokens, _amounts)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeTransactor) SetTokenVault(opts *bind.TransactOpts, _vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setTokenVault", _vaultChain, _vaultAddress)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeSession) SetTokenVault(_vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetTokenVault(&_PegBridge.TransactOpts, _vaultChain, _vaultAddress)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeTransactorSession) SetTokenVault(_vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetTokenVault(&_PegBridge.TransactOpts, _vaultChain, _vaultAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.TransferOwnership(&_PegBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.TransferOwnership(&_PegBridge.TransactOpts, newOwner)
}

// PegBridgeBridgeTokenAddedIterator is returned from FilterBridgeTokenAdded and is used to iterate over the raw logs and unpacked data for BridgeTokenAdded events raised by the PegBridge contract.
type PegBridgeBridgeTokenAddedIterator struct {
	Event *PegBridgeBridgeTokenAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBridgeTokenAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBridgeTokenAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBridgeTokenAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBridgeTokenAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBridgeTokenAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBridgeTokenAdded represents a BridgeTokenAdded event raised by the PegBridge contract.
type PegBridgeBridgeTokenAdded struct {
	VaultToken common.Address
	PegToken   common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterBridgeTokenAdded is a free log retrieval operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) FilterBridgeTokenAdded(opts *bind.FilterOpts) (*PegBridgeBridgeTokenAddedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "BridgeTokenAdded")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBridgeTokenAddedIterator{contract: _PegBridge.contract, event: "BridgeTokenAdded", logs: logs, sub: sub}, nil
}

// WatchBridgeTokenAdded is a free log subscription operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) WatchBridgeTokenAdded(opts *bind.WatchOpts, sink chan<- *PegBridgeBridgeTokenAdded) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "BridgeTokenAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBridgeTokenAdded)
				if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeTokenAdded is a log parse operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) ParseBridgeTokenAdded(log types.Log) (*PegBridgeBridgeTokenAdded, error) {
	event := new(PegBridgeBridgeTokenAdded)
	if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeBridgeTokenDeletedIterator is returned from FilterBridgeTokenDeleted and is used to iterate over the raw logs and unpacked data for BridgeTokenDeleted events raised by the PegBridge contract.
type PegBridgeBridgeTokenDeletedIterator struct {
	Event *PegBridgeBridgeTokenDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBridgeTokenDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBridgeTokenDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBridgeTokenDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBridgeTokenDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBridgeTokenDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBridgeTokenDeleted represents a BridgeTokenDeleted event raised by the PegBridge contract.
type PegBridgeBridgeTokenDeleted struct {
	VaultToken common.Address
	PegToken   common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterBridgeTokenDeleted is a free log retrieval operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) FilterBridgeTokenDeleted(opts *bind.FilterOpts) (*PegBridgeBridgeTokenDeletedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "BridgeTokenDeleted")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBridgeTokenDeletedIterator{contract: _PegBridge.contract, event: "BridgeTokenDeleted", logs: logs, sub: sub}, nil
}

// WatchBridgeTokenDeleted is a free log subscription operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) WatchBridgeTokenDeleted(opts *bind.WatchOpts, sink chan<- *PegBridgeBridgeTokenDeleted) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "BridgeTokenDeleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBridgeTokenDeleted)
				if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeTokenDeleted is a log parse operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) ParseBridgeTokenDeleted(log types.Log) (*PegBridgeBridgeTokenDeleted, error) {
	event := new(PegBridgeBridgeTokenDeleted)
	if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PegBridge contract.
type PegBridgeBurnIterator struct {
	Event *PegBridgeBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBurn represents a Burn event raised by the PegBridge contract.
type PegBridgeBurn struct {
	BurnId          [32]byte
	BurnAccount     common.Address
	Token           common.Address
	Amount          *big.Int
	WithdrawAccount common.Address
	Nonce           uint64
	MessageId       [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) FilterBurn(opts *bind.FilterOpts) (*PegBridgeBurnIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBurnIterator{contract: _PegBridge.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PegBridgeBurn) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBurn)
				if err := _PegBridge.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) ParseBurn(log types.Log) (*PegBridgeBurn, error) {
	event := new(PegBridgeBurn)
	if err := _PegBridge.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PegBridge contract.
type PegBridgeMinBurnUpdatedIterator struct {
	Event *PegBridgeMinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeMinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeMinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeMinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeMinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeMinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeMinBurnUpdated represents a MinBurnUpdated event raised by the PegBridge contract.
type PegBridgeMinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PegBridgeMinBurnUpdatedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PegBridgeMinBurnUpdatedIterator{contract: _PegBridge.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PegBridgeMinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeMinBurnUpdated)
				if err := _PegBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) ParseMinBurnUpdated(log types.Log) (*PegBridgeMinBurnUpdated, error) {
	event := new(PegBridgeMinBurnUpdated)
	if err := _PegBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PegBridge contract.
type PegBridgeMintIterator struct {
	Event *PegBridgeMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeMint represents a Mint event raised by the PegBridge contract.
type PegBridgeMint struct {
	MintId    [32]byte
	Account   common.Address
	Token     common.Address
	Amount    *big.Int
	RefId     [32]byte
	Depositor common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) FilterMint(opts *bind.FilterOpts) (*PegBridgeMintIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PegBridgeMintIterator{contract: _PegBridge.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PegBridgeMint) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeMint)
				if err := _PegBridge.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) ParseMint(log types.Log) (*PegBridgeMint, error) {
	event := new(PegBridgeMint)
	if err := _PegBridge.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PegBridge contract.
type PegBridgeOwnershipTransferredIterator struct {
	Event *PegBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the PegBridge contract.
type PegBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PegBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PegBridgeOwnershipTransferredIterator{contract: _PegBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PegBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeOwnershipTransferred)
				if err := _PegBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*PegBridgeOwnershipTransferred, error) {
	event := new(PegBridgeOwnershipTransferred)
	if err := _PegBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PoolMetaData contains all meta data concerning the Pool contract.
var PoolMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"NoLiquidityToReceiveFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceCurrentX96\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitAlreadyExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"TickLiquidityOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"}],\"name\":\"TickLowerOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"TickNotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TickUpperOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TicksMisordered\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212201f9d5a00c252f5b6692072835d0f264c66bdb95f24b7007b98f522277a4eec0c64736f6c63430008140033",
}

// PoolABI is the input ABI used to generate the binding from.
// Deprecated: Use PoolMetaData.ABI instead.
var PoolABI = PoolMetaData.ABI

// PoolBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PoolMetaData.Bin instead.
var PoolBin = PoolMetaData.Bin

// DeployPool deploys a new Ethereum contract, binding an instance of Pool to it.
func DeployPool(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Pool, error) {
	parsed, err := PoolMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PoolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Pool{PoolCaller: PoolCaller{contract: contract}, PoolTransactor: PoolTransactor{contract: contract}, PoolFilterer: PoolFilterer{contract: contract}}, nil
}

// Pool is an auto generated Go binding around an Ethereum contract.
type Pool struct {
	PoolCaller     // Read-only binding to the contract
	PoolTransactor // Write-only binding to the contract
	PoolFilterer   // Log filterer for contract events
}

// PoolCaller is an auto generated read-only Go binding around an Ethereum contract.
type PoolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PoolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PoolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PoolSession struct {
	Contract     *Pool             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PoolCallerSession struct {
	Contract *PoolCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// PoolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PoolTransactorSession struct {
	Contract     *PoolTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolRaw is an auto generated low-level Go binding around an Ethereum contract.
type PoolRaw struct {
	Contract *Pool // Generic contract binding to access the raw methods on
}

// PoolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PoolCallerRaw struct {
	Contract *PoolCaller // Generic read-only contract binding to access the raw methods on
}

// PoolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PoolTransactorRaw struct {
	Contract *PoolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPool creates a new instance of Pool, bound to a specific deployed contract.
func NewPool(address common.Address, backend bind.ContractBackend) (*Pool, error) {
	contract, err := bindPool(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pool{PoolCaller: PoolCaller{contract: contract}, PoolTransactor: PoolTransactor{contract: contract}, PoolFilterer: PoolFilterer{contract: contract}}, nil
}

// NewPoolCaller creates a new read-only instance of Pool, bound to a specific deployed contract.
func NewPoolCaller(address common.Address, caller bind.ContractCaller) (*PoolCaller, error) {
	contract, err := bindPool(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PoolCaller{contract: contract}, nil
}

// NewPoolTransactor creates a new write-only instance of Pool, bound to a specific deployed contract.
func NewPoolTransactor(address common.Address, transactor bind.ContractTransactor) (*PoolTransactor, error) {
	contract, err := bindPool(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PoolTransactor{contract: contract}, nil
}

// NewPoolFilterer creates a new log filterer instance of Pool, bound to a specific deployed contract.
func NewPoolFilterer(address common.Address, filterer bind.ContractFilterer) (*PoolFilterer, error) {
	contract, err := bindPool(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PoolFilterer{contract: contract}, nil
}

// bindPool binds a generic wrapper to an already deployed contract.
func bindPool(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PoolMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pool *PoolRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pool.Contract.PoolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pool *PoolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pool.Contract.PoolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pool *PoolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pool.Contract.PoolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pool *PoolCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pool.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pool *PoolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pool.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pool *PoolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pool.Contract.contract.Transact(opts, method, params...)
}

// PoolIdLibraryMetaData contains all meta data concerning the PoolIdLibrary contract.
var PoolIdLibraryMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220598582b12c1a1d3f16ac7db7c15d1627ece96c470ea935a5d1e1f2d58c69b83264736f6c63430008140033",
}

// PoolIdLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use PoolIdLibraryMetaData.ABI instead.
var PoolIdLibraryABI = PoolIdLibraryMetaData.ABI

// PoolIdLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PoolIdLibraryMetaData.Bin instead.
var PoolIdLibraryBin = PoolIdLibraryMetaData.Bin

// DeployPoolIdLibrary deploys a new Ethereum contract, binding an instance of PoolIdLibrary to it.
func DeployPoolIdLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PoolIdLibrary, error) {
	parsed, err := PoolIdLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PoolIdLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PoolIdLibrary{PoolIdLibraryCaller: PoolIdLibraryCaller{contract: contract}, PoolIdLibraryTransactor: PoolIdLibraryTransactor{contract: contract}, PoolIdLibraryFilterer: PoolIdLibraryFilterer{contract: contract}}, nil
}

// PoolIdLibrary is an auto generated Go binding around an Ethereum contract.
type PoolIdLibrary struct {
	PoolIdLibraryCaller     // Read-only binding to the contract
	PoolIdLibraryTransactor // Write-only binding to the contract
	PoolIdLibraryFilterer   // Log filterer for contract events
}

// PoolIdLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type PoolIdLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PoolIdLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PoolIdLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PoolIdLibrarySession struct {
	Contract     *PoolIdLibrary    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolIdLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PoolIdLibraryCallerSession struct {
	Contract *PoolIdLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// PoolIdLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PoolIdLibraryTransactorSession struct {
	Contract     *PoolIdLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// PoolIdLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type PoolIdLibraryRaw struct {
	Contract *PoolIdLibrary // Generic contract binding to access the raw methods on
}

// PoolIdLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PoolIdLibraryCallerRaw struct {
	Contract *PoolIdLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// PoolIdLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PoolIdLibraryTransactorRaw struct {
	Contract *PoolIdLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPoolIdLibrary creates a new instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibrary(address common.Address, backend bind.ContractBackend) (*PoolIdLibrary, error) {
	contract, err := bindPoolIdLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibrary{PoolIdLibraryCaller: PoolIdLibraryCaller{contract: contract}, PoolIdLibraryTransactor: PoolIdLibraryTransactor{contract: contract}, PoolIdLibraryFilterer: PoolIdLibraryFilterer{contract: contract}}, nil
}

// NewPoolIdLibraryCaller creates a new read-only instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryCaller(address common.Address, caller bind.ContractCaller) (*PoolIdLibraryCaller, error) {
	contract, err := bindPoolIdLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryCaller{contract: contract}, nil
}

// NewPoolIdLibraryTransactor creates a new write-only instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*PoolIdLibraryTransactor, error) {
	contract, err := bindPoolIdLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryTransactor{contract: contract}, nil
}

// NewPoolIdLibraryFilterer creates a new log filterer instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*PoolIdLibraryFilterer, error) {
	contract, err := bindPoolIdLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryFilterer{contract: contract}, nil
}

// bindPoolIdLibrary binds a generic wrapper to an already deployed contract.
func bindPoolIdLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PoolIdLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PoolIdLibrary *PoolIdLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PoolIdLibrary.Contract.PoolIdLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PoolIdLibrary *PoolIdLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.PoolIdLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PoolIdLibrary *PoolIdLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.PoolIdLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PoolIdLibrary *PoolIdLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PoolIdLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PoolIdLibrary *PoolIdLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PoolIdLibrary *PoolIdLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.contract.Transact(opts, method, params...)
}

// PositionMetaData contains all meta data concerning the Position contract.
var PositionMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"CannotUpdateEmptyPosition\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220881c698c438a05fc5b842b4572390b3901f6d0c90e363bc1e1a6047ec62b5dec64736f6c63430008140033",
}

// PositionABI is the input ABI used to generate the binding from.
// Deprecated: Use PositionMetaData.ABI instead.
var PositionABI = PositionMetaData.ABI

// PositionBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PositionMetaData.Bin instead.
var PositionBin = PositionMetaData.Bin

// DeployPosition deploys a new Ethereum contract, binding an instance of Position to it.
func DeployPosition(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Position, error) {
	parsed, err := PositionMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PositionBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Position{PositionCaller: PositionCaller{contract: contract}, PositionTransactor: PositionTransactor{contract: contract}, PositionFilterer: PositionFilterer{contract: contract}}, nil
}

// Position is an auto generated Go binding around an Ethereum contract.
type Position struct {
	PositionCaller     // Read-only binding to the contract
	PositionTransactor // Write-only binding to the contract
	PositionFilterer   // Log filterer for contract events
}

// PositionCaller is an auto generated read-only Go binding around an Ethereum contract.
type PositionCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PositionTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PositionFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PositionSession struct {
	Contract     *Position         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PositionCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PositionCallerSession struct {
	Contract *PositionCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PositionTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PositionTransactorSession struct {
	Contract     *PositionTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PositionRaw is an auto generated low-level Go binding around an Ethereum contract.
type PositionRaw struct {
	Contract *Position // Generic contract binding to access the raw methods on
}

// PositionCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PositionCallerRaw struct {
	Contract *PositionCaller // Generic read-only contract binding to access the raw methods on
}

// PositionTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PositionTransactorRaw struct {
	Contract *PositionTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPosition creates a new instance of Position, bound to a specific deployed contract.
func NewPosition(address common.Address, backend bind.ContractBackend) (*Position, error) {
	contract, err := bindPosition(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Position{PositionCaller: PositionCaller{contract: contract}, PositionTransactor: PositionTransactor{contract: contract}, PositionFilterer: PositionFilterer{contract: contract}}, nil
}

// NewPositionCaller creates a new read-only instance of Position, bound to a specific deployed contract.
func NewPositionCaller(address common.Address, caller bind.ContractCaller) (*PositionCaller, error) {
	contract, err := bindPosition(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PositionCaller{contract: contract}, nil
}

// NewPositionTransactor creates a new write-only instance of Position, bound to a specific deployed contract.
func NewPositionTransactor(address common.Address, transactor bind.ContractTransactor) (*PositionTransactor, error) {
	contract, err := bindPosition(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PositionTransactor{contract: contract}, nil
}

// NewPositionFilterer creates a new log filterer instance of Position, bound to a specific deployed contract.
func NewPositionFilterer(address common.Address, filterer bind.ContractFilterer) (*PositionFilterer, error) {
	contract, err := bindPosition(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PositionFilterer{contract: contract}, nil
}

// bindPosition binds a generic wrapper to an already deployed contract.
func bindPosition(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PositionMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Position *PositionRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Position.Contract.PositionCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Position *PositionRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Position.Contract.PositionTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Position *PositionRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Position.Contract.PositionTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Position *PositionCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Position.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Position *PositionTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Position.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Position *PositionTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Position.Contract.contract.Transact(opts, method, params...)
}

// RLPReaderMetaData contains all meta data concerning the RLPReader contract.
var RLPReaderMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212201c303cddb168f46ddce711922a3ec5ea6de36d3f9c896b35b2bac58b0556763264736f6c63430008140033",
}

// RLPReaderABI is the input ABI used to generate the binding from.
// Deprecated: Use RLPReaderMetaData.ABI instead.
var RLPReaderABI = RLPReaderMetaData.ABI

// RLPReaderBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use RLPReaderMetaData.Bin instead.
var RLPReaderBin = RLPReaderMetaData.Bin

// DeployRLPReader deploys a new Ethereum contract, binding an instance of RLPReader to it.
func DeployRLPReader(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RLPReader, error) {
	parsed, err := RLPReaderMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(RLPReaderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RLPReader{RLPReaderCaller: RLPReaderCaller{contract: contract}, RLPReaderTransactor: RLPReaderTransactor{contract: contract}, RLPReaderFilterer: RLPReaderFilterer{contract: contract}}, nil
}

// RLPReader is an auto generated Go binding around an Ethereum contract.
type RLPReader struct {
	RLPReaderCaller     // Read-only binding to the contract
	RLPReaderTransactor // Write-only binding to the contract
	RLPReaderFilterer   // Log filterer for contract events
}

// RLPReaderCaller is an auto generated read-only Go binding around an Ethereum contract.
type RLPReaderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RLPReaderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RLPReaderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RLPReaderSession struct {
	Contract     *RLPReader        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RLPReaderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RLPReaderCallerSession struct {
	Contract *RLPReaderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// RLPReaderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RLPReaderTransactorSession struct {
	Contract     *RLPReaderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// RLPReaderRaw is an auto generated low-level Go binding around an Ethereum contract.
type RLPReaderRaw struct {
	Contract *RLPReader // Generic contract binding to access the raw methods on
}

// RLPReaderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RLPReaderCallerRaw struct {
	Contract *RLPReaderCaller // Generic read-only contract binding to access the raw methods on
}

// RLPReaderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RLPReaderTransactorRaw struct {
	Contract *RLPReaderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRLPReader creates a new instance of RLPReader, bound to a specific deployed contract.
func NewRLPReader(address common.Address, backend bind.ContractBackend) (*RLPReader, error) {
	contract, err := bindRLPReader(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RLPReader{RLPReaderCaller: RLPReaderCaller{contract: contract}, RLPReaderTransactor: RLPReaderTransactor{contract: contract}, RLPReaderFilterer: RLPReaderFilterer{contract: contract}}, nil
}

// NewRLPReaderCaller creates a new read-only instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderCaller(address common.Address, caller bind.ContractCaller) (*RLPReaderCaller, error) {
	contract, err := bindRLPReader(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RLPReaderCaller{contract: contract}, nil
}

// NewRLPReaderTransactor creates a new write-only instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderTransactor(address common.Address, transactor bind.ContractTransactor) (*RLPReaderTransactor, error) {
	contract, err := bindRLPReader(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RLPReaderTransactor{contract: contract}, nil
}

// NewRLPReaderFilterer creates a new log filterer instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderFilterer(address common.Address, filterer bind.ContractFilterer) (*RLPReaderFilterer, error) {
	contract, err := bindRLPReader(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RLPReaderFilterer{contract: contract}, nil
}

// bindRLPReader binds a generic wrapper to an already deployed contract.
func bindRLPReader(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := RLPReaderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RLPReader *RLPReaderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RLPReader.Contract.RLPReaderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RLPReader *RLPReaderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RLPReader.Contract.RLPReaderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RLPReader *RLPReaderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RLPReader.Contract.RLPReaderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RLPReader *RLPReaderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RLPReader.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RLPReader *RLPReaderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RLPReader.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RLPReader *RLPReaderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RLPReader.Contract.contract.Transact(opts, method, params...)
}

// ReceiptVerifierMetaData contains all meta data concerning the ReceiptVerifier contract.
var ReceiptVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receiptHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedReceipt\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"}],\"name\":\"decodeReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceiptAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f6119f138819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3600254161760025561193490816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f803560e01c9081631eeb86da146100a7575080633996da7a146100a257806368ac2f781461009d578063724796ed146100985780638da5cb5b14610093578063c109ae5d1461008e578063ec4ffc5214610089578063f2fde38b146100845763f5cec6af1461007f575f80fd5b610615565b61052b565b610489565b610435565b610410565b6103ea565b6103be565b610330565b34610124576020366003190112610124577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a9860206100e3610127565b6001600160a01b03906100fa828654163314610657565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a180f35b80fd5b600435906001600160a01b038216820361013d57565b5f80fd5b9181601f8401121561013d5782359167ffffffffffffffff831161013d576020838186019501011161013d57565b90606060031983011261013d5767ffffffffffffffff60043581811161013d578361019c91600401610141565b9390939260243583811161013d57826101b791600401610141565b9390939260443591821161013d576101d191600401610141565b9091565b5f5b8381106101e65750505f910152565b81810151838201526020016101d7565b602080825260e0820190835115158184015267ffffffffffffffff928382860151166040908183015260a081870151966060978885015263ffffffff8882015116966080978886015287820151168285015201519560c08084015286518095526101009184838501938760051b8601019801965f9081955b888710610282575050505050505050505090565b9091929394959697989960ff19828203018752888b51878301926001600160a01b0382511681528783830151928a8584015283518096528488840194019589905b808210610313575050600195509184939184930151908a8184039101526102f5815180928185528580860191016101d5565b601f01601f191601019c019a9998919091019601949392919061026e565b87518652968601968f9695909501948b93506001909101906102c3565b3461013d576103ba61039c7fa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366604061038461036a3661016f565b9261037c999599969496929192610728565b50868a610973565b9467ffffffffffffffff602087015116923691610785565b6020815191012082519182526020820152a1604051918291826101f6565b0390f35b3461013d576103ba6103de6103d23661016f565b94939093929192610973565b604051918291826101f6565b3461013d575f36600319011261013d5760206001600160a01b0360025416604051908152f35b3461013d575f36600319011261013d5760206001600160a01b035f5416604051908152f35b3461013d57602036600319011261013d5760043567ffffffffffffffff811161013d576103de61046c6103ba923690600401610141565b90611024565b6004359067ffffffffffffffff8216820361013d57565b3461013d57604036600319011261013d576104a2610472565b602435906001600160a01b039182811680910361013d5767ffffffffffffffff6040926104f47ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f54163314610657565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b3461013d57602036600319011261013d57610544610127565b5f908154906001600160a01b0380831691610560338414610657565b169182156105aa5773ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461013d57602036600319011261013d5767ffffffffffffffff610637610472565b165f52600160205260206001600160a01b0360405f205416604051908152f35b1561065e57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176106d257604052565b6106a2565b90601f8019910116810190811067ffffffffffffffff8211176106d257604052565b6040519060c0820182811067ffffffffffffffff8211176106d257604052565b60405190610726826106b6565b565b6040519060c0820182811067ffffffffffffffff8211176106d257604052606060a0835f81525f60208201525f60408201525f838201525f60808201520152565b67ffffffffffffffff81116106d257601f01601f191660200190565b92919261079182610769565b9161079f60405193846106d7565b82948184528183011161013d578281602093845f960137010152565b156107c257565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b6020908361072693959495604051968361082a89955180928880890191016101d5565b84019185830137015f838201520380855201836106d7565b1561084957565b60405162461bcd60e51b815260206004820152601260248201527f6c65616648617368206e6f74206d6174636800000000000000000000000000006044820152606490fd5b9081602091031261013d5751801515810361013d5790565b91909161018081019267ffffffffffffffff815116825260a08063ffffffff926020938085830151168587015260408201516040870152606082015160608701526080820151166080860152015192015f905b600782106109075750505050565b828060019286518152019401910190926108f9565b6040513d5f823e3d90fd5b1561092e57565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b9594610a9994939291610984610728565b506109b76109b261099586866113a1565b9560808701956109ad875167ffffffffffffffff1690565b611237565b6107bb565b6109e56109c9828a60a0880151610807565b928351966109e06020988980970120885114610842565b610d97565b85519294919267ffffffffffffffff1690610a556040890194610a0c865163ffffffff1690565b97858b0198610a3e8a5191610a32610a226106f9565b67ffffffffffffffff9099168952565b63ffffffff1687890152565b6040860152606085015263ffffffff166080840152565b60a0820152610a7e610a72610a726002546001600160a01b031690565b6001600160a01b031690565b60405180809b8194631513dce960e21b8352600483016108a6565b03915afa918215610b6557610af26060610b2897610b1a96610adc610b039560409f610ad76107269f9a8f9b610b0d9c5f92610b38575b5050610927565b611024565b9d8e9151910152015167ffffffffffffffff1690565b67ffffffffffffffff1660808b0152565b5163ffffffff1690565b63ffffffff166060880152565b5167ffffffffffffffff1690565b67ffffffffffffffff1690840152565b610b579250803d10610b5e575b610b4f81836106d7565b81019061088e565b8f80610ad0565b503d610b45565b61091c565b15610b7157565b60405162461bcd60e51b815260206004820152601b60248201527f696e636f72726563742061757869426c6b566572696679496e666f00000000006044820152606490fd5b9060201161013d5790602090565b9060241161013d5760200190600490565b906101041161013d5760e40190602090565b909291928360011161013d57831161013d57600101915f190190565b906101801161013d576101700190601090565b906101a01161013d576101800190602090565b906101c01161013d576101b00190601090565b906101e01161013d576101dc0190600490565b906102001161013d576101f80190600890565b906102081161013d576102000190600890565b9291926102089184831161013d57841161013d570191610207190190565b9093929384831161013d57841161013d578101920390565b359060208110610cb9575090565b5f199060200360031b1b1690565b7fffffffff000000000000000000000000000000000000000000000000000000009035818116939260048110610cfc57505050565b60040360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b60ff1660ff8114610d305760010190565b610d0b565b60051b90611fe060e0831692168203610d3057565b60ff166024019060ff8211610d3057565b60ff60019116019060ff8211610d3057565b634e487b7160e01b5f52603260045260245ffd5b906007811015610d925760051b0190565b610d6d565b916040519060e0820182811067ffffffffffffffff8211176106d25760405260e036833781610dc96101048514610b6a565b610ddc610dd68587610bb6565b90610cab565b93610df9610df3610ded8389610bc4565b90610cc7565b60e01c90565b945f5b60ff808216906006821015610e5e5790610e53610e4c610dd685948d89610e2d610e28610e599a610d35565b610d4a565b9280610e43610e28610e3e8c610d5b565b610d35565b16931691610c93565b9189610d81565b52610d1f565b610dfc565b50505095610dd660c092610e7492969496610bd5565b910152565b9015610d925790565b15610e8957565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b805115610d925760200190565b805160031015610d925760800190565b805160011015610d925760400190565b805160021015610d925760600190565b8051821015610d925760209160051b010190565b906020825192015160ff60f81b908181169360018110610f3e57505050565b60010360031b82901b16169150565b67ffffffffffffffff81116106d25760051b60200190565b90610f6f82610f4d565b604090610f7e825191826106d7565b8381528093610f8f601f1991610f4d565b01905f92835b838110610fa3575050505050565b8151906060918281019281841067ffffffffffffffff8511176106d25760209385528782528390808284015285830152828601015201610f95565b90610fe882610f4d565b610ff560405191826106d7565b8281528092611006601f1991610f4d565b0190602036910137565b602081519101519060208110610cb9575090565b6110f86110f26110a261109d61109861109161103e610728565b978060ff9861108c60028b61108561107f6110598787610e79565b357fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b1614610e82565b610be7565b3691610785565b6114c5565b611514565b600160f81b7fff000000000000000000000000000000000000000000000000000000000000006110e26110dd6110d785610ece565b516116e1565b610f1f565b1614611207575b94939294610edb565b51611514565b926111038451610f65565b915f80945b865191848716928310156111f9576111236110f2848a610f0b565b976111526111396111338b610ece565b51611609565b611143868a610f0b565b51906001600160a01b03169052565b61115e6110f28a610eeb565b926111698451610fde565b9560209687611178888c610f0b565b510152835b8551898216908110156111c157908a610e53838b6111b48c6111ae6111a96110d78f9a6111bc9b610f0b565b611010565b95610f0b565b510151610f0b565b61117d565b505098929550986111f093506111e86111e16110d7604093979497610efb565b9289610f0b565b510152610d1f565b94919095611108565b5094505093505060a0830152565b600185526110e9565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b909167ffffffffffffffff82165f5260016020526001600160a01b0360405f205416156112e3576112b392611296610a72610a7261128960209667ffffffffffffffff165f52600160205260405f2090565b546001600160a01b031690565b906040518095819482936322bb937360e11b845260048401611210565b03915afa908115610b65575f916112c8575090565b6112e0915060203d8111610b5e57610b4f81836106d7565b90565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b6fffffffffffffffffffffffffffffffff19903581811693926010811061134e57505050565b60100360031b82901b16169150565b7fffffffffffffffff000000000000000000000000000000000000000000000000903581811693926008811061139257505050565b60080360031b82901b16169150565b91906113ab610728565b92816101601161013d578180826113f26113dd6113d76113d16114a69861109198610c03565b90611328565b60801c90565b6fffffffffffffffffffffffffffffffff1690565b61014082013560801b17875261141461140e610dd68484610c16565b60801b90565b6114276113dd6113d76113d18686610c29565b17602088015261144d611440610df3610ded8585610c3c565b63ffffffff166040890152565b61147d61146c6114666114608585610c4f565b9061135d565b60c01c90565b67ffffffffffffffff166060890152565b6114a16114906114666114608585610c62565b67ffffffffffffffff166080890152565b610c75565b60a0830152565b604051906114ba826106b6565b5f6020838281520152565b6114cd6114ad565b506020815191604051926114e0846106b6565b835201602082015290565b9060018201809211610d3057565b91908201809211610d3057565b5f198114610d305760010190565b61151d816115e5565b1561013d5761152b8161172e565b61153481610f4d565b9161154260405193846106d7565b818352601f1961155183610f4d565b015f5b8181106115ce57505061157560208092015161156f81611814565b906114f9565b5f905b838210611586575050505090565b6115c2816115966115c89361178f565b9061159f610719565b82815281878201526115b1868a610f0b565b526115bc8589610f0b565b506114f9565b91611506565b90611578565b6020906115d96114ad565b82828801015201611554565b80511561160457602060c0910151515f1a1061160057600190565b5f90565b505f90565b80516015810361013d578015159081611651575b501561013d576116346001600160a01b03916116b5565b9051906020811061164457501690565b6020036101000a90041690565b6021915011155f61161d565b60bf19810191908211610d3057565b607f19810191908211610d3057565b6020039060208211610d3057565b5f19810191908211610d3057565b60f619810191908211610d3057565b60b619810191908211610d3057565b9060208201916116c58351611814565b925190838201809211610d305751928303928311610d30579190565b80511561013d576116f46112e0916116b5565b61170081939293610769565b9261170e60405194856106d7565b818452601f1961171d83610769565b013660208601378360200190611881565b805115611604575f906020810190815161174781611814565b8101809111610d3057915190518101809111610d305791905b82811061176d5750905090565b6117768161178f565b8101809111610d30576117899091611506565b90611760565b80515f1a9060808210156117a4575050600190565b60b88210156117bf57506117ba6112e09161166c565b6114eb565b9060c08110156117e35760b51991600160b783602003016101000a91015104010190565b9060f88210156117fa57506117ba6112e09161165d565b60010151602082900360f7016101000a90040160f5190190565b515f1a608081101561182557505f90565b60b88110801561185c575b1561183b5750600190565b60c0811015611850576117ba6112e0916116a6565b6117ba6112e091611697565b5060c08110158015611830575060f88110611830565b601f8111610d30576101000a90565b9290919283156118f85792915b6020938484106118c35780518252848101809111610d3057938101809111610d305791601f198101908111610d30579161188e565b91935091806118d157505050565b6118e56118e06118ea9261167b565b611872565b611689565b905182518216911916179052565b5091505056fea2646970667358221220db33f16f0bf1d71b72b0bfb23e8eeb6a86c6e68ba97c81f6276971b44d056d0464736f6c63430008140033",
}

// ReceiptVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ReceiptVerifierMetaData.ABI instead.
var ReceiptVerifierABI = ReceiptVerifierMetaData.ABI

// ReceiptVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ReceiptVerifierMetaData.Bin instead.
var ReceiptVerifierBin = ReceiptVerifierMetaData.Bin

// DeployReceiptVerifier deploys a new Ethereum contract, binding an instance of ReceiptVerifier to it.
func DeployReceiptVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blockChunks common.Address) (common.Address, *types.Transaction, *ReceiptVerifier, error) {
	parsed, err := ReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ReceiptVerifierBin), backend, _blockChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ReceiptVerifier{ReceiptVerifierCaller: ReceiptVerifierCaller{contract: contract}, ReceiptVerifierTransactor: ReceiptVerifierTransactor{contract: contract}, ReceiptVerifierFilterer: ReceiptVerifierFilterer{contract: contract}}, nil
}

// ReceiptVerifier is an auto generated Go binding around an Ethereum contract.
type ReceiptVerifier struct {
	ReceiptVerifierCaller     // Read-only binding to the contract
	ReceiptVerifierTransactor // Write-only binding to the contract
	ReceiptVerifierFilterer   // Log filterer for contract events
}

// ReceiptVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ReceiptVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ReceiptVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ReceiptVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ReceiptVerifierSession struct {
	Contract     *ReceiptVerifier  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ReceiptVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ReceiptVerifierCallerSession struct {
	Contract *ReceiptVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ReceiptVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ReceiptVerifierTransactorSession struct {
	Contract     *ReceiptVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ReceiptVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ReceiptVerifierRaw struct {
	Contract *ReceiptVerifier // Generic contract binding to access the raw methods on
}

// ReceiptVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ReceiptVerifierCallerRaw struct {
	Contract *ReceiptVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ReceiptVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ReceiptVerifierTransactorRaw struct {
	Contract *ReceiptVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewReceiptVerifier creates a new instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifier(address common.Address, backend bind.ContractBackend) (*ReceiptVerifier, error) {
	contract, err := bindReceiptVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifier{ReceiptVerifierCaller: ReceiptVerifierCaller{contract: contract}, ReceiptVerifierTransactor: ReceiptVerifierTransactor{contract: contract}, ReceiptVerifierFilterer: ReceiptVerifierFilterer{contract: contract}}, nil
}

// NewReceiptVerifierCaller creates a new read-only instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierCaller(address common.Address, caller bind.ContractCaller) (*ReceiptVerifierCaller, error) {
	contract, err := bindReceiptVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierCaller{contract: contract}, nil
}

// NewReceiptVerifierTransactor creates a new write-only instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ReceiptVerifierTransactor, error) {
	contract, err := bindReceiptVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierTransactor{contract: contract}, nil
}

// NewReceiptVerifierFilterer creates a new log filterer instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ReceiptVerifierFilterer, error) {
	contract, err := bindReceiptVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierFilterer{contract: contract}, nil
}

// bindReceiptVerifier binds a generic wrapper to an already deployed contract.
func bindReceiptVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReceiptVerifier *ReceiptVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReceiptVerifier.Contract.ReceiptVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReceiptVerifier *ReceiptVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.ReceiptVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReceiptVerifier *ReceiptVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.ReceiptVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReceiptVerifier *ReceiptVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReceiptVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReceiptVerifier *ReceiptVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReceiptVerifier *ReceiptVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "blockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) BlockChunks() (common.Address, error) {
	return _ReceiptVerifier.Contract.BlockChunks(&_ReceiptVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _ReceiptVerifier.Contract.BlockChunks(&_ReceiptVerifier.CallOpts)
}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCaller) DecodeReceipt(opts *bind.CallOpts, receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "decodeReceipt", receiptRaw)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) DecodeReceipt(receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.DecodeReceipt(&_ReceiptVerifier.CallOpts, receiptRaw)
}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) DecodeReceipt(receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.DecodeReceipt(&_ReceiptVerifier.CallOpts, receiptRaw)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) Owner() (common.Address, error) {
	return _ReceiptVerifier.Contract.Owner(&_ReceiptVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) Owner() (common.Address, error) {
	return _ReceiptVerifier.Contract.Owner(&_ReceiptVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _ReceiptVerifier.Contract.VerifierAddresses(&_ReceiptVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _ReceiptVerifier.Contract.VerifierAddresses(&_ReceiptVerifier.CallOpts, arg0)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCaller) VerifyReceipt(opts *bind.CallOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "verifyReceipt", receiptRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.VerifyReceipt(&_ReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.VerifyReceipt(&_ReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.TransferOwnership(&_ReceiptVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.TransferOwnership(&_ReceiptVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "updateBlockChunks", _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateBlockChunks(&_ReceiptVerifier.TransactOpts, _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateBlockChunks(&_ReceiptVerifier.TransactOpts, _blockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateVerifierAddress(&_ReceiptVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateVerifierAddress(&_ReceiptVerifier.TransactOpts, _chainId, _verifierAddress)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierTransactor) VerifyReceiptAndLog(opts *bind.TransactOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "verifyReceiptAndLog", receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.VerifyReceiptAndLog(&_ReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.VerifyReceiptAndLog(&_ReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// ReceiptVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ReceiptVerifier contract.
type ReceiptVerifierOwnershipTransferredIterator struct {
	Event *ReceiptVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the ReceiptVerifier contract.
type ReceiptVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ReceiptVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierOwnershipTransferredIterator{contract: _ReceiptVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierOwnershipTransferred)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*ReceiptVerifierOwnershipTransferred, error) {
	event := new(ReceiptVerifierOwnershipTransferred)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateBlockChunksIterator struct {
	Event *ReceiptVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*ReceiptVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierUpdateBlockChunksIterator{contract: _ReceiptVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierUpdateBlockChunks)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*ReceiptVerifierUpdateBlockChunks, error) {
	event := new(ReceiptVerifierUpdateBlockChunks)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateVerifierAddressIterator struct {
	Event *ReceiptVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*ReceiptVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierUpdateVerifierAddressIterator{contract: _ReceiptVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierUpdateVerifierAddress)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*ReceiptVerifierUpdateVerifierAddress, error) {
	event := new(ReceiptVerifierUpdateVerifierAddress)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierVerifiedReceiptIterator is returned from FilterVerifiedReceipt and is used to iterate over the raw logs and unpacked data for VerifiedReceipt events raised by the ReceiptVerifier contract.
type ReceiptVerifierVerifiedReceiptIterator struct {
	Event *ReceiptVerifierVerifiedReceipt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierVerifiedReceiptIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierVerifiedReceipt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierVerifiedReceipt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierVerifiedReceiptIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierVerifiedReceiptIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierVerifiedReceipt represents a VerifiedReceipt event raised by the ReceiptVerifier contract.
type ReceiptVerifierVerifiedReceipt struct {
	ChainId     uint64
	ReceiptHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVerifiedReceipt is a free log retrieval operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterVerifiedReceipt(opts *bind.FilterOpts) (*ReceiptVerifierVerifiedReceiptIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "VerifiedReceipt")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierVerifiedReceiptIterator{contract: _ReceiptVerifier.contract, event: "VerifiedReceipt", logs: logs, sub: sub}, nil
}

// WatchVerifiedReceipt is a free log subscription operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchVerifiedReceipt(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierVerifiedReceipt) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "VerifiedReceipt")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierVerifiedReceipt)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "VerifiedReceipt", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedReceipt is a log parse operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseVerifiedReceipt(log types.Log) (*ReceiptVerifierVerifiedReceipt, error) {
	event := new(ReceiptVerifierVerifiedReceipt)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "VerifiedReceipt", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReentrancyGuardMetaData contains all meta data concerning the ReentrancyGuard contract.
var ReentrancyGuardMetaData = &bind.MetaData{
	ABI: "[]",
}

// ReentrancyGuardABI is the input ABI used to generate the binding from.
// Deprecated: Use ReentrancyGuardMetaData.ABI instead.
var ReentrancyGuardABI = ReentrancyGuardMetaData.ABI

// ReentrancyGuard is an auto generated Go binding around an Ethereum contract.
type ReentrancyGuard struct {
	ReentrancyGuardCaller     // Read-only binding to the contract
	ReentrancyGuardTransactor // Write-only binding to the contract
	ReentrancyGuardFilterer   // Log filterer for contract events
}

// ReentrancyGuardCaller is an auto generated read-only Go binding around an Ethereum contract.
type ReentrancyGuardCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ReentrancyGuardFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ReentrancyGuardSession struct {
	Contract     *ReentrancyGuard  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ReentrancyGuardCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ReentrancyGuardCallerSession struct {
	Contract *ReentrancyGuardCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ReentrancyGuardTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ReentrancyGuardTransactorSession struct {
	Contract     *ReentrancyGuardTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ReentrancyGuardRaw is an auto generated low-level Go binding around an Ethereum contract.
type ReentrancyGuardRaw struct {
	Contract *ReentrancyGuard // Generic contract binding to access the raw methods on
}

// ReentrancyGuardCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ReentrancyGuardCallerRaw struct {
	Contract *ReentrancyGuardCaller // Generic read-only contract binding to access the raw methods on
}

// ReentrancyGuardTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactorRaw struct {
	Contract *ReentrancyGuardTransactor // Generic write-only contract binding to access the raw methods on
}

// NewReentrancyGuard creates a new instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuard(address common.Address, backend bind.ContractBackend) (*ReentrancyGuard, error) {
	contract, err := bindReentrancyGuard(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuard{ReentrancyGuardCaller: ReentrancyGuardCaller{contract: contract}, ReentrancyGuardTransactor: ReentrancyGuardTransactor{contract: contract}, ReentrancyGuardFilterer: ReentrancyGuardFilterer{contract: contract}}, nil
}

// NewReentrancyGuardCaller creates a new read-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardCaller(address common.Address, caller bind.ContractCaller) (*ReentrancyGuardCaller, error) {
	contract, err := bindReentrancyGuard(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardCaller{contract: contract}, nil
}

// NewReentrancyGuardTransactor creates a new write-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardTransactor(address common.Address, transactor bind.ContractTransactor) (*ReentrancyGuardTransactor, error) {
	contract, err := bindReentrancyGuard(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardTransactor{contract: contract}, nil
}

// NewReentrancyGuardFilterer creates a new log filterer instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardFilterer(address common.Address, filterer bind.ContractFilterer) (*ReentrancyGuardFilterer, error) {
	contract, err := bindReentrancyGuard(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardFilterer{contract: contract}, nil
}

// bindReentrancyGuard binds a generic wrapper to an already deployed contract.
func bindReentrancyGuard(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ReentrancyGuardMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.ReentrancyGuardCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transact(opts, method, params...)
}

// SMTMetaData contains all meta data concerning the SMT contract.
var SMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_anchorProviders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_initRoots\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"AnchorProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"}],\"name\":\"SmtRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorProviders\",\"outputs\":[{\"internalType\":\"contractIAnchorBlocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLatestRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"latestRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"setAnchorProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"smtRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"commitPub\",\"type\":\"bytes32\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"contractIVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060808152346200039b5762001e1e90813803806200001f81620003b9565b93843982016080838203126200039b5782516001600160401b0391908281116200039b5784019381601f860112156200039b578451916200006a6200006484620003f3565b620003b9565b908196848352602080930183600596871b830101918383116200039b578401905b8282106200039f57505050818301518581116200039b5781620000b09185016200040b565b96868401518681116200039b5782620000cb9186016200040b565b936060810151908782116200039b57019180601f840112156200039b578251620000f96200006482620003f3565b938580868481520192891b8201019283116200039b5785809101915b8383106200038a5750505f80548a519891976001600160a01b0394509250338482167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08a80a36001600160a81b0319163360ff60a01b198116919091178855875260018087528a88205490989060ff166200034857506002549a680100000000000000008c10156200033457888c01806002558c101562000320578a99899c957f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8898c9860028d52818d20019d60018060a01b03199e8f3390825416179055338d52898252808d2060ff199a8b82541617905551338152a16200021c815184511462000479565b6200022b815186511462000479565b6200023a815189511462000479565b899d5b62000252575b8c5161193f9081620004df8239f35b8d815111156200031a578d808e8e8c828f8c8c878d838e8e620002778f8690620004b5565b51169c6200028591620004b5565b5116908b865287528585209088825416179055620002a391620004b5565b51169287825260069052209182541617905560078c52818d8c83822092620002cb91620004b5565b5190528c528c208d8a825416179055620002e6908a620004b5565b51908b5260088a528d8b20555f198e1462000306579c8a019c8a6200023d565b634e487b7160e01b8a52601160045260248afd5b62000243565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b62461bcd60e51b815260048101879052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b825181529181019186910162000115565b5f80fd5b815188811681036200039b5781529084019084016200008b565b6040519190601f01601f191682016001600160401b03811183821017620003df57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111620003df5760051b60200190565b9080601f830112156200039b578151906200042a6200006483620003f3565b9182938184526020808095019260051b8201019283116200039b578301905b82821062000458575050505090565b81516001600160a01b03811681036200039b57815290830190830162000449565b156200048157565b60405162461bcd60e51b815260206004820152600c60248201526b0d8cadc40dad2e6dac2e8c6d60a31b6044820152606490fd5b8051821015620004ca5760209160051b010190565b634e487b7160e01b5f52603260045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081631019b616146111c957508063158535ff14611198578063318a492d14610aef5780633870253214610aa55780633f4ba83a146109a557806346fbf68e1461067e578063479aa6da1461070a5780634f4fef181461098857806358a16b441461096b5780635c975abb146109475780635ca32bd81461088a578063677625f2146107435780636ae3e0801461070a5780636b2c0f55146106d45780636ef8d66d146106bb57806380f51c121461067e5780638195408d1461063c57806382dc1ec4146106065780638456cb59146104ef5780638da5cb5b146104ca5780639c8413c514610408578063a036e799146103ba578063afe8154b14610378578063e6c6fcec1461032a578063e79b7a51146102d5578063f2fde38b146101ed578063fabc74f5146101955763fd1190ea14610150575f80fd5b3461019157602036600319011261019157600435600454811015610191576001600160a01b0361018160209261126e565b9190546040519260031b1c168152f35b5f80fd5b34610191576020366003190112610191576001600160a01b036101b66112e1565b165f52600360205260ff60405f20541660405160038210156101d9576020918152f35b634e487b7160e01b5f52602160045260245ffd5b34610191576020366003190112610191576102066112e1565b5f54906001600160a01b03808316916102203384146113c5565b1691821561026a5773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b34610191576102e33661130d565b6001600160a01b03906102fa825f541633146113c5565b5f5b8151811015610328578061031e846103176103239486611432565b5116611668565b611410565b6102fc565b005b34610191576103383661130d565b6001600160a01b039061034f825f541633146113c5565b5f5b8151811015610328578061031e8461036c6103739486611432565b5116611492565b610351565b346101915760203660031901126101915767ffffffffffffffff61039a61120e565b165f52600560205260206001600160a01b0360405f205416604051908152f35b34610191576103c83661130d565b6001600160a01b03906103df825f541633146113c5565b5f5b8151811015610328578061031e846103fc6104039486611432565b511661174d565b6103e1565b34610191576040366003190112610191577fb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be816261044261120e565b61044a6112f7565b906001600160a01b03610461815f541633146113c5565b67ffffffffffffffff82165f52600660205260405f2090831673ffffffffffffffffffffffffffffffffffffffff198254161790556104c5604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b0390a1005b34610191575f3660031901126101915760206001600160a01b035f5416604051908152f35b34610191575f36600319011261019157335f52600160209080825261051a60ff60405f205416611446565b5f5460ff8160a01c166105c15760ff60a01b19740100000000000000000000000000000000000000009116175f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a15f815b61057a57005b60045481101561032857806001600160a01b036105996105bb9361126e565b919054600392831b1c165f52845260405f20600260ff19825416179055611410565b81610574565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b34610191576020366003190112610191576103286106226112e1565b6106376001600160a01b035f541633146113c5565b611668565b346101915760203660031901126101915767ffffffffffffffff61065e61120e565b165f52600660205260206001600160a01b0360405f205416604051908152f35b34610191576020366003190112610191576001600160a01b0361069f6112e1565b165f526001602052602060ff60405f2054166040519015158152f35b34610191575f366003190112610191576103283361174d565b34610191576020366003190112610191576103286106f06112e1565b6107056001600160a01b035f541633146113c5565b61174d565b346101915760203660031901126101915767ffffffffffffffff61072c61120e565b165f526008602052602060405f2054604051908152f35b34610191576107513661130d565b6001600160a01b03610767815f541633146113c5565b5f5b8251811015610328578161077d8285611432565b511690815f526003602081815260ff60405f205416828110156101d9576108465760045493680100000000000000008510156108325761082d947fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849361080e836107ee60019485810160045561126e565b90919082549060031b916001600160a01b03809116831b921b1916179055565b825f52835260405f209060ff19825416179055604051908152a1611410565b610769565b634e487b7160e01b5f52604160045260245ffd5b6064906040519062461bcd60e51b82526004820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b34610191576040366003190112610191577fd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c80906108c461120e565b6108cc6112f7565b906001600160a01b036108e3815f541633146113c5565b67ffffffffffffffff82165f52600560205260405f2090831673ffffffffffffffffffffffffffffffffffffffff198254161790556104c5604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b34610191575f36600319011261019157602060ff5f5460a01c166040519015158152f35b34610191575f366003190112610191576020600254604051908152f35b34610191575f366003190112610191576020600454604051908152f35b34610191575f36600319011261019157335f5260016020908082526109d060ff60405f205416611446565b5f5460ff8160a01c1615610a605760ff60a01b19165f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a15f815b610a1957005b60045481101561032857610a5a816001600160a01b03610a39859461126e565b919054600392831b1c165f52855260405f208360ff19825416179055611410565b90610a13565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b346101915760403660031901126101915767ffffffffffffffff610ac761120e565b165f52600760205260405f206024355f52602052602060ff60405f2054166040519015158152f35b346101915761020036600319011261019157610b0961120e565b6101e0366023190112610191576040519060c0820182811067ffffffffffffffff82111761083257604052602435825260443567ffffffffffffffff811681036101915760208301526064803560408401526084356060840152906101403660a3190112610191576040516080810181811067ffffffffffffffff82111761083257806040523660c3121561019157610ba1816112a3565b803660e4116101915760a4905b60e48210611188575050815236610103121561019157604051610bd0816112a3565b8036610164116101915760e4905b6101648210611136575050602082015236610183121561019157604051610c04816112a3565b80366101a41161019157610164905b6101a482106111265750506040820152366101c3121561019157604051610c39816112a3565b80366101e411610191576101a4905b6101e48210611116575050606082015260808401526101e43560a0840152335f52600360205260ff60405f20541660038110156101d9576001036110d357606083015115610fb1575b67ffffffffffffffff81165f52600860205260405f20549060066020526001600160a01b0360405f205416908115610f6d57604051928361014081011067ffffffffffffffff6101408601111761083257610140849394016040526101403684378060801c83526fffffffffffffffffffffffffffffffff8091166020840152855160801c6040840152808651166060840152604086015160801c60808401528060408701511660a084015267ffffffffffffffff60208701511660c0840152606086015160801c60e084015260608601511661010083015260a085015161012083015260808501519384516020860151946060604088015197015194610da9604051936313a4214360e31b8552600485019061139e565b5f9695604484015b6002891015610df45787515f90825b60028310610dde575050506020604060019201980198019796610db1565b6020806001928451815201920192019190610dc0565b5089965090610e178492610e0c8b60c486019061139e565b61010484019061139e565b5f61014483015b600a8210610f5357505050610284816020935afa908115610f48575f91610f0d575b5015610ecb577f05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a76040848467ffffffffffffffff81165f526007602052825f2082515f52602052825f20600160ff1982541617905567ffffffffffffffff825191165f526008602052825f205567ffffffffffffffff602082519201511682519182526020820152a1005b60405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207a6b2070726f6f66000000000000000000000000000000006044820152fd5b90506020813d602011610f40575b81610f28602093836112bf565b81010312610191575180151581036101915784610e40565b3d9150610f1b565b6040513d5f823e3d90fd5b829350602080916001939451815201930191018492610e1e565b60405162461bcd60e51b815260206004820152601760248201527f6e6f20766572696669657220666f7220636861696e496400000000000000000060448201528490fd5b67ffffffffffffffff81165f5260056020526001600160a01b0360405f205416801561108f57602067ffffffffffffffff818601511660246040518094819363f25b3f9960e01b835260048301525afa908115610f48575f9161105d575b50604084015114610c91575060405162461bcd60e51b815260206004820152601360248201527f616e63686f7220636865636b206661696c6564000000000000000000000000006044820152fd5b90506020813d602011611087575b81611078602093836112bf565b8101031261019157518461100f565b3d915061106b565b60405162461bcd60e51b815260206004820152601760248201527f756e6b6e6f776e20616e63686f722070726f766964657200000000000000000060448201528390fd5b5060405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152fd5b8135815260209182019101610c48565b8135815260209182019101610c13565b36601f830112156101915760405161114d816112a3565b803660408501116101915783905b604085018210611178575050816020916040935201910190610bde565b813581526020918201910161115b565b8135815260209182019101610bae565b3461019157602036600319011261019157600435600254811015610191576001600160a01b03610181602092611225565b346101915760403660031901126101915760209067ffffffffffffffff6111ee61120e565b165f526007825260405f206024355f52825260ff60405f20541615158152f35b6004359067ffffffffffffffff8216820361019157565b60025481101561125a5760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b60045481101561125a5760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6040810190811067ffffffffffffffff82111761083257604052565b90601f8019910116810190811067ffffffffffffffff82111761083257604052565b600435906001600160a01b038216820361019157565b602435906001600160a01b038216820361019157565b6020806003198301126101915767ffffffffffffffff916004358381116101915781602382011215610191578060040135938411610832578360051b906040519461135a858401876112bf565b855260248486019282010192831161019157602401905b82821061137f575050505090565b81356001600160a01b0381168103610191578152908301908301611371565b5f915b600283106113ae57505050565b6001908251815260208091019201920191906113a1565b156113cc57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f19811461141e5760010190565b634e487b7160e01b5f52601160045260245ffd5b805182101561125a5760209160051b010190565b1561144d57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff8282205416878110156116545715611610576004968754965f19908189019889116115fd57835b8a548110156115ba5786826114eb8361126e565b905490871b1c16146115055761150090611410565b6114d7565b909192939495969798808210611595575b505050875480156115825797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859899019061156c6115578361126e565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b6115b2926115a56107ee9261126e565b905490871b1c169161126e565b5f8080611516565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff60408320541661170857600254680100000000000000008110156116f4576020926116d87f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936107ee84600160409601600255611225565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff8588205416156118c5576002805490915f19918281019081116118b157908695949392918a975b6117dc575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a10156118a85781856117f48c611225565b929054600393841b1c161461181d57506118148798999a97959697611410565b97969594611793565b9293949796959991818310611883575b505050508154801561186f57918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e989993019061156c61155783611225565b634e487b7160e01b89526031600452602489fd5b61189f936118936107ee93611225565b9054911b1c1691611225565b5f80808061182d565b87989950611798565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220697413ba9cf319aae2e1f52027952bca31cc5ef99b0466a9fb461e58203e8c0a64736f6c63430008140033",
}

// SMTABI is the input ABI used to generate the binding from.
// Deprecated: Use SMTMetaData.ABI instead.
var SMTABI = SMTMetaData.ABI

// SMTBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SMTMetaData.Bin instead.
var SMTBin = SMTMetaData.Bin

// DeploySMT deploys a new Ethereum contract, binding an instance of SMT to it.
func DeploySMT(auth *bind.TransactOpts, backend bind.ContractBackend, _chainIds []uint64, _anchorProviders []common.Address, _verifiers []common.Address, _initRoots [][32]byte) (common.Address, *types.Transaction, *SMT, error) {
	parsed, err := SMTMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SMTBin), backend, _chainIds, _anchorProviders, _verifiers, _initRoots)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SMT{SMTCaller: SMTCaller{contract: contract}, SMTTransactor: SMTTransactor{contract: contract}, SMTFilterer: SMTFilterer{contract: contract}}, nil
}

// SMT is an auto generated Go binding around an Ethereum contract.
type SMT struct {
	SMTCaller     // Read-only binding to the contract
	SMTTransactor // Write-only binding to the contract
	SMTFilterer   // Log filterer for contract events
}

// SMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type SMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SMTSession struct {
	Contract     *SMT              // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SMTCallerSession struct {
	Contract *SMTCaller    // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// SMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SMTTransactorSession struct {
	Contract     *SMTTransactor    // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type SMTRaw struct {
	Contract *SMT // Generic contract binding to access the raw methods on
}

// SMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SMTCallerRaw struct {
	Contract *SMTCaller // Generic read-only contract binding to access the raw methods on
}

// SMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SMTTransactorRaw struct {
	Contract *SMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSMT creates a new instance of SMT, bound to a specific deployed contract.
func NewSMT(address common.Address, backend bind.ContractBackend) (*SMT, error) {
	contract, err := bindSMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SMT{SMTCaller: SMTCaller{contract: contract}, SMTTransactor: SMTTransactor{contract: contract}, SMTFilterer: SMTFilterer{contract: contract}}, nil
}

// NewSMTCaller creates a new read-only instance of SMT, bound to a specific deployed contract.
func NewSMTCaller(address common.Address, caller bind.ContractCaller) (*SMTCaller, error) {
	contract, err := bindSMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SMTCaller{contract: contract}, nil
}

// NewSMTTransactor creates a new write-only instance of SMT, bound to a specific deployed contract.
func NewSMTTransactor(address common.Address, transactor bind.ContractTransactor) (*SMTTransactor, error) {
	contract, err := bindSMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SMTTransactor{contract: contract}, nil
}

// NewSMTFilterer creates a new log filterer instance of SMT, bound to a specific deployed contract.
func NewSMTFilterer(address common.Address, filterer bind.ContractFilterer) (*SMTFilterer, error) {
	contract, err := bindSMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SMTFilterer{contract: contract}, nil
}

// bindSMT binds a generic wrapper to an already deployed contract.
func bindSMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SMT *SMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SMT.Contract.SMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SMT *SMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.Contract.SMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SMT *SMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SMT.Contract.SMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SMT *SMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SMT *SMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SMT *SMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SMT.Contract.contract.Transact(opts, method, params...)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTCaller) AnchorProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "anchorProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.AnchorProviders(&_SMT.CallOpts, arg0)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTCallerSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.AnchorProviders(&_SMT.CallOpts, arg0)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTCaller) GetLatestRoot(opts *bind.CallOpts, chainId uint64) ([32]byte, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "getLatestRoot", chainId)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _SMT.Contract.GetLatestRoot(&_SMT.CallOpts, chainId)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTCallerSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _SMT.Contract.GetLatestRoot(&_SMT.CallOpts, chainId)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTSession) IsPauser(account common.Address) (bool, error) {
	return _SMT.Contract.IsPauser(&_SMT.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTCallerSession) IsPauser(account common.Address) (bool, error) {
	return _SMT.Contract.IsPauser(&_SMT.CallOpts, account)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _SMT.Contract.IsSmtRootValid(&_SMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _SMT.Contract.IsSmtRootValid(&_SMT.CallOpts, chainId, smtRoot)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTCaller) LatestRoots(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "latestRoots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _SMT.Contract.LatestRoots(&_SMT.CallOpts, arg0)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTCallerSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _SMT.Contract.LatestRoots(&_SMT.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTSession) NumPausers() (*big.Int, error) {
	return _SMT.Contract.NumPausers(&_SMT.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTCallerSession) NumPausers() (*big.Int, error) {
	return _SMT.Contract.NumPausers(&_SMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTSession) NumProvers() (*big.Int, error) {
	return _SMT.Contract.NumProvers(&_SMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTCallerSession) NumProvers() (*big.Int, error) {
	return _SMT.Contract.NumProvers(&_SMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTSession) Owner() (common.Address, error) {
	return _SMT.Contract.Owner(&_SMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTCallerSession) Owner() (common.Address, error) {
	return _SMT.Contract.Owner(&_SMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTSession) Paused() (bool, error) {
	return _SMT.Contract.Paused(&_SMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTCallerSession) Paused() (bool, error) {
	return _SMT.Contract.Paused(&_SMT.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.PauserList(&_SMT.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.PauserList(&_SMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTSession) Pausers(arg0 common.Address) (bool, error) {
	return _SMT.Contract.Pausers(&_SMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _SMT.Contract.Pausers(&_SMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _SMT.Contract.ProverStates(&_SMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _SMT.Contract.ProverStates(&_SMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.Provers(&_SMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.Provers(&_SMT.CallOpts, arg0)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTCaller) SmtRoots(opts *bind.CallOpts, arg0 uint64, arg1 [32]byte) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "smtRoots", arg0, arg1)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _SMT.Contract.SmtRoots(&_SMT.CallOpts, arg0, arg1)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTCallerSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _SMT.Contract.SmtRoots(&_SMT.CallOpts, arg0, arg1)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTCaller) Verifiers(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "verifiers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.Verifiers(&_SMT.CallOpts, arg0)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTCallerSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.Verifiers(&_SMT.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPauser(&_SMT.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPauser(&_SMT.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPausers(&_SMT.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPausers(&_SMT.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddProvers(&_SMT.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddProvers(&_SMT.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTSession) Pause() (*types.Transaction, error) {
	return _SMT.Contract.Pause(&_SMT.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTTransactorSession) Pause() (*types.Transaction, error) {
	return _SMT.Contract.Pause(&_SMT.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePauser(&_SMT.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePauser(&_SMT.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePausers(&_SMT.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePausers(&_SMT.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemoveProvers(&_SMT.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemoveProvers(&_SMT.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTSession) RenouncePauser() (*types.Transaction, error) {
	return _SMT.Contract.RenouncePauser(&_SMT.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _SMT.Contract.RenouncePauser(&_SMT.TransactOpts)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTTransactor) SetAnchorProvider(opts *bind.TransactOpts, chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "setAnchorProvider", chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetAnchorProvider(&_SMT.TransactOpts, chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTTransactorSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetAnchorProvider(&_SMT.TransactOpts, chainId, anchorProvider)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTTransactor) SetVerifier(opts *bind.TransactOpts, chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "setVerifier", chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetVerifier(&_SMT.TransactOpts, chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTTransactorSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetVerifier(&_SMT.TransactOpts, chainId, verifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SMT.Contract.TransferOwnership(&_SMT.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SMT.Contract.TransferOwnership(&_SMT.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTSession) Unpause() (*types.Transaction, error) {
	return _SMT.Contract.Unpause(&_SMT.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTTransactorSession) Unpause() (*types.Transaction, error) {
	return _SMT.Contract.Unpause(&_SMT.TransactOpts)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_SMT *SMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_SMT *SMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.Contract.UpdateRoot(&_SMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_SMT *SMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.Contract.UpdateRoot(&_SMT.TransactOpts, chainId, u)
}

// SMTAnchorProviderUpdatedIterator is returned from FilterAnchorProviderUpdated and is used to iterate over the raw logs and unpacked data for AnchorProviderUpdated events raised by the SMT contract.
type SMTAnchorProviderUpdatedIterator struct {
	Event *SMTAnchorProviderUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTAnchorProviderUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTAnchorProviderUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTAnchorProviderUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTAnchorProviderUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTAnchorProviderUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTAnchorProviderUpdated represents a AnchorProviderUpdated event raised by the SMT contract.
type SMTAnchorProviderUpdated struct {
	ChainId        uint64
	AnchorProvider common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterAnchorProviderUpdated is a free log retrieval operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) FilterAnchorProviderUpdated(opts *bind.FilterOpts) (*SMTAnchorProviderUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTAnchorProviderUpdatedIterator{contract: _SMT.contract, event: "AnchorProviderUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorProviderUpdated is a free log subscription operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) WatchAnchorProviderUpdated(opts *bind.WatchOpts, sink chan<- *SMTAnchorProviderUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTAnchorProviderUpdated)
				if err := _SMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorProviderUpdated is a log parse operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) ParseAnchorProviderUpdated(log types.Log) (*SMTAnchorProviderUpdated, error) {
	event := new(SMTAnchorProviderUpdated)
	if err := _SMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SMT contract.
type SMTOwnershipTransferredIterator struct {
	Event *SMTOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTOwnershipTransferred represents a OwnershipTransferred event raised by the SMT contract.
type SMTOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SMTOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SMT.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SMTOwnershipTransferredIterator{contract: _SMT.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SMTOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SMT.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTOwnershipTransferred)
				if err := _SMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) ParseOwnershipTransferred(log types.Log) (*SMTOwnershipTransferred, error) {
	event := new(SMTOwnershipTransferred)
	if err := _SMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the SMT contract.
type SMTPausedIterator struct {
	Event *SMTPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPaused represents a Paused event raised by the SMT contract.
type SMTPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) FilterPaused(opts *bind.FilterOpts) (*SMTPausedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &SMTPausedIterator{contract: _SMT.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *SMTPaused) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPaused)
				if err := _SMT.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) ParsePaused(log types.Log) (*SMTPaused, error) {
	event := new(SMTPaused)
	if err := _SMT.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the SMT contract.
type SMTPauserAddedIterator struct {
	Event *SMTPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPauserAdded represents a PauserAdded event raised by the SMT contract.
type SMTPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*SMTPauserAddedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &SMTPauserAddedIterator{contract: _SMT.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *SMTPauserAdded) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPauserAdded)
				if err := _SMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) ParsePauserAdded(log types.Log) (*SMTPauserAdded, error) {
	event := new(SMTPauserAdded)
	if err := _SMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the SMT contract.
type SMTPauserRemovedIterator struct {
	Event *SMTPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPauserRemoved represents a PauserRemoved event raised by the SMT contract.
type SMTPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*SMTPauserRemovedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &SMTPauserRemovedIterator{contract: _SMT.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *SMTPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPauserRemoved)
				if err := _SMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) ParsePauserRemoved(log types.Log) (*SMTPauserRemoved, error) {
	event := new(SMTPauserRemoved)
	if err := _SMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the SMT contract.
type SMTProverAddedIterator struct {
	Event *SMTProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTProverAdded represents a ProverAdded event raised by the SMT contract.
type SMTProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) FilterProverAdded(opts *bind.FilterOpts) (*SMTProverAddedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &SMTProverAddedIterator{contract: _SMT.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *SMTProverAdded) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTProverAdded)
				if err := _SMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) ParseProverAdded(log types.Log) (*SMTProverAdded, error) {
	event := new(SMTProverAdded)
	if err := _SMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the SMT contract.
type SMTProverRemovedIterator struct {
	Event *SMTProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTProverRemoved represents a ProverRemoved event raised by the SMT contract.
type SMTProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*SMTProverRemovedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &SMTProverRemovedIterator{contract: _SMT.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *SMTProverRemoved) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTProverRemoved)
				if err := _SMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) ParseProverRemoved(log types.Log) (*SMTProverRemoved, error) {
	event := new(SMTProverRemoved)
	if err := _SMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTSmtRootUpdatedIterator is returned from FilterSmtRootUpdated and is used to iterate over the raw logs and unpacked data for SmtRootUpdated events raised by the SMT contract.
type SMTSmtRootUpdatedIterator struct {
	Event *SMTSmtRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTSmtRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTSmtRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTSmtRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTSmtRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTSmtRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTSmtRootUpdated represents a SmtRootUpdated event raised by the SMT contract.
type SMTSmtRootUpdated struct {
	SmtRoot     [32]byte
	EndBlockNum uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtRootUpdated is a free log retrieval operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_SMT *SMTFilterer) FilterSmtRootUpdated(opts *bind.FilterOpts) (*SMTSmtRootUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTSmtRootUpdatedIterator{contract: _SMT.contract, event: "SmtRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtRootUpdated is a free log subscription operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_SMT *SMTFilterer) WatchSmtRootUpdated(opts *bind.WatchOpts, sink chan<- *SMTSmtRootUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTSmtRootUpdated)
				if err := _SMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtRootUpdated is a log parse operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_SMT *SMTFilterer) ParseSmtRootUpdated(log types.Log) (*SMTSmtRootUpdated, error) {
	event := new(SMTSmtRootUpdated)
	if err := _SMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the SMT contract.
type SMTUnpausedIterator struct {
	Event *SMTUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTUnpaused represents a Unpaused event raised by the SMT contract.
type SMTUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) FilterUnpaused(opts *bind.FilterOpts) (*SMTUnpausedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &SMTUnpausedIterator{contract: _SMT.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *SMTUnpaused) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTUnpaused)
				if err := _SMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) ParseUnpaused(log types.Log) (*SMTUnpaused, error) {
	event := new(SMTUnpaused)
	if err := _SMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTVerifierUpdatedIterator is returned from FilterVerifierUpdated and is used to iterate over the raw logs and unpacked data for VerifierUpdated events raised by the SMT contract.
type SMTVerifierUpdatedIterator struct {
	Event *SMTVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTVerifierUpdated represents a VerifierUpdated event raised by the SMT contract.
type SMTVerifierUpdated struct {
	ChainId  uint64
	Verifier common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVerifierUpdated is a free log retrieval operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) FilterVerifierUpdated(opts *bind.FilterOpts) (*SMTVerifierUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTVerifierUpdatedIterator{contract: _SMT.contract, event: "VerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierUpdated is a free log subscription operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) WatchVerifierUpdated(opts *bind.WatchOpts, sink chan<- *SMTVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTVerifierUpdated)
				if err := _SMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierUpdated is a log parse operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) ParseVerifierUpdated(log types.Log) (*SMTVerifierUpdated, error) {
	event := new(SMTVerifierUpdated)
	if err := _SMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeCastMetaData contains all meta data concerning the SafeCast contract.
var SafeCastMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212204f475c892cbda698f12a0b91db9c6366c91dca0d42d74a2c5ab56b1cf6ee56c264736f6c63430008140033",
}

// SafeCastABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeCastMetaData.ABI instead.
var SafeCastABI = SafeCastMetaData.ABI

// SafeCastBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeCastMetaData.Bin instead.
var SafeCastBin = SafeCastMetaData.Bin

// DeploySafeCast deploys a new Ethereum contract, binding an instance of SafeCast to it.
func DeploySafeCast(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeCast, error) {
	parsed, err := SafeCastMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeCastBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeCast{SafeCastCaller: SafeCastCaller{contract: contract}, SafeCastTransactor: SafeCastTransactor{contract: contract}, SafeCastFilterer: SafeCastFilterer{contract: contract}}, nil
}

// SafeCast is an auto generated Go binding around an Ethereum contract.
type SafeCast struct {
	SafeCastCaller     // Read-only binding to the contract
	SafeCastTransactor // Write-only binding to the contract
	SafeCastFilterer   // Log filterer for contract events
}

// SafeCastCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeCastCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeCastTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeCastFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeCastSession struct {
	Contract     *SafeCast         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeCastCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeCastCallerSession struct {
	Contract *SafeCastCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeCastTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeCastTransactorSession struct {
	Contract     *SafeCastTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeCastRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeCastRaw struct {
	Contract *SafeCast // Generic contract binding to access the raw methods on
}

// SafeCastCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeCastCallerRaw struct {
	Contract *SafeCastCaller // Generic read-only contract binding to access the raw methods on
}

// SafeCastTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeCastTransactorRaw struct {
	Contract *SafeCastTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeCast creates a new instance of SafeCast, bound to a specific deployed contract.
func NewSafeCast(address common.Address, backend bind.ContractBackend) (*SafeCast, error) {
	contract, err := bindSafeCast(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeCast{SafeCastCaller: SafeCastCaller{contract: contract}, SafeCastTransactor: SafeCastTransactor{contract: contract}, SafeCastFilterer: SafeCastFilterer{contract: contract}}, nil
}

// NewSafeCastCaller creates a new read-only instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastCaller(address common.Address, caller bind.ContractCaller) (*SafeCastCaller, error) {
	contract, err := bindSafeCast(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeCastCaller{contract: contract}, nil
}

// NewSafeCastTransactor creates a new write-only instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeCastTransactor, error) {
	contract, err := bindSafeCast(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeCastTransactor{contract: contract}, nil
}

// NewSafeCastFilterer creates a new log filterer instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeCastFilterer, error) {
	contract, err := bindSafeCast(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeCastFilterer{contract: contract}, nil
}

// bindSafeCast binds a generic wrapper to an already deployed contract.
func bindSafeCast(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SafeCastMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeCast *SafeCastRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeCast.Contract.SafeCastCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeCast *SafeCastRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeCast.Contract.SafeCastTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeCast *SafeCastRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeCast.Contract.SafeCastTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeCast *SafeCastCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeCast.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeCast *SafeCastTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeCast.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeCast *SafeCastTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeCast.Contract.contract.Transact(opts, method, params...)
}

// SafeERC20MetaData contains all meta data concerning the SafeERC20 contract.
var SafeERC20MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220e4452412b1c842239525529cee107192565885a28e2498d223386853155461ed64736f6c63430008140033",
}

// SafeERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeERC20MetaData.ABI instead.
var SafeERC20ABI = SafeERC20MetaData.ABI

// SafeERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeERC20MetaData.Bin instead.
var SafeERC20Bin = SafeERC20MetaData.Bin

// DeploySafeERC20 deploys a new Ethereum contract, binding an instance of SafeERC20 to it.
func DeploySafeERC20(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeERC20, error) {
	parsed, err := SafeERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeERC20Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// SafeERC20 is an auto generated Go binding around an Ethereum contract.
type SafeERC20 struct {
	SafeERC20Caller     // Read-only binding to the contract
	SafeERC20Transactor // Write-only binding to the contract
	SafeERC20Filterer   // Log filterer for contract events
}

// SafeERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type SafeERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeERC20Session struct {
	Contract     *SafeERC20        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeERC20CallerSession struct {
	Contract *SafeERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// SafeERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeERC20TransactorSession struct {
	Contract     *SafeERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// SafeERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type SafeERC20Raw struct {
	Contract *SafeERC20 // Generic contract binding to access the raw methods on
}

// SafeERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeERC20CallerRaw struct {
	Contract *SafeERC20Caller // Generic read-only contract binding to access the raw methods on
}

// SafeERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeERC20TransactorRaw struct {
	Contract *SafeERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeERC20 creates a new instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20(address common.Address, backend bind.ContractBackend) (*SafeERC20, error) {
	contract, err := bindSafeERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// NewSafeERC20Caller creates a new read-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Caller(address common.Address, caller bind.ContractCaller) (*SafeERC20Caller, error) {
	contract, err := bindSafeERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Caller{contract: contract}, nil
}

// NewSafeERC20Transactor creates a new write-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*SafeERC20Transactor, error) {
	contract, err := bindSafeERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Transactor{contract: contract}, nil
}

// NewSafeERC20Filterer creates a new log filterer instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*SafeERC20Filterer, error) {
	contract, err := bindSafeERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Filterer{contract: contract}, nil
}

// bindSafeERC20 binds a generic wrapper to an already deployed contract.
func bindSafeERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SafeERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.SafeERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transact(opts, method, params...)
}

// SameChainAnchorBlocksMetaData contains all meta data concerning the SameChainAnchorBlocks contract.
var SameChainAnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461005a575f8054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3610211908161005f8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f90813560e01c9081638da5cb5b146101a757508063f25b3f99146101885763f2fde38b1461003f575f80fd5b346101855760203660031901126101855760043573ffffffffffffffffffffffffffffffffffffffff8082168092036101815782549081169033820361013d5782156100d2577fffffffffffffffffffffffff000000000000000000000000000000000000000016821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b8280fd5b80fd5b5034610185576020366003190112610185576020604051600435408152f35b9050346101d757816003193601126101d75773ffffffffffffffffffffffffffffffffffffffff60209254168152f35b5080fdfea26469706673582212205e5ffe9317aae71c622720c397618703d8c3c5ee1a5afd82bc1c200569d6c10364736f6c63430008140033",
}

// SameChainAnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use SameChainAnchorBlocksMetaData.ABI instead.
var SameChainAnchorBlocksABI = SameChainAnchorBlocksMetaData.ABI

// SameChainAnchorBlocksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SameChainAnchorBlocksMetaData.Bin instead.
var SameChainAnchorBlocksBin = SameChainAnchorBlocksMetaData.Bin

// DeploySameChainAnchorBlocks deploys a new Ethereum contract, binding an instance of SameChainAnchorBlocks to it.
func DeploySameChainAnchorBlocks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SameChainAnchorBlocks, error) {
	parsed, err := SameChainAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SameChainAnchorBlocksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SameChainAnchorBlocks{SameChainAnchorBlocksCaller: SameChainAnchorBlocksCaller{contract: contract}, SameChainAnchorBlocksTransactor: SameChainAnchorBlocksTransactor{contract: contract}, SameChainAnchorBlocksFilterer: SameChainAnchorBlocksFilterer{contract: contract}}, nil
}

// SameChainAnchorBlocks is an auto generated Go binding around an Ethereum contract.
type SameChainAnchorBlocks struct {
	SameChainAnchorBlocksCaller     // Read-only binding to the contract
	SameChainAnchorBlocksTransactor // Write-only binding to the contract
	SameChainAnchorBlocksFilterer   // Log filterer for contract events
}

// SameChainAnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SameChainAnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SameChainAnchorBlocksSession struct {
	Contract     *SameChainAnchorBlocks // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// SameChainAnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SameChainAnchorBlocksCallerSession struct {
	Contract *SameChainAnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// SameChainAnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SameChainAnchorBlocksTransactorSession struct {
	Contract     *SameChainAnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// SameChainAnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type SameChainAnchorBlocksRaw struct {
	Contract *SameChainAnchorBlocks // Generic contract binding to access the raw methods on
}

// SameChainAnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksCallerRaw struct {
	Contract *SameChainAnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// SameChainAnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksTransactorRaw struct {
	Contract *SameChainAnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSameChainAnchorBlocks creates a new instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocks(address common.Address, backend bind.ContractBackend) (*SameChainAnchorBlocks, error) {
	contract, err := bindSameChainAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocks{SameChainAnchorBlocksCaller: SameChainAnchorBlocksCaller{contract: contract}, SameChainAnchorBlocksTransactor: SameChainAnchorBlocksTransactor{contract: contract}, SameChainAnchorBlocksFilterer: SameChainAnchorBlocksFilterer{contract: contract}}, nil
}

// NewSameChainAnchorBlocksCaller creates a new read-only instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*SameChainAnchorBlocksCaller, error) {
	contract, err := bindSameChainAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksCaller{contract: contract}, nil
}

// NewSameChainAnchorBlocksTransactor creates a new write-only instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*SameChainAnchorBlocksTransactor, error) {
	contract, err := bindSameChainAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksTransactor{contract: contract}, nil
}

// NewSameChainAnchorBlocksFilterer creates a new log filterer instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*SameChainAnchorBlocksFilterer, error) {
	contract, err := bindSameChainAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksFilterer{contract: contract}, nil
}

// bindSameChainAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindSameChainAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SameChainAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SameChainAnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCaller) Blocks(opts *bind.CallOpts, blockNum *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _SameChainAnchorBlocks.contract.Call(opts, &out, "blocks", blockNum)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _SameChainAnchorBlocks.Contract.Blocks(&_SameChainAnchorBlocks.CallOpts, blockNum)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _SameChainAnchorBlocks.Contract.Blocks(&_SameChainAnchorBlocks.CallOpts, blockNum)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SameChainAnchorBlocks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) Owner() (common.Address, error) {
	return _SameChainAnchorBlocks.Contract.Owner(&_SameChainAnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerSession) Owner() (common.Address, error) {
	return _SameChainAnchorBlocks.Contract.Owner(&_SameChainAnchorBlocks.CallOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.TransferOwnership(&_SameChainAnchorBlocks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.TransferOwnership(&_SameChainAnchorBlocks.TransactOpts, newOwner)
}

// SameChainAnchorBlocksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SameChainAnchorBlocks contract.
type SameChainAnchorBlocksOwnershipTransferredIterator struct {
	Event *SameChainAnchorBlocksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SameChainAnchorBlocksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SameChainAnchorBlocksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SameChainAnchorBlocksOwnershipTransferred represents a OwnershipTransferred event raised by the SameChainAnchorBlocks contract.
type SameChainAnchorBlocksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SameChainAnchorBlocksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SameChainAnchorBlocks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksOwnershipTransferredIterator{contract: _SameChainAnchorBlocks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SameChainAnchorBlocksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SameChainAnchorBlocks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SameChainAnchorBlocksOwnershipTransferred)
				if err := _SameChainAnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) ParseOwnershipTransferred(log types.Log) (*SameChainAnchorBlocksOwnershipTransferred, error) {
	event := new(SameChainAnchorBlocksOwnershipTransferred)
	if err := _SameChainAnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueMetaData contains all meta data concerning the SlotValue contract.
var SlotValueMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedSlotValueProof\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"submitSlotValuePoof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60803461007357601f6103ad38819003918201601f19168301916001600160401b038311848410176100775780849260209460405283398101031261007357516001600160a01b03811690819003610073575f80546001600160a01b031916919091179055604051610321908161008c8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080604081815260049081361015610015575f80fd5b5f92833560e01c90816363c6ccb214610265575063de833bb214610037575f80fd5b3461026157600319906060368301811361025d57833567ffffffffffffffff8082168092036102195760243581811161021d576100779036908801610299565b604493919335838111610259576100919036908a01610299565b979092896100ee73ffffffffffffffffffffffffffffffffffffffff8d5416936100da8b51998a9788968796630b885e5360e01b88528701528c602487015260648601916102cb565b9083820301604484015260c09b8c976102cb565b03915afa91821561024f578792610166575b507fef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897955081511692602082015192808301516080840151928063ffffffff60a0870151169501519581519788526020880152860152840152608083015260a0820152a180f35b90915084953d8611610247575b601f8701601f191682019683881183891017610234578287918101031261021d57858701908782108483111761022157508452805190828216820361021d5760a091875260208101516020880152848101518588015283810151848801526080810151608088015201519463ffffffff86168603610219577fef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad1858979560a0820152905f610100565b8680fd5b8780fd5b634e487b7160e01b895260419052602488fd5b634e487b7160e01b895260418252602489fd5b3d9650610173565b84513d89823e3d90fd5b8980fd5b8480fd5b8280fd5b84903461029557816003193601126102955773ffffffffffffffffffffffffffffffffffffffff60209254168152f35b5080fd5b9181601f840112156102c75782359167ffffffffffffffff83116102c757602083818601950101116102c757565b5f80fd5b908060209392818452848401375f828201840152601f01601f191601019056fea2646970667358221220024e66dce9143896bf635b7816c6784747ebc88a49830508de74760d4ce7a43e64736f6c63430008140033",
}

// SlotValueABI is the input ABI used to generate the binding from.
// Deprecated: Use SlotValueMetaData.ABI instead.
var SlotValueABI = SlotValueMetaData.ABI

// SlotValueBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SlotValueMetaData.Bin instead.
var SlotValueBin = SlotValueMetaData.Bin

// DeploySlotValue deploys a new Ethereum contract, binding an instance of SlotValue to it.
func DeploySlotValue(auth *bind.TransactOpts, backend bind.ContractBackend, _verifier common.Address) (common.Address, *types.Transaction, *SlotValue, error) {
	parsed, err := SlotValueMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SlotValueBin), backend, _verifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SlotValue{SlotValueCaller: SlotValueCaller{contract: contract}, SlotValueTransactor: SlotValueTransactor{contract: contract}, SlotValueFilterer: SlotValueFilterer{contract: contract}}, nil
}

// SlotValue is an auto generated Go binding around an Ethereum contract.
type SlotValue struct {
	SlotValueCaller     // Read-only binding to the contract
	SlotValueTransactor // Write-only binding to the contract
	SlotValueFilterer   // Log filterer for contract events
}

// SlotValueCaller is an auto generated read-only Go binding around an Ethereum contract.
type SlotValueCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SlotValueTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SlotValueFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SlotValueSession struct {
	Contract     *SlotValue        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SlotValueCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SlotValueCallerSession struct {
	Contract *SlotValueCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// SlotValueTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SlotValueTransactorSession struct {
	Contract     *SlotValueTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// SlotValueRaw is an auto generated low-level Go binding around an Ethereum contract.
type SlotValueRaw struct {
	Contract *SlotValue // Generic contract binding to access the raw methods on
}

// SlotValueCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SlotValueCallerRaw struct {
	Contract *SlotValueCaller // Generic read-only contract binding to access the raw methods on
}

// SlotValueTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SlotValueTransactorRaw struct {
	Contract *SlotValueTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSlotValue creates a new instance of SlotValue, bound to a specific deployed contract.
func NewSlotValue(address common.Address, backend bind.ContractBackend) (*SlotValue, error) {
	contract, err := bindSlotValue(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SlotValue{SlotValueCaller: SlotValueCaller{contract: contract}, SlotValueTransactor: SlotValueTransactor{contract: contract}, SlotValueFilterer: SlotValueFilterer{contract: contract}}, nil
}

// NewSlotValueCaller creates a new read-only instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueCaller(address common.Address, caller bind.ContractCaller) (*SlotValueCaller, error) {
	contract, err := bindSlotValue(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueCaller{contract: contract}, nil
}

// NewSlotValueTransactor creates a new write-only instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueTransactor(address common.Address, transactor bind.ContractTransactor) (*SlotValueTransactor, error) {
	contract, err := bindSlotValue(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueTransactor{contract: contract}, nil
}

// NewSlotValueFilterer creates a new log filterer instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueFilterer(address common.Address, filterer bind.ContractFilterer) (*SlotValueFilterer, error) {
	contract, err := bindSlotValue(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SlotValueFilterer{contract: contract}, nil
}

// bindSlotValue binds a generic wrapper to an already deployed contract.
func bindSlotValue(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SlotValueMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValue *SlotValueRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValue.Contract.SlotValueCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValue *SlotValueRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValue.Contract.SlotValueTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValue *SlotValueRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValue.Contract.SlotValueTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValue *SlotValueCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValue.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValue *SlotValueTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValue.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValue *SlotValueTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValue.Contract.contract.Transact(opts, method, params...)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValue.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueSession) SlotValueVerifier() (common.Address, error) {
	return _SlotValue.Contract.SlotValueVerifier(&_SlotValue.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueCallerSession) SlotValueVerifier() (common.Address, error) {
	return _SlotValue.Contract.SlotValueVerifier(&_SlotValue.CallOpts)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueTransactor) SubmitSlotValuePoof(opts *bind.TransactOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.contract.Transact(opts, "submitSlotValuePoof", chainId, proofData, blkVerifyInfo)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueSession) SubmitSlotValuePoof(chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.Contract.SubmitSlotValuePoof(&_SlotValue.TransactOpts, chainId, proofData, blkVerifyInfo)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueTransactorSession) SubmitSlotValuePoof(chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.Contract.SubmitSlotValuePoof(&_SlotValue.TransactOpts, chainId, proofData, blkVerifyInfo)
}

// SlotValueVerifiedSlotValueProofIterator is returned from FilterVerifiedSlotValueProof and is used to iterate over the raw logs and unpacked data for VerifiedSlotValueProof events raised by the SlotValue contract.
type SlotValueVerifiedSlotValueProofIterator struct {
	Event *SlotValueVerifiedSlotValueProof // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifiedSlotValueProofIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifiedSlotValueProof)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifiedSlotValueProof)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifiedSlotValueProofIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifiedSlotValueProofIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifiedSlotValueProof represents a VerifiedSlotValueProof event raised by the SlotValue contract.
type SlotValueVerifiedSlotValueProof struct {
	ChainId     uint64
	AddrHash    [32]byte
	SlotKeyHash [32]byte
	SlotValue   [32]byte
	BlkNum      uint32
	BlkHash     [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVerifiedSlotValueProof is a free log retrieval operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) FilterVerifiedSlotValueProof(opts *bind.FilterOpts) (*SlotValueVerifiedSlotValueProofIterator, error) {

	logs, sub, err := _SlotValue.contract.FilterLogs(opts, "VerifiedSlotValueProof")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifiedSlotValueProofIterator{contract: _SlotValue.contract, event: "VerifiedSlotValueProof", logs: logs, sub: sub}, nil
}

// WatchVerifiedSlotValueProof is a free log subscription operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) WatchVerifiedSlotValueProof(opts *bind.WatchOpts, sink chan<- *SlotValueVerifiedSlotValueProof) (event.Subscription, error) {

	logs, sub, err := _SlotValue.contract.WatchLogs(opts, "VerifiedSlotValueProof")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifiedSlotValueProof)
				if err := _SlotValue.contract.UnpackLog(event, "VerifiedSlotValueProof", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedSlotValueProof is a log parse operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) ParseVerifiedSlotValueProof(log types.Log) (*SlotValueVerifiedSlotValueProof, error) {
	event := new(SlotValueVerifiedSlotValueProof)
	if err := _SlotValue.contract.UnpackLog(event, "VerifiedSlotValueProof", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierMetaData contains all meta data concerning the SlotValueVerifier contract.
var SlotValueVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blocChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BlockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BlockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifySlotValue\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"}],\"internalType\":\"structISlotValueVerifier.SlotInfo\",\"name\":\"slotInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f610af638819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36002541617600255610a3990816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081630215d013146108be575080630b885e53146102da5780631eeb86da1461025e5780638da5cb5b14610239578063ec4ffc5214610197578063f2fde38b146100af5763f5cec6af14610069575f80fd5b346100ab5760203660031901126100ab5767ffffffffffffffff61008b6108e1565b165f52600160205260206001600160a01b0360405f205416604051908152f35b5f80fd5b346100ab5760203660031901126100ab576100c8610926565b5f54906001600160a01b03808316916100e233841461093c565b1691821561012c5773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b346100ab5760403660031901126100ab576101b06108e1565b602435906001600160a01b03918281168091036100ab5767ffffffffffffffff6040926102027ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f5416331461093c565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b346100ab575f3660031901126100ab5760206001600160a01b035f5416604051908152f35b346100ab5760203660031901126100ab577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98602061029a610926565b6001600160a01b03906102b1825f5416331461093c565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a1005b346100ab5760603660031901126100ab576102f36108e1565b60243567ffffffffffffffff81116100ab576103139036906004016108f8565b9160443567ffffffffffffffff81116100ab576103349036906004016108f8565b92906040519461034386610987565b5f86525f60208701525f60408701525f60608701525f60808701525f60a087015267ffffffffffffffff84165f5260016020526001600160a01b0360405f205416156108795767ffffffffffffffff84165f5260016020526001600160a01b0360405f205416602060405180926322bb937360e11b8252826004830152846024830152848760448401375f6044868401015281604481601f19601f89011681010301915afa9081156107dc575f9161085a575b50156100ab576040519360e0850185811067ffffffffffffffff8211176108015760405260e0368637610104860361081557856020116100ab57856024116100ab575f5b60ff6006818316101561050057610458610453836109dd565b6109f2565b906001818416018181116104c15761047361045383926109dd565b1680828416116100ab578981116100ab57918116868101359203602081106104e9575b50600790831610156104d557611fe08260051b1687015260ff8091169081146104c15760010161043a565b634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f1960209190910360031b1b909116906007610496565b50508684868589610104116100ab5760e481013560c08301526040519560a0870187811067ffffffffffffffff8211176108015760405280610160116100ab5780610180116100ab5761017084013560801c61014085013560801b178752806101a0116100ab57806101c0116100ab576101b084013560801c61018085013560801b176020880152806101e0116100ab5780610200116100ab576101f084013560801c6101c085013560801b17604088015280610220116100ab5780610240116100ab5761023084013560801c61020085013560801b176060880152610260116100ab57906020839261025c60a095013560e01c60808901526040519361060685610987565b67ffffffffffffffff8816855261025c81013560e01c8386015261014061017082013560801c91013560801b17604085015280356060850152013560e01c6080830152828201526001600160a01b036002541690604051928391631513dce960e21b835267ffffffffffffffff815116600484015263ffffffff6020820151166024840152604081015160448401526060810151606484015263ffffffff6080820151166084840152015160a482015f905b600782106107e757505050610184816020935afa9081156107dc575f916107ad575b50156107685760a063ffffffff91606060c09567ffffffffffffffff86168352805160408401526020810151602084015284608082015116848401526040810151828401520151608082015267ffffffffffffffff604051941684526020810151602085015260408101516040850152606081015160608501526080810151608085015201511660a0820152f35b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b6107cf915060203d6020116107d5575b6107c781836109a3565b8101906109c5565b846106da565b503d6107bd565b6040513d5f823e3d90fd5b8293506020809160019394518152019301910184926106b8565b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601760248201527f696e636f727265637420626c6b566572696679496e666f0000000000000000006044820152606490fd5b610873915060203d6020116107d5576107c781836109a3565b876103f6565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b346100ab575f3660031901126100ab576020906001600160a01b03600254168152f35b6004359067ffffffffffffffff821682036100ab57565b9181601f840112156100ab5782359167ffffffffffffffff83116100ab57602083818601950101116100ab57565b600435906001600160a01b03821682036100ab57565b1561094357565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b60c0810190811067ffffffffffffffff82111761080157604052565b90601f8019910116810190811067ffffffffffffffff82111761080157604052565b908160209103126100ab575180151581036100ab5790565b60051b90611fe060e08316921682036104c157565b60ff166024019060ff82116104c15756fea26469706673582212208cc7485a6ba1c922b7e9e84999d0c63ce99c4499bb7d3ccf1bcbc8d025095e1764736f6c63430008140033",
}

// SlotValueVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use SlotValueVerifierMetaData.ABI instead.
var SlotValueVerifierABI = SlotValueVerifierMetaData.ABI

// SlotValueVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SlotValueVerifierMetaData.Bin instead.
var SlotValueVerifierBin = SlotValueVerifierMetaData.Bin

// DeploySlotValueVerifier deploys a new Ethereum contract, binding an instance of SlotValueVerifier to it.
func DeploySlotValueVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blocChunks common.Address) (common.Address, *types.Transaction, *SlotValueVerifier, error) {
	parsed, err := SlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SlotValueVerifierBin), backend, _blocChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SlotValueVerifier{SlotValueVerifierCaller: SlotValueVerifierCaller{contract: contract}, SlotValueVerifierTransactor: SlotValueVerifierTransactor{contract: contract}, SlotValueVerifierFilterer: SlotValueVerifierFilterer{contract: contract}}, nil
}

// SlotValueVerifier is an auto generated Go binding around an Ethereum contract.
type SlotValueVerifier struct {
	SlotValueVerifierCaller     // Read-only binding to the contract
	SlotValueVerifierTransactor // Write-only binding to the contract
	SlotValueVerifierFilterer   // Log filterer for contract events
}

// SlotValueVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type SlotValueVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SlotValueVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SlotValueVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SlotValueVerifierSession struct {
	Contract     *SlotValueVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// SlotValueVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SlotValueVerifierCallerSession struct {
	Contract *SlotValueVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// SlotValueVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SlotValueVerifierTransactorSession struct {
	Contract     *SlotValueVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// SlotValueVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type SlotValueVerifierRaw struct {
	Contract *SlotValueVerifier // Generic contract binding to access the raw methods on
}

// SlotValueVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SlotValueVerifierCallerRaw struct {
	Contract *SlotValueVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// SlotValueVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SlotValueVerifierTransactorRaw struct {
	Contract *SlotValueVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSlotValueVerifier creates a new instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifier(address common.Address, backend bind.ContractBackend) (*SlotValueVerifier, error) {
	contract, err := bindSlotValueVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifier{SlotValueVerifierCaller: SlotValueVerifierCaller{contract: contract}, SlotValueVerifierTransactor: SlotValueVerifierTransactor{contract: contract}, SlotValueVerifierFilterer: SlotValueVerifierFilterer{contract: contract}}, nil
}

// NewSlotValueVerifierCaller creates a new read-only instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierCaller(address common.Address, caller bind.ContractCaller) (*SlotValueVerifierCaller, error) {
	contract, err := bindSlotValueVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierCaller{contract: contract}, nil
}

// NewSlotValueVerifierTransactor creates a new write-only instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*SlotValueVerifierTransactor, error) {
	contract, err := bindSlotValueVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierTransactor{contract: contract}, nil
}

// NewSlotValueVerifierFilterer creates a new log filterer instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*SlotValueVerifierFilterer, error) {
	contract, err := bindSlotValueVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierFilterer{contract: contract}, nil
}

// bindSlotValueVerifier binds a generic wrapper to an already deployed contract.
func bindSlotValueVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValueVerifier *SlotValueVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValueVerifier.Contract.SlotValueVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValueVerifier *SlotValueVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.SlotValueVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValueVerifier *SlotValueVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.SlotValueVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValueVerifier *SlotValueVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValueVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValueVerifier *SlotValueVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValueVerifier *SlotValueVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "BlockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) BlockChunks() (common.Address, error) {
	return _SlotValueVerifier.Contract.BlockChunks(&_SlotValueVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _SlotValueVerifier.Contract.BlockChunks(&_SlotValueVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) Owner() (common.Address, error) {
	return _SlotValueVerifier.Contract.Owner(&_SlotValueVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) Owner() (common.Address, error) {
	return _SlotValueVerifier.Contract.Owner(&_SlotValueVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _SlotValueVerifier.Contract.VerifierAddresses(&_SlotValueVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _SlotValueVerifier.Contract.VerifierAddresses(&_SlotValueVerifier.CallOpts, arg0)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierCaller) VerifySlotValue(opts *bind.CallOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "verifySlotValue", chainId, proofData, blkVerifyInfo)

	if err != nil {
		return *new(ISlotValueVerifierSlotInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ISlotValueVerifierSlotInfo)).(*ISlotValueVerifierSlotInfo)

	return out0, err

}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _SlotValueVerifier.Contract.VerifySlotValue(&_SlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _SlotValueVerifier.Contract.VerifySlotValue(&_SlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.TransferOwnership(&_SlotValueVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.TransferOwnership(&_SlotValueVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "updateBlockChunks", _BlockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) UpdateBlockChunks(_BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateBlockChunks(&_SlotValueVerifier.TransactOpts, _BlockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) UpdateBlockChunks(_BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateBlockChunks(&_SlotValueVerifier.TransactOpts, _BlockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateVerifierAddress(&_SlotValueVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateVerifierAddress(&_SlotValueVerifier.TransactOpts, _chainId, _verifierAddress)
}

// SlotValueVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SlotValueVerifier contract.
type SlotValueVerifierOwnershipTransferredIterator struct {
	Event *SlotValueVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the SlotValueVerifier contract.
type SlotValueVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SlotValueVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierOwnershipTransferredIterator{contract: _SlotValueVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierOwnershipTransferred)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*SlotValueVerifierOwnershipTransferred, error) {
	event := new(SlotValueVerifierOwnershipTransferred)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateBlockChunksIterator struct {
	Event *SlotValueVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*SlotValueVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierUpdateBlockChunksIterator{contract: _SlotValueVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierUpdateBlockChunks)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*SlotValueVerifierUpdateBlockChunks, error) {
	event := new(SlotValueVerifierUpdateBlockChunks)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateVerifierAddressIterator struct {
	Event *SlotValueVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*SlotValueVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierUpdateVerifierAddressIterator{contract: _SlotValueVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierUpdateVerifierAddress)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*SlotValueVerifierUpdateVerifierAddress, error) {
	event := new(SlotValueVerifierUpdateVerifierAddress)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SqrtPriceMathMetaData contains all meta data concerning the SqrtPriceMath contract.
var SqrtPriceMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212205959e7cdbf4caea353261654724f6336174cb8bdfcfb6d34bd658287549b098d64736f6c63430008140033",
}

// SqrtPriceMathABI is the input ABI used to generate the binding from.
// Deprecated: Use SqrtPriceMathMetaData.ABI instead.
var SqrtPriceMathABI = SqrtPriceMathMetaData.ABI

// SqrtPriceMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SqrtPriceMathMetaData.Bin instead.
var SqrtPriceMathBin = SqrtPriceMathMetaData.Bin

// DeploySqrtPriceMath deploys a new Ethereum contract, binding an instance of SqrtPriceMath to it.
func DeploySqrtPriceMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SqrtPriceMath, error) {
	parsed, err := SqrtPriceMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SqrtPriceMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SqrtPriceMath{SqrtPriceMathCaller: SqrtPriceMathCaller{contract: contract}, SqrtPriceMathTransactor: SqrtPriceMathTransactor{contract: contract}, SqrtPriceMathFilterer: SqrtPriceMathFilterer{contract: contract}}, nil
}

// SqrtPriceMath is an auto generated Go binding around an Ethereum contract.
type SqrtPriceMath struct {
	SqrtPriceMathCaller     // Read-only binding to the contract
	SqrtPriceMathTransactor // Write-only binding to the contract
	SqrtPriceMathFilterer   // Log filterer for contract events
}

// SqrtPriceMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SqrtPriceMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SqrtPriceMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SqrtPriceMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SqrtPriceMathSession struct {
	Contract     *SqrtPriceMath    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SqrtPriceMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SqrtPriceMathCallerSession struct {
	Contract *SqrtPriceMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// SqrtPriceMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SqrtPriceMathTransactorSession struct {
	Contract     *SqrtPriceMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// SqrtPriceMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SqrtPriceMathRaw struct {
	Contract *SqrtPriceMath // Generic contract binding to access the raw methods on
}

// SqrtPriceMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SqrtPriceMathCallerRaw struct {
	Contract *SqrtPriceMathCaller // Generic read-only contract binding to access the raw methods on
}

// SqrtPriceMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SqrtPriceMathTransactorRaw struct {
	Contract *SqrtPriceMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSqrtPriceMath creates a new instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMath(address common.Address, backend bind.ContractBackend) (*SqrtPriceMath, error) {
	contract, err := bindSqrtPriceMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMath{SqrtPriceMathCaller: SqrtPriceMathCaller{contract: contract}, SqrtPriceMathTransactor: SqrtPriceMathTransactor{contract: contract}, SqrtPriceMathFilterer: SqrtPriceMathFilterer{contract: contract}}, nil
}

// NewSqrtPriceMathCaller creates a new read-only instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathCaller(address common.Address, caller bind.ContractCaller) (*SqrtPriceMathCaller, error) {
	contract, err := bindSqrtPriceMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathCaller{contract: contract}, nil
}

// NewSqrtPriceMathTransactor creates a new write-only instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SqrtPriceMathTransactor, error) {
	contract, err := bindSqrtPriceMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathTransactor{contract: contract}, nil
}

// NewSqrtPriceMathFilterer creates a new log filterer instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SqrtPriceMathFilterer, error) {
	contract, err := bindSqrtPriceMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathFilterer{contract: contract}, nil
}

// bindSqrtPriceMath binds a generic wrapper to an already deployed contract.
func bindSqrtPriceMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SqrtPriceMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SqrtPriceMath *SqrtPriceMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SqrtPriceMath.Contract.SqrtPriceMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SqrtPriceMath *SqrtPriceMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.SqrtPriceMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SqrtPriceMath *SqrtPriceMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.SqrtPriceMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SqrtPriceMath *SqrtPriceMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SqrtPriceMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SqrtPriceMath *SqrtPriceMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SqrtPriceMath *SqrtPriceMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.contract.Transact(opts, method, params...)
}

// StringsMetaData contains all meta data concerning the Strings contract.
var StringsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122019fc3cc1e39006ddd1cceed6f4ddeca31842e419d9501858154147cc7095c4b764736f6c63430008140033",
}

// StringsABI is the input ABI used to generate the binding from.
// Deprecated: Use StringsMetaData.ABI instead.
var StringsABI = StringsMetaData.ABI

// StringsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StringsMetaData.Bin instead.
var StringsBin = StringsMetaData.Bin

// DeployStrings deploys a new Ethereum contract, binding an instance of Strings to it.
func DeployStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Strings, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// Strings is an auto generated Go binding around an Ethereum contract.
type Strings struct {
	StringsCaller     // Read-only binding to the contract
	StringsTransactor // Write-only binding to the contract
	StringsFilterer   // Log filterer for contract events
}

// StringsCaller is an auto generated read-only Go binding around an Ethereum contract.
type StringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StringsSession struct {
	Contract     *Strings          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StringsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StringsCallerSession struct {
	Contract *StringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StringsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StringsTransactorSession struct {
	Contract     *StringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StringsRaw is an auto generated low-level Go binding around an Ethereum contract.
type StringsRaw struct {
	Contract *Strings // Generic contract binding to access the raw methods on
}

// StringsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StringsCallerRaw struct {
	Contract *StringsCaller // Generic read-only contract binding to access the raw methods on
}

// StringsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StringsTransactorRaw struct {
	Contract *StringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStrings creates a new instance of Strings, bound to a specific deployed contract.
func NewStrings(address common.Address, backend bind.ContractBackend) (*Strings, error) {
	contract, err := bindStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// NewStringsCaller creates a new read-only instance of Strings, bound to a specific deployed contract.
func NewStringsCaller(address common.Address, caller bind.ContractCaller) (*StringsCaller, error) {
	contract, err := bindStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StringsCaller{contract: contract}, nil
}

// NewStringsTransactor creates a new write-only instance of Strings, bound to a specific deployed contract.
func NewStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*StringsTransactor, error) {
	contract, err := bindStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StringsTransactor{contract: contract}, nil
}

// NewStringsFilterer creates a new log filterer instance of Strings, bound to a specific deployed contract.
func NewStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*StringsFilterer, error) {
	contract, err := bindStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StringsFilterer{contract: contract}, nil
}

// bindStrings binds a generic wrapper to an already deployed contract.
func bindStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.StringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transact(opts, method, params...)
}

// SwapMathMetaData contains all meta data concerning the SwapMath contract.
var SwapMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220db6fc69538043d203f78224bf51355e754e11b04715eeeaabe29c93b3c8df61064736f6c63430008140033",
}

// SwapMathABI is the input ABI used to generate the binding from.
// Deprecated: Use SwapMathMetaData.ABI instead.
var SwapMathABI = SwapMathMetaData.ABI

// SwapMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SwapMathMetaData.Bin instead.
var SwapMathBin = SwapMathMetaData.Bin

// DeploySwapMath deploys a new Ethereum contract, binding an instance of SwapMath to it.
func DeploySwapMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SwapMath, error) {
	parsed, err := SwapMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SwapMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SwapMath{SwapMathCaller: SwapMathCaller{contract: contract}, SwapMathTransactor: SwapMathTransactor{contract: contract}, SwapMathFilterer: SwapMathFilterer{contract: contract}}, nil
}

// SwapMath is an auto generated Go binding around an Ethereum contract.
type SwapMath struct {
	SwapMathCaller     // Read-only binding to the contract
	SwapMathTransactor // Write-only binding to the contract
	SwapMathFilterer   // Log filterer for contract events
}

// SwapMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SwapMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SwapMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SwapMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SwapMathSession struct {
	Contract     *SwapMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SwapMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SwapMathCallerSession struct {
	Contract *SwapMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SwapMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SwapMathTransactorSession struct {
	Contract     *SwapMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SwapMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SwapMathRaw struct {
	Contract *SwapMath // Generic contract binding to access the raw methods on
}

// SwapMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SwapMathCallerRaw struct {
	Contract *SwapMathCaller // Generic read-only contract binding to access the raw methods on
}

// SwapMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SwapMathTransactorRaw struct {
	Contract *SwapMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSwapMath creates a new instance of SwapMath, bound to a specific deployed contract.
func NewSwapMath(address common.Address, backend bind.ContractBackend) (*SwapMath, error) {
	contract, err := bindSwapMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SwapMath{SwapMathCaller: SwapMathCaller{contract: contract}, SwapMathTransactor: SwapMathTransactor{contract: contract}, SwapMathFilterer: SwapMathFilterer{contract: contract}}, nil
}

// NewSwapMathCaller creates a new read-only instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathCaller(address common.Address, caller bind.ContractCaller) (*SwapMathCaller, error) {
	contract, err := bindSwapMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SwapMathCaller{contract: contract}, nil
}

// NewSwapMathTransactor creates a new write-only instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SwapMathTransactor, error) {
	contract, err := bindSwapMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SwapMathTransactor{contract: contract}, nil
}

// NewSwapMathFilterer creates a new log filterer instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SwapMathFilterer, error) {
	contract, err := bindSwapMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SwapMathFilterer{contract: contract}, nil
}

// bindSwapMath binds a generic wrapper to an already deployed contract.
func bindSwapMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SwapMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SwapMath *SwapMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SwapMath.Contract.SwapMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SwapMath *SwapMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SwapMath.Contract.SwapMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SwapMath *SwapMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SwapMath.Contract.SwapMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SwapMath *SwapMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SwapMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SwapMath *SwapMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SwapMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SwapMath *SwapMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SwapMath.Contract.contract.Transact(opts, method, params...)
}

// TestSMTMetaData contains all meta data concerning the TestSMT contract.
var TestSMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_anchorProviders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_initRoots\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"AnchorProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"}],\"name\":\"SmtRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"}],\"name\":\"addRootForTesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorProviders\",\"outputs\":[{\"internalType\":\"contractIAnchorBlocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLatestRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"latestRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"setAnchorProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"smtRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"commitPub\",\"type\":\"bytes32\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"contractIVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060808152346200039b5762001ee690813803806200001f81620003b9565b93843982016080838203126200039b5782516001600160401b0391908281116200039b5784019381601f860112156200039b578451916200006a6200006484620003f3565b620003b9565b908196848352602080930183600596871b830101918383116200039b578401905b8282106200039f57505050818301518581116200039b5781620000b09185016200040b565b96868401518681116200039b5782620000cb9186016200040b565b936060810151908782116200039b57019180601f840112156200039b578251620000f96200006482620003f3565b938580868481520192891b8201019283116200039b5785809101915b8383106200038a5750505f80548a519891976001600160a01b0394509250338482167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08a80a36001600160a81b0319163360ff60a01b198116919091178855875260018087528a88205490989060ff166200034857506002549a680100000000000000008c10156200033457888c01806002558c101562000320578a99899c957f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8898c9860028d52818d20019d60018060a01b03199e8f3390825416179055338d52898252808d2060ff199a8b82541617905551338152a16200021c815184511462000479565b6200022b815186511462000479565b6200023a815189511462000479565b899d5b62000252575b8c51611a079081620004df8239f35b8d815111156200031a578d808e8e8c828f8c8c878d838e8e620002778f8690620004b5565b51169c6200028591620004b5565b5116908b865287528585209088825416179055620002a391620004b5565b51169287825260069052209182541617905560078c52818d8c83822092620002cb91620004b5565b5190528c528c208d8a825416179055620002e6908a620004b5565b51908b5260088a528d8b20555f198e1462000306579c8a019c8a6200023d565b634e487b7160e01b8a52601160045260248afd5b62000243565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b62461bcd60e51b815260048101879052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b825181529181019186910162000115565b5f80fd5b815188811681036200039b5781529084019084016200008b565b6040519190601f01601f191682016001600160401b03811183821017620003df57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111620003df5760051b60200190565b9080601f830112156200039b578151906200042a6200006483620003f3565b9182938184526020808095019260051b8201019283116200039b578301905b82821062000458575050505090565b81516001600160a01b03811681036200039b57815290830190830162000449565b156200048157565b60405162461bcd60e51b815260206004820152600c60248201526b0d8cadc40dad2e6dac2e8c6d60a31b6044820152606490fd5b8051821015620004ca5760209160051b010190565b634e487b7160e01b5f52603260045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081631019b6161461127a57508063158535ff14611249578063318a492d14610bb35780633870253214610b695780633f4ba83a14610a6957806346fbf68e14610742578063479aa6da146107ce5780634f4fef1814610a4c57806358a16b4414610a2f5780635c975abb14610a0b5780635ca32bd81461094e578063677625f2146108075780636ae3e080146107ce5780636b2c0f55146107985780636ef8d66d1461077f57806380f51c12146107425780638195408d1461070057806382dc1ec4146106ca5780638456cb59146105b35780638da5cb5b1461058e5780639c8413c5146104d1578063a036e79914610483578063afe8154b14610441578063e31476da14610383578063e6c6fcec14610335578063e79b7a51146102e0578063f2fde38b146101f8578063fabc74f5146101a05763fd1190ea1461015b575f80fd5b3461019c57602036600319011261019c5760043560045481101561019c576001600160a01b0361018c602092611336565b9190546040519260031b1c168152f35b5f80fd5b3461019c57602036600319011261019c576001600160a01b036101c16113a9565b165f52600360205260ff60405f20541660405160038210156101e4576020918152f35b634e487b7160e01b5f52602160045260245ffd5b3461019c57602036600319011261019c576102116113a9565b5f54906001600160a01b038083169161022b33841461148d565b169182156102755773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461019c576102ee366113d5565b6001600160a01b0390610305825f5416331461148d565b5f5b815181101561033357806103298461032261032e94866114fa565b5116611730565b6114d8565b610307565b005b3461019c57610343366113d5565b6001600160a01b039061035a825f5416331461148d565b5f5b815181101561033357806103298461037761037e94866114fa565b511661155a565b61035c565b3461019c57606036600319011261019c577f05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a76103bd6112bf565b60243567ffffffffffffffff6103d16112d6565b926103e76001600160a01b035f5416331461148d565b16805f52600760205260405f20825f5260205260405f20600160ff198254161790555f5260086020528060405f205561043c6040519283928390929167ffffffffffffffff6020916040840195845216910152565b0390a1005b3461019c57602036600319011261019c5767ffffffffffffffff6104636112bf565b165f52600560205260206001600160a01b0360405f205416604051908152f35b3461019c57610491366113d5565b6001600160a01b03906104a8825f5416331461148d565b5f5b81518110156103335780610329846104c56104cc94866114fa565b5116611815565b6104aa565b3461019c57604036600319011261019c577fb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be816261050b6112bf565b6105136113bf565b906001600160a01b0361052a815f5416331461148d565b67ffffffffffffffff82165f52600660205260405f2090831673ffffffffffffffffffffffffffffffffffffffff1982541617905561043c604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b3461019c575f36600319011261019c5760206001600160a01b035f5416604051908152f35b3461019c575f36600319011261019c57335f5260016020908082526105de60ff60405f20541661150e565b5f5460ff8160a01c166106855760ff60a01b19740100000000000000000000000000000000000000009116175f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a15f815b61063e57005b60045481101561033357806001600160a01b0361065d61067f93611336565b919054600392831b1c165f52845260405f20600260ff198254161790556114d8565b81610638565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b3461019c57602036600319011261019c576103336106e66113a9565b6106fb6001600160a01b035f5416331461148d565b611730565b3461019c57602036600319011261019c5767ffffffffffffffff6107226112bf565b165f52600660205260206001600160a01b0360405f205416604051908152f35b3461019c57602036600319011261019c576001600160a01b036107636113a9565b165f526001602052602060ff60405f2054166040519015158152f35b3461019c575f36600319011261019c5761033333611815565b3461019c57602036600319011261019c576103336107b46113a9565b6107c96001600160a01b035f5416331461148d565b611815565b3461019c57602036600319011261019c5767ffffffffffffffff6107f06112bf565b165f526008602052602060405f2054604051908152f35b3461019c57610815366113d5565b6001600160a01b0361082b815f5416331461148d565b5f5b8251811015610333578161084182856114fa565b511690815f526003602081815260ff60405f205416828110156101e45761090a5760045493680100000000000000008510156108f6576108f1947fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684936108d2836108b2600194858101600455611336565b90919082549060031b916001600160a01b03809116831b921b1916179055565b825f52835260405f209060ff19825416179055604051908152a16114d8565b61082d565b634e487b7160e01b5f52604160045260245ffd5b6064906040519062461bcd60e51b82526004820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b3461019c57604036600319011261019c577fd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c80906109886112bf565b6109906113bf565b906001600160a01b036109a7815f5416331461148d565b67ffffffffffffffff82165f52600560205260405f2090831673ffffffffffffffffffffffffffffffffffffffff1982541617905561043c604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b3461019c575f36600319011261019c57602060ff5f5460a01c166040519015158152f35b3461019c575f36600319011261019c576020600254604051908152f35b3461019c575f36600319011261019c576020600454604051908152f35b3461019c575f36600319011261019c57335f526001602090808252610a9460ff60405f20541661150e565b5f5460ff8160a01c1615610b245760ff60a01b19165f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a15f815b610add57005b60045481101561033357610b1e816001600160a01b03610afd8594611336565b919054600392831b1c165f52855260405f208360ff198254161790556114d8565b90610ad7565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b3461019c57604036600319011261019c5767ffffffffffffffff610b8b6112bf565b165f52600760205260405f206024355f52602052602060ff60405f2054166040519015158152f35b3461019c5761020036600319011261019c57610bcd6112bf565b6101e036602319011261019c5760405160c0810181811067ffffffffffffffff8211176108f6576040526024358152610c046112d6565b6020820152606435604082015260843560608201526101403660a319011261019c576040516080810181811067ffffffffffffffff8211176108f657806040523660c3121561019c57610c568161136b565b8060e49136831161019c5760a4905b838210611239575050825236610103121561019c5760405190610c878261136b565b8190366101641161019c57905b61016482106111e7575050602082015236610183121561019c5760405190610cbb8261136b565b816101a49236841161019c57610164905b8482106111d75750506040820152366101c3121561019c57604051610cf08161136b565b806101e49336851161019c57905b8482106111c7575050606082015260808301523560a0820152335f52600360205260ff60405f20541660038110156101e4576001036111825760608101511561105d575b67ffffffffffffffff82165f52600860205260405f205460066020526001600160a01b0360405f205416801561101857604051918261014081011067ffffffffffffffff610140850111176108f657610140839293016040526101403683378060801c82526fffffffffffffffffffffffffffffffff8091166020830152835160801c6040830152808451166060830152604084015160801c60808301528060408501511660a083015267ffffffffffffffff60208501511660c0830152606084015160801c60e083015260608401511661010082015260a083015161012082015260808301519283516020850151936060604087015196015193610e58604051936313a4214360e31b85526004850190611466565b5f9594604484015b6002881015610ea35786515f90825b60028310610e8d575050506020604060019201970197019695610e60565b6020806001928451815201920192019190610e6f565b5088955090610ec68492610ebb8a60c4860190611466565b610104840190611466565b5f61014483015b600a8210610ffe57505050610284816020935afa908115610ff3575f91610fb8575b5015610f735767ffffffffffffffff9182165f818152600760209081526040808320855184528252808320805460ff1916600117905584519383526008825291829020929092558251928201518151938452909316908201527f05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7918190810161043c565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207a6b2070726f6f66000000000000000000000000000000006044820152606490fd5b90506020813d602011610feb575b81610fd360209383611387565b8101031261019c5751801515810361019c5783610eef565b3d9150610fc6565b6040513d5f823e3d90fd5b829350602080916001939451815201930191018492610ecd565b60405162461bcd60e51b815260206004820152601760248201527f6e6f20766572696669657220666f7220636861696e49640000000000000000006044820152606490fd5b67ffffffffffffffff82165f5260056020526001600160a01b0360405f205416801561113d57602067ffffffffffffffff818401511660246040518094819363f25b3f9960e01b835260048301525afa908115610ff3575f9161110b575b50604082015114610d425760405162461bcd60e51b815260206004820152601360248201527f616e63686f7220636865636b206661696c6564000000000000000000000000006044820152606490fd5b90506020813d602011611135575b8161112660209383611387565b8101031261019c5751836110bb565b3d9150611119565b60405162461bcd60e51b815260206004820152601760248201527f756e6b6e6f776e20616e63686f722070726f76696465720000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b8135815260209182019101610cfe565b8135815260209182019101610ccc565b36601f8301121561019c576040516111fe8161136b565b8036604085011161019c5783905b604085018210611229575050816020916040935201910190610c94565b813581526020918201910161120c565b8135815260209182019101610c65565b3461019c57602036600319011261019c5760043560025481101561019c576001600160a01b0361018c6020926112ed565b3461019c57604036600319011261019c5760209067ffffffffffffffff61129f6112bf565b165f526007825260405f206024355f52825260ff60405f20541615158152f35b6004359067ffffffffffffffff8216820361019c57565b6044359067ffffffffffffffff8216820361019c57565b6002548110156113225760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156113225760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6040810190811067ffffffffffffffff8211176108f657604052565b90601f8019910116810190811067ffffffffffffffff8211176108f657604052565b600435906001600160a01b038216820361019c57565b602435906001600160a01b038216820361019c57565b60208060031983011261019c5767ffffffffffffffff9160043583811161019c578160238201121561019c5780600401359384116108f6578360051b906040519461142285840187611387565b855260248486019282010192831161019c57602401905b828210611447575050505090565b81356001600160a01b038116810361019c578152908301908301611439565b5f915b6002831061147657505050565b600190825181526020809101920192019190611469565b1561149457565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f1981146114e65760010190565b634e487b7160e01b5f52601160045260245ffd5b80518210156113225760209160051b010190565b1561151557565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff82822054168781101561171c57156116d8576004968754965f19908189019889116116c557835b8a548110156116825786826115b383611336565b905490871b1c16146115cd576115c8906114d8565b61159f565b90919293949596979880821061165d575b5050508754801561164a5797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859899019061163461161f83611336565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b61167a9261166d6108b292611336565b905490871b1c1691611336565b5f80806115de565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff6040832054166117d057600254680100000000000000008110156117bc576020926117a07f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936108b2846001604096016002556112ed565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff85882054161561198d576002805490915f199182810190811161197957908695949392918a975b6118a4575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a10156119705781856118bc8c6112ed565b929054600393841b1c16146118e557506118dc8798999a979596976114d8565b9796959461185b565b929394979695999181831061194b575b505050508154801561193757918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e989993019061163461161f836112ed565b634e487b7160e01b89526031600452602489fd5b6119679361195b6108b2936112ed565b9054911b1c16916112ed565b5f8080806118f5565b87989950611860565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220a8ff9be43f73499fc54131702beabfef3eff921eccd1a352884aaf8c4e26d17764736f6c63430008140033",
}

// TestSMTABI is the input ABI used to generate the binding from.
// Deprecated: Use TestSMTMetaData.ABI instead.
var TestSMTABI = TestSMTMetaData.ABI

// TestSMTBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TestSMTMetaData.Bin instead.
var TestSMTBin = TestSMTMetaData.Bin

// DeployTestSMT deploys a new Ethereum contract, binding an instance of TestSMT to it.
func DeployTestSMT(auth *bind.TransactOpts, backend bind.ContractBackend, _chainIds []uint64, _anchorProviders []common.Address, _verifiers []common.Address, _initRoots [][32]byte) (common.Address, *types.Transaction, *TestSMT, error) {
	parsed, err := TestSMTMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TestSMTBin), backend, _chainIds, _anchorProviders, _verifiers, _initRoots)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TestSMT{TestSMTCaller: TestSMTCaller{contract: contract}, TestSMTTransactor: TestSMTTransactor{contract: contract}, TestSMTFilterer: TestSMTFilterer{contract: contract}}, nil
}

// TestSMT is an auto generated Go binding around an Ethereum contract.
type TestSMT struct {
	TestSMTCaller     // Read-only binding to the contract
	TestSMTTransactor // Write-only binding to the contract
	TestSMTFilterer   // Log filterer for contract events
}

// TestSMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type TestSMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TestSMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TestSMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TestSMTSession struct {
	Contract     *TestSMT          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TestSMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TestSMTCallerSession struct {
	Contract *TestSMTCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// TestSMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TestSMTTransactorSession struct {
	Contract     *TestSMTTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// TestSMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type TestSMTRaw struct {
	Contract *TestSMT // Generic contract binding to access the raw methods on
}

// TestSMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TestSMTCallerRaw struct {
	Contract *TestSMTCaller // Generic read-only contract binding to access the raw methods on
}

// TestSMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TestSMTTransactorRaw struct {
	Contract *TestSMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTestSMT creates a new instance of TestSMT, bound to a specific deployed contract.
func NewTestSMT(address common.Address, backend bind.ContractBackend) (*TestSMT, error) {
	contract, err := bindTestSMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TestSMT{TestSMTCaller: TestSMTCaller{contract: contract}, TestSMTTransactor: TestSMTTransactor{contract: contract}, TestSMTFilterer: TestSMTFilterer{contract: contract}}, nil
}

// NewTestSMTCaller creates a new read-only instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTCaller(address common.Address, caller bind.ContractCaller) (*TestSMTCaller, error) {
	contract, err := bindTestSMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TestSMTCaller{contract: contract}, nil
}

// NewTestSMTTransactor creates a new write-only instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTTransactor(address common.Address, transactor bind.ContractTransactor) (*TestSMTTransactor, error) {
	contract, err := bindTestSMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TestSMTTransactor{contract: contract}, nil
}

// NewTestSMTFilterer creates a new log filterer instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTFilterer(address common.Address, filterer bind.ContractFilterer) (*TestSMTFilterer, error) {
	contract, err := bindTestSMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TestSMTFilterer{contract: contract}, nil
}

// bindTestSMT binds a generic wrapper to an already deployed contract.
func bindTestSMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TestSMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TestSMT *TestSMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TestSMT.Contract.TestSMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TestSMT *TestSMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.Contract.TestSMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TestSMT *TestSMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TestSMT.Contract.TestSMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TestSMT *TestSMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TestSMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TestSMT *TestSMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TestSMT *TestSMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TestSMT.Contract.contract.Transact(opts, method, params...)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTCaller) AnchorProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "anchorProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.AnchorProviders(&_TestSMT.CallOpts, arg0)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.AnchorProviders(&_TestSMT.CallOpts, arg0)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTCaller) GetLatestRoot(opts *bind.CallOpts, chainId uint64) ([32]byte, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "getLatestRoot", chainId)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _TestSMT.Contract.GetLatestRoot(&_TestSMT.CallOpts, chainId)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTCallerSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _TestSMT.Contract.GetLatestRoot(&_TestSMT.CallOpts, chainId)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTSession) IsPauser(account common.Address) (bool, error) {
	return _TestSMT.Contract.IsPauser(&_TestSMT.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTCallerSession) IsPauser(account common.Address) (bool, error) {
	return _TestSMT.Contract.IsPauser(&_TestSMT.CallOpts, account)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _TestSMT.Contract.IsSmtRootValid(&_TestSMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _TestSMT.Contract.IsSmtRootValid(&_TestSMT.CallOpts, chainId, smtRoot)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTCaller) LatestRoots(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "latestRoots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _TestSMT.Contract.LatestRoots(&_TestSMT.CallOpts, arg0)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTCallerSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _TestSMT.Contract.LatestRoots(&_TestSMT.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTSession) NumPausers() (*big.Int, error) {
	return _TestSMT.Contract.NumPausers(&_TestSMT.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTCallerSession) NumPausers() (*big.Int, error) {
	return _TestSMT.Contract.NumPausers(&_TestSMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTSession) NumProvers() (*big.Int, error) {
	return _TestSMT.Contract.NumProvers(&_TestSMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTCallerSession) NumProvers() (*big.Int, error) {
	return _TestSMT.Contract.NumProvers(&_TestSMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTSession) Owner() (common.Address, error) {
	return _TestSMT.Contract.Owner(&_TestSMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTCallerSession) Owner() (common.Address, error) {
	return _TestSMT.Contract.Owner(&_TestSMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTSession) Paused() (bool, error) {
	return _TestSMT.Contract.Paused(&_TestSMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTCallerSession) Paused() (bool, error) {
	return _TestSMT.Contract.Paused(&_TestSMT.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.PauserList(&_TestSMT.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.PauserList(&_TestSMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTSession) Pausers(arg0 common.Address) (bool, error) {
	return _TestSMT.Contract.Pausers(&_TestSMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _TestSMT.Contract.Pausers(&_TestSMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _TestSMT.Contract.ProverStates(&_TestSMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _TestSMT.Contract.ProverStates(&_TestSMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.Provers(&_TestSMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.Provers(&_TestSMT.CallOpts, arg0)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTCaller) SmtRoots(opts *bind.CallOpts, arg0 uint64, arg1 [32]byte) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "smtRoots", arg0, arg1)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _TestSMT.Contract.SmtRoots(&_TestSMT.CallOpts, arg0, arg1)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTCallerSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _TestSMT.Contract.SmtRoots(&_TestSMT.CallOpts, arg0, arg1)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTCaller) Verifiers(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "verifiers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.Verifiers(&_TestSMT.CallOpts, arg0)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.Verifiers(&_TestSMT.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPauser(&_TestSMT.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPauser(&_TestSMT.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPausers(&_TestSMT.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPausers(&_TestSMT.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddProvers(&_TestSMT.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddProvers(&_TestSMT.TransactOpts, _accounts)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTTransactor) AddRootForTesting(opts *bind.TransactOpts, chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addRootForTesting", chainId, newRoot, endBlockNum)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTSession) AddRootForTesting(chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.Contract.AddRootForTesting(&_TestSMT.TransactOpts, chainId, newRoot, endBlockNum)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTTransactorSession) AddRootForTesting(chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.Contract.AddRootForTesting(&_TestSMT.TransactOpts, chainId, newRoot, endBlockNum)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTSession) Pause() (*types.Transaction, error) {
	return _TestSMT.Contract.Pause(&_TestSMT.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTTransactorSession) Pause() (*types.Transaction, error) {
	return _TestSMT.Contract.Pause(&_TestSMT.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePauser(&_TestSMT.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePauser(&_TestSMT.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePausers(&_TestSMT.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePausers(&_TestSMT.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemoveProvers(&_TestSMT.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemoveProvers(&_TestSMT.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTSession) RenouncePauser() (*types.Transaction, error) {
	return _TestSMT.Contract.RenouncePauser(&_TestSMT.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _TestSMT.Contract.RenouncePauser(&_TestSMT.TransactOpts)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTTransactor) SetAnchorProvider(opts *bind.TransactOpts, chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "setAnchorProvider", chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetAnchorProvider(&_TestSMT.TransactOpts, chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTTransactorSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetAnchorProvider(&_TestSMT.TransactOpts, chainId, anchorProvider)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTTransactor) SetVerifier(opts *bind.TransactOpts, chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "setVerifier", chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetVerifier(&_TestSMT.TransactOpts, chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTTransactorSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetVerifier(&_TestSMT.TransactOpts, chainId, verifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.TransferOwnership(&_TestSMT.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.TransferOwnership(&_TestSMT.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTSession) Unpause() (*types.Transaction, error) {
	return _TestSMT.Contract.Unpause(&_TestSMT.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTTransactorSession) Unpause() (*types.Transaction, error) {
	return _TestSMT.Contract.Unpause(&_TestSMT.TransactOpts)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_TestSMT *TestSMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_TestSMT *TestSMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.Contract.UpdateRoot(&_TestSMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x318a492d.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),bytes32) u) returns()
func (_TestSMT *TestSMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.Contract.UpdateRoot(&_TestSMT.TransactOpts, chainId, u)
}

// TestSMTAnchorProviderUpdatedIterator is returned from FilterAnchorProviderUpdated and is used to iterate over the raw logs and unpacked data for AnchorProviderUpdated events raised by the TestSMT contract.
type TestSMTAnchorProviderUpdatedIterator struct {
	Event *TestSMTAnchorProviderUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTAnchorProviderUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTAnchorProviderUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTAnchorProviderUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTAnchorProviderUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTAnchorProviderUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTAnchorProviderUpdated represents a AnchorProviderUpdated event raised by the TestSMT contract.
type TestSMTAnchorProviderUpdated struct {
	ChainId        uint64
	AnchorProvider common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterAnchorProviderUpdated is a free log retrieval operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) FilterAnchorProviderUpdated(opts *bind.FilterOpts) (*TestSMTAnchorProviderUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTAnchorProviderUpdatedIterator{contract: _TestSMT.contract, event: "AnchorProviderUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorProviderUpdated is a free log subscription operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) WatchAnchorProviderUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTAnchorProviderUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTAnchorProviderUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorProviderUpdated is a log parse operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) ParseAnchorProviderUpdated(log types.Log) (*TestSMTAnchorProviderUpdated, error) {
	event := new(TestSMTAnchorProviderUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TestSMT contract.
type TestSMTOwnershipTransferredIterator struct {
	Event *TestSMTOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTOwnershipTransferred represents a OwnershipTransferred event raised by the TestSMT contract.
type TestSMTOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TestSMTOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TestSMTOwnershipTransferredIterator{contract: _TestSMT.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TestSMTOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTOwnershipTransferred)
				if err := _TestSMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) ParseOwnershipTransferred(log types.Log) (*TestSMTOwnershipTransferred, error) {
	event := new(TestSMTOwnershipTransferred)
	if err := _TestSMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the TestSMT contract.
type TestSMTPausedIterator struct {
	Event *TestSMTPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPaused represents a Paused event raised by the TestSMT contract.
type TestSMTPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) FilterPaused(opts *bind.FilterOpts) (*TestSMTPausedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &TestSMTPausedIterator{contract: _TestSMT.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *TestSMTPaused) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPaused)
				if err := _TestSMT.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) ParsePaused(log types.Log) (*TestSMTPaused, error) {
	event := new(TestSMTPaused)
	if err := _TestSMT.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the TestSMT contract.
type TestSMTPauserAddedIterator struct {
	Event *TestSMTPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPauserAdded represents a PauserAdded event raised by the TestSMT contract.
type TestSMTPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*TestSMTPauserAddedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &TestSMTPauserAddedIterator{contract: _TestSMT.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *TestSMTPauserAdded) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPauserAdded)
				if err := _TestSMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) ParsePauserAdded(log types.Log) (*TestSMTPauserAdded, error) {
	event := new(TestSMTPauserAdded)
	if err := _TestSMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the TestSMT contract.
type TestSMTPauserRemovedIterator struct {
	Event *TestSMTPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPauserRemoved represents a PauserRemoved event raised by the TestSMT contract.
type TestSMTPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*TestSMTPauserRemovedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &TestSMTPauserRemovedIterator{contract: _TestSMT.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *TestSMTPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPauserRemoved)
				if err := _TestSMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) ParsePauserRemoved(log types.Log) (*TestSMTPauserRemoved, error) {
	event := new(TestSMTPauserRemoved)
	if err := _TestSMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the TestSMT contract.
type TestSMTProverAddedIterator struct {
	Event *TestSMTProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTProverAdded represents a ProverAdded event raised by the TestSMT contract.
type TestSMTProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) FilterProverAdded(opts *bind.FilterOpts) (*TestSMTProverAddedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &TestSMTProverAddedIterator{contract: _TestSMT.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *TestSMTProverAdded) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTProverAdded)
				if err := _TestSMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) ParseProverAdded(log types.Log) (*TestSMTProverAdded, error) {
	event := new(TestSMTProverAdded)
	if err := _TestSMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the TestSMT contract.
type TestSMTProverRemovedIterator struct {
	Event *TestSMTProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTProverRemoved represents a ProverRemoved event raised by the TestSMT contract.
type TestSMTProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*TestSMTProverRemovedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &TestSMTProverRemovedIterator{contract: _TestSMT.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *TestSMTProverRemoved) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTProverRemoved)
				if err := _TestSMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) ParseProverRemoved(log types.Log) (*TestSMTProverRemoved, error) {
	event := new(TestSMTProverRemoved)
	if err := _TestSMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTSmtRootUpdatedIterator is returned from FilterSmtRootUpdated and is used to iterate over the raw logs and unpacked data for SmtRootUpdated events raised by the TestSMT contract.
type TestSMTSmtRootUpdatedIterator struct {
	Event *TestSMTSmtRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTSmtRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTSmtRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTSmtRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTSmtRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTSmtRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTSmtRootUpdated represents a SmtRootUpdated event raised by the TestSMT contract.
type TestSMTSmtRootUpdated struct {
	SmtRoot     [32]byte
	EndBlockNum uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtRootUpdated is a free log retrieval operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_TestSMT *TestSMTFilterer) FilterSmtRootUpdated(opts *bind.FilterOpts) (*TestSMTSmtRootUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTSmtRootUpdatedIterator{contract: _TestSMT.contract, event: "SmtRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtRootUpdated is a free log subscription operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_TestSMT *TestSMTFilterer) WatchSmtRootUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTSmtRootUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTSmtRootUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtRootUpdated is a log parse operation binding the contract event 0x05712e4e1ed94f6f2706270c5ab0cbecd31613e0534ea4878ec4a16dc2f532a7.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum)
func (_TestSMT *TestSMTFilterer) ParseSmtRootUpdated(log types.Log) (*TestSMTSmtRootUpdated, error) {
	event := new(TestSMTSmtRootUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the TestSMT contract.
type TestSMTUnpausedIterator struct {
	Event *TestSMTUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTUnpaused represents a Unpaused event raised by the TestSMT contract.
type TestSMTUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) FilterUnpaused(opts *bind.FilterOpts) (*TestSMTUnpausedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &TestSMTUnpausedIterator{contract: _TestSMT.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *TestSMTUnpaused) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTUnpaused)
				if err := _TestSMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) ParseUnpaused(log types.Log) (*TestSMTUnpaused, error) {
	event := new(TestSMTUnpaused)
	if err := _TestSMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTVerifierUpdatedIterator is returned from FilterVerifierUpdated and is used to iterate over the raw logs and unpacked data for VerifierUpdated events raised by the TestSMT contract.
type TestSMTVerifierUpdatedIterator struct {
	Event *TestSMTVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTVerifierUpdated represents a VerifierUpdated event raised by the TestSMT contract.
type TestSMTVerifierUpdated struct {
	ChainId  uint64
	Verifier common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVerifierUpdated is a free log retrieval operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) FilterVerifierUpdated(opts *bind.FilterOpts) (*TestSMTVerifierUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTVerifierUpdatedIterator{contract: _TestSMT.contract, event: "VerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierUpdated is a free log subscription operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) WatchVerifierUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTVerifierUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierUpdated is a log parse operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) ParseVerifierUpdated(log types.Log) (*TestSMTVerifierUpdated, error) {
	event := new(TestSMTVerifierUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TickBitmapMetaData contains all meta data concerning the TickBitmap contract.
var TickBitmapMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"TickMisaligned\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212208fbdf76d95acb28bf06a018ce600d7687585fd7839436ed10e31224f33b4466c64736f6c63430008140033",
}

// TickBitmapABI is the input ABI used to generate the binding from.
// Deprecated: Use TickBitmapMetaData.ABI instead.
var TickBitmapABI = TickBitmapMetaData.ABI

// TickBitmapBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TickBitmapMetaData.Bin instead.
var TickBitmapBin = TickBitmapMetaData.Bin

// DeployTickBitmap deploys a new Ethereum contract, binding an instance of TickBitmap to it.
func DeployTickBitmap(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TickBitmap, error) {
	parsed, err := TickBitmapMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TickBitmapBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TickBitmap{TickBitmapCaller: TickBitmapCaller{contract: contract}, TickBitmapTransactor: TickBitmapTransactor{contract: contract}, TickBitmapFilterer: TickBitmapFilterer{contract: contract}}, nil
}

// TickBitmap is an auto generated Go binding around an Ethereum contract.
type TickBitmap struct {
	TickBitmapCaller     // Read-only binding to the contract
	TickBitmapTransactor // Write-only binding to the contract
	TickBitmapFilterer   // Log filterer for contract events
}

// TickBitmapCaller is an auto generated read-only Go binding around an Ethereum contract.
type TickBitmapCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TickBitmapTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TickBitmapFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TickBitmapSession struct {
	Contract     *TickBitmap       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TickBitmapCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TickBitmapCallerSession struct {
	Contract *TickBitmapCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TickBitmapTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TickBitmapTransactorSession struct {
	Contract     *TickBitmapTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TickBitmapRaw is an auto generated low-level Go binding around an Ethereum contract.
type TickBitmapRaw struct {
	Contract *TickBitmap // Generic contract binding to access the raw methods on
}

// TickBitmapCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TickBitmapCallerRaw struct {
	Contract *TickBitmapCaller // Generic read-only contract binding to access the raw methods on
}

// TickBitmapTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TickBitmapTransactorRaw struct {
	Contract *TickBitmapTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTickBitmap creates a new instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmap(address common.Address, backend bind.ContractBackend) (*TickBitmap, error) {
	contract, err := bindTickBitmap(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TickBitmap{TickBitmapCaller: TickBitmapCaller{contract: contract}, TickBitmapTransactor: TickBitmapTransactor{contract: contract}, TickBitmapFilterer: TickBitmapFilterer{contract: contract}}, nil
}

// NewTickBitmapCaller creates a new read-only instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapCaller(address common.Address, caller bind.ContractCaller) (*TickBitmapCaller, error) {
	contract, err := bindTickBitmap(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TickBitmapCaller{contract: contract}, nil
}

// NewTickBitmapTransactor creates a new write-only instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapTransactor(address common.Address, transactor bind.ContractTransactor) (*TickBitmapTransactor, error) {
	contract, err := bindTickBitmap(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TickBitmapTransactor{contract: contract}, nil
}

// NewTickBitmapFilterer creates a new log filterer instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapFilterer(address common.Address, filterer bind.ContractFilterer) (*TickBitmapFilterer, error) {
	contract, err := bindTickBitmap(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TickBitmapFilterer{contract: contract}, nil
}

// bindTickBitmap binds a generic wrapper to an already deployed contract.
func bindTickBitmap(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TickBitmapMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickBitmap *TickBitmapRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickBitmap.Contract.TickBitmapCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickBitmap *TickBitmapRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickBitmap.Contract.TickBitmapTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickBitmap *TickBitmapRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickBitmap.Contract.TickBitmapTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickBitmap *TickBitmapCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickBitmap.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickBitmap *TickBitmapTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickBitmap.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickBitmap *TickBitmapTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickBitmap.Contract.contract.Transact(opts, method, params...)
}

// TickMathMetaData contains all meta data concerning the TickMath contract.
var TickMathMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"InvalidSqrtRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTick\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212205772a8b338a83359a3f28220a5ee3b420f99c706f658d1ecd9777e86a692d54764736f6c63430008140033",
}

// TickMathABI is the input ABI used to generate the binding from.
// Deprecated: Use TickMathMetaData.ABI instead.
var TickMathABI = TickMathMetaData.ABI

// TickMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TickMathMetaData.Bin instead.
var TickMathBin = TickMathMetaData.Bin

// DeployTickMath deploys a new Ethereum contract, binding an instance of TickMath to it.
func DeployTickMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TickMath, error) {
	parsed, err := TickMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TickMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TickMath{TickMathCaller: TickMathCaller{contract: contract}, TickMathTransactor: TickMathTransactor{contract: contract}, TickMathFilterer: TickMathFilterer{contract: contract}}, nil
}

// TickMath is an auto generated Go binding around an Ethereum contract.
type TickMath struct {
	TickMathCaller     // Read-only binding to the contract
	TickMathTransactor // Write-only binding to the contract
	TickMathFilterer   // Log filterer for contract events
}

// TickMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type TickMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TickMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TickMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TickMathSession struct {
	Contract     *TickMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TickMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TickMathCallerSession struct {
	Contract *TickMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// TickMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TickMathTransactorSession struct {
	Contract     *TickMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// TickMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type TickMathRaw struct {
	Contract *TickMath // Generic contract binding to access the raw methods on
}

// TickMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TickMathCallerRaw struct {
	Contract *TickMathCaller // Generic read-only contract binding to access the raw methods on
}

// TickMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TickMathTransactorRaw struct {
	Contract *TickMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTickMath creates a new instance of TickMath, bound to a specific deployed contract.
func NewTickMath(address common.Address, backend bind.ContractBackend) (*TickMath, error) {
	contract, err := bindTickMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TickMath{TickMathCaller: TickMathCaller{contract: contract}, TickMathTransactor: TickMathTransactor{contract: contract}, TickMathFilterer: TickMathFilterer{contract: contract}}, nil
}

// NewTickMathCaller creates a new read-only instance of TickMath, bound to a specific deployed contract.
func NewTickMathCaller(address common.Address, caller bind.ContractCaller) (*TickMathCaller, error) {
	contract, err := bindTickMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TickMathCaller{contract: contract}, nil
}

// NewTickMathTransactor creates a new write-only instance of TickMath, bound to a specific deployed contract.
func NewTickMathTransactor(address common.Address, transactor bind.ContractTransactor) (*TickMathTransactor, error) {
	contract, err := bindTickMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TickMathTransactor{contract: contract}, nil
}

// NewTickMathFilterer creates a new log filterer instance of TickMath, bound to a specific deployed contract.
func NewTickMathFilterer(address common.Address, filterer bind.ContractFilterer) (*TickMathFilterer, error) {
	contract, err := bindTickMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TickMathFilterer{contract: contract}, nil
}

// bindTickMath binds a generic wrapper to an already deployed contract.
func bindTickMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TickMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickMath *TickMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickMath.Contract.TickMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickMath *TickMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickMath.Contract.TickMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickMath *TickMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickMath.Contract.TickMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickMath *TickMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickMath *TickMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickMath *TickMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickMath.Contract.contract.Transact(opts, method, params...)
}

// TierFactoryMetaData contains all meta data concerning the TierFactory contract.
var TierFactoryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TargetPrefix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FLAG_MASK\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractTierHook\",\"name\":\"_tierHook\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sumVolumeAddress\",\"type\":\"address\"}],\"name\":\"updateHookSumVolumeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a08060405234610079576021609a1b6080525f8054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3611630908161007e823960805181818161026b0152818161042b01526105720152f35b5f80fdfe6040608081526004361015610012575f80fd5b5f90813560e01c806321cde3ec146103bf5780632e026a671461038857806332c02a1414610350578063635d401714610321578063715018a6146102b45780638da5cb5b1461028f578063a707b18a1461024c578063c6f614631461022e57828163d8f4720114610179575063f2fde38b1461008c575f80fd5b34610175576020366003190112610175576100a56103f2565b6001600160a01b0380916100bd828654163314610763565b1691821561010c57505f548273ffffffffffffffffffffffffffffffffffffffff198216175f55167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a380f35b5162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b5080fd5b80833461022b578060031936011261022b576004356001600160a01b03908181168091036102225760243591808316809303610227576101bd908554163314610763565b803b15610222576024849284519586938492630221016d60e31b845260048401525af18015610218576101ee578280f35b67ffffffffffffffff8211610204575281808280f35b634e487b7160e01b83526041600452602483fd5b81513d85823e3d90fd5b505050fd5b8480fd5b50fd5b50346101755781600319360112610175576020905160ff60981b8152f35b5034610175578160031936011261017557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346101755781600319360112610175576001600160a01b0360209254169051908152f35b823461031e578060031936011261031e5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b038216916102f4338414610763565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b50346101755780600319360112610175576020906103496103406103f2565b60243590610546565b9051908152f35b50346101755780600319360112610175576020906001600160a01b036103806103776103f2565b602435906106eb565b915191168152f35b5034610175576020366003190112610175576020906001600160a01b036103806103b06103f2565b6103b98161040c565b906106eb565b50346101755780600319360112610175576020906001600160a01b036103806103e66103f2565b6103b960243582610546565b600435906001600160a01b038216820361040857565b5f80fd5b5f610e4c906020928383016107af903060601b926001600160a01b03807f000000000000000000000000000000000000000000000000000000000000000016955b6103e8811061049b5760405162461bcd60e51b8152600481018a9052601560248201527f4661696c656420746f2066696e6420612073616c7400000000000000000000006044820152606490fd5b8660ff60981b8a8a6104e76104fb6040938451936104b98c866106c9565b8085528c828601396104ed85518a8c16838201528281526104d98161067d565b86519485938401809761073a565b9061073a565b03601f1981018352826106c9565b51902090518c81019160ff60f81b83528a6021830152856035830152605590818301528152610529816106ad565b519020161461053a5760010161044d565b97505050505050505090565b906103e881019081811161066957610e4c6020938482016107af913060601b936001600160a01b0390817f000000000000000000000000000000000000000000000000000000000000000016965b8881106105e05760405162461bcd60e51b8152600481018b9052601560248201527f4661696c656420746f2066696e6420612073616c7400000000000000000000006044820152606490fd5b8760ff60981b60408c6104e761061d8351926105fc8c856106c9565b888452888d828601396104ed85518b8d16838201528281526104d98161067d565b51902090518d81019160ff60f81b83528b602183015285603583015260559081830152815261064b816106ad565b519020161461065c57600101610594565b9850505050505050505090565b634e487b7160e01b5f52601160045260245ffd5b6040810190811067ffffffffffffffff82111761069957604052565b634e487b7160e01b5f52604160045260245ffd5b6080810190811067ffffffffffffffff82111761069957604052565b90601f8019910116810190811067ffffffffffffffff82111761069957604052565b90604051610e4c8082019082821067ffffffffffffffff8311176106995760209183916107af83396001600160a01b0380961681520301905ff5801561072f571690565b6040513d5f823e3d90fd5b908151915f5b838110610750575050015f815290565b8060208092840101518185015201610740565b1561076a57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfe60a034620001f657601f62000e4c38819003918201601f19168301916001600160401b03831184841017620001fa57808492602094604052833981010312620001f657516001600160a01b03908181168103620001f6575f8054336001600160a01b03198216811783559193167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08480a36080528060e0620000a06200020e565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260e0620000d56200020e565b60018152826020820152826040820152826060820152826080820152600160a08201528260c082015201526001609f1b30161515600114801590620001e6575b8015620001d6575b8015620001c6575b8015620001b6575b8015620001a2575b801562000192575b801562000182575b6200016a57604051610c1c908162000230823960805181818161023101526103fd0152f35b604051630732d7b560e51b8152306004820152602490fd5b5030600160981b16151562000145565b5030600160991b1615156200013d565b50306001609a1b1615156001141562000135565b50306001609b1b1615156200012d565b50306001609c1b16151562000125565b50306001609d1b1615156200011d565b50306001609e1b16151562000115565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519061010082016001600160401b03811183821017620001fa5760405256fe60406080815260049081361015610014575f80fd5b5f803560e01c806311080b68146107c8578063229c7d8b146107a05780632ab7a3e21461077b57806330b7cdef146107585780633440d820146106ce57806339dfff16146106b2578063575e24b4146106a25780635ae4ce5814610684578063612c39b7146105b4578063715018a61461054a5780638da5cb5b1461052457806390f57fc1146104f2578063a910f80f14610484578063ab6291fe146103c0578063b47b2fb114610259578063b6a8b0fa1461020c578063dc4c90d314610211578063e1b4af691461020c578063f2fde38b1461011d5763fe9a6f45146100f9575f80fd5b3461011a5750610108366108a3565b505050505051630a85dc2960e01b8152fd5b80fd5b50913461020857602036600319011261020857610138610847565b908354906001600160a01b0380831693610153338614610ad3565b1693841561019f57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610981565b509034610255578160031936011261025557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5080fd5b503461011a5761026836610907565b505092505060a08136031261020857835167ffffffffffffffff9360a08201858111838210176103ad57865261029d83610861565b918281526102ad60208501610861565b9360208201948552878101359062ffffff80831683036103a9578984019283526060820135918260020b83036103a557608090606086019384520135926001600160a01b039485851685036103a157608001938452848b51988160208b019916895251168b890152511660608701525160020b6080860152511660a084015260a0835260c08301948386109086111761038e57506020955060e09084865282519020928060801d8552600f0b9101527f6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee833293a35163b47b2fb160e01b8152f35b634e487b7160e01b815260418752602490fd5b8680fd5b8580fd5b8480fd5b634e487b7160e01b825260418852602482fd5b503461011a576020928360031936011261025557803567ffffffffffffffff8111610208576103f29036908301610875565b916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163303610476575061043084928692610a39565b82519382859384528251928382860152825b84811061046057505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610442565b845163570c108560e11b8152fd5b503461011a5761012036600319011261011a5761049f610847565b5060a036602319011261011a576104b461096b565b5060e4358060020b0361011a57610104359067ffffffffffffffff821161011a57506104e39036908401610875565b505051630a85dc2960e01b8152fd5b5090346102555760203660031901126102555760209062ffffff61051c610517610847565b610b1e565b915191168152f35b5090346102555781600319360112610255576001600160a01b0360209254169051908152f35b503461011a578060031936011261011a5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b0382169161058a338414610ad3565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b509034610255578160031936011261025557816101009260e083516105d8816109e6565b82815282602082015282858201528260608201528260808201528260a08201528260c08201520152815161060b816109e6565b6001815260208101928284528082019083825260608301848152608084019185835260a08501936001855260e060c087019688885201968752815197600189525115156020890152511515908701525115156060860152511515608085015251151560a084015251151560c083015251151560e0820152f35b5090346102555760a036600319011261025557602090516155338152f35b503461011a5750610108366108a3565b5090346102555760a03660031901126102555751908152602090f35b503461011a5761010036600319011261011a576106e9610847565b5060a036602319011261011a576106fe61096b565b5060e43567ffffffffffffffff81116102555761071e9036908501610875565b50506064359062ffffff8216820361011a575062800000161561074b57516301a206c160e51b8152602090f35b516315b3d69f60e31b8152fd5b503461011a575061076836610907565b50505050505051630a85dc2960e01b8152fd5b5090346102555760209061078e366108a3565b505050505062ffffff61051c32610b1e565b5090346102555781600319360112610255576020906001600160a01b03600154169051908152f35b5090346102555760203660031901126102555760207fa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a91610807610847565b6001600160a01b039061081e828754163314610ad3565b16908173ffffffffffffffffffffffffffffffffffffffff19600154161760015551908152a180f35b600435906001600160a01b038216820361085d57565b5f80fd5b35906001600160a01b038216820361085d57565b9181601f8401121561085d5782359167ffffffffffffffff831161085d576020838186019501011161085d57565b9061014060031983011261085d576004356001600160a01b038116810361085d579160a060231982011261085d57602491606060c31983011261085d5760c491610124359067ffffffffffffffff821161085d5761090391600401610875565b9091565b61016060031982011261085d576004356001600160a01b038116810361085d579160a060231983011261085d57602491606060c31982011261085d5760c4916101243591610144359067ffffffffffffffff821161085d5761090391600401610875565b60c435906001600160a01b038216820361085d57565b3461085d5761012036600319011261085d576004356001600160a01b0381160361085d5760a036602319011261085d576101043567ffffffffffffffff811161085d576109d2903690600401610875565b5050604051630a85dc2960e01b8152600490fd5b610100810190811067ffffffffffffffff821117610a0357604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff821117610a0357604052565b604051929183918190833781015f9384928284809452039082305af13d15610aca573d67ffffffffffffffff8111610ab65760405190610a83601f8201601f191660200183610a17565b8152809360203d92013e5b610ab45750805115610aa257602081519101fd5b6040516314815f4760e31b8152600490fd5b565b634e487b7160e01b84526041600452602484fd5b60609250610a8e565b15610ada57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b610b2790610b50565b6127109060028103610b3f575060011c627fffff1690565b600114610b495790565b50611f4090565b60206001600160a01b036024816001541693604051948593849263950650c160e01b84521660048301525afa908115610bdb575f91610baa575b50633b9aca00811115610b9d5750600290565b610ba5575f90565b600190565b906020823d8211610bd3575b81610bc360209383610a17565b8101031261011a5750515f610b8a565b3d9150610bb6565b6040513d5f823e3d90fdfea2646970667358221220ca7b196d50b7c878106cc182c7e0c071e9c805e958bc249fe2b729fd872fedfc64736f6c63430008140033a26469706673582212203c9dd67491f46c6a8c0facc5fa50311d9b77e5b500939cfc0f787c1931b29e7b64736f6c63430008140033",
}

// TierFactoryABI is the input ABI used to generate the binding from.
// Deprecated: Use TierFactoryMetaData.ABI instead.
var TierFactoryABI = TierFactoryMetaData.ABI

// TierFactoryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TierFactoryMetaData.Bin instead.
var TierFactoryBin = TierFactoryMetaData.Bin

// DeployTierFactory deploys a new Ethereum contract, binding an instance of TierFactory to it.
func DeployTierFactory(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TierFactory, error) {
	parsed, err := TierFactoryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TierFactoryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TierFactory{TierFactoryCaller: TierFactoryCaller{contract: contract}, TierFactoryTransactor: TierFactoryTransactor{contract: contract}, TierFactoryFilterer: TierFactoryFilterer{contract: contract}}, nil
}

// TierFactory is an auto generated Go binding around an Ethereum contract.
type TierFactory struct {
	TierFactoryCaller     // Read-only binding to the contract
	TierFactoryTransactor // Write-only binding to the contract
	TierFactoryFilterer   // Log filterer for contract events
}

// TierFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type TierFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TierFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TierFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TierFactorySession struct {
	Contract     *TierFactory      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TierFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TierFactoryCallerSession struct {
	Contract *TierFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// TierFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TierFactoryTransactorSession struct {
	Contract     *TierFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// TierFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type TierFactoryRaw struct {
	Contract *TierFactory // Generic contract binding to access the raw methods on
}

// TierFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TierFactoryCallerRaw struct {
	Contract *TierFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// TierFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TierFactoryTransactorRaw struct {
	Contract *TierFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTierFactory creates a new instance of TierFactory, bound to a specific deployed contract.
func NewTierFactory(address common.Address, backend bind.ContractBackend) (*TierFactory, error) {
	contract, err := bindTierFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TierFactory{TierFactoryCaller: TierFactoryCaller{contract: contract}, TierFactoryTransactor: TierFactoryTransactor{contract: contract}, TierFactoryFilterer: TierFactoryFilterer{contract: contract}}, nil
}

// NewTierFactoryCaller creates a new read-only instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryCaller(address common.Address, caller bind.ContractCaller) (*TierFactoryCaller, error) {
	contract, err := bindTierFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TierFactoryCaller{contract: contract}, nil
}

// NewTierFactoryTransactor creates a new write-only instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*TierFactoryTransactor, error) {
	contract, err := bindTierFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TierFactoryTransactor{contract: contract}, nil
}

// NewTierFactoryFilterer creates a new log filterer instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*TierFactoryFilterer, error) {
	contract, err := bindTierFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TierFactoryFilterer{contract: contract}, nil
}

// bindTierFactory binds a generic wrapper to an already deployed contract.
func bindTierFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TierFactoryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierFactory *TierFactoryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierFactory.Contract.TierFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierFactory *TierFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.Contract.TierFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierFactory *TierFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierFactory.Contract.TierFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierFactory *TierFactoryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierFactory *TierFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierFactory *TierFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierFactory.Contract.contract.Transact(opts, method, params...)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactoryCaller) TargetPrefix(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "TargetPrefix")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactorySession) TargetPrefix() (common.Address, error) {
	return _TierFactory.Contract.TargetPrefix(&_TierFactory.CallOpts)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactoryCallerSession) TargetPrefix() (common.Address, error) {
	return _TierFactory.Contract.TargetPrefix(&_TierFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactoryCaller) UNISWAPFLAGMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "UNISWAP_FLAG_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactorySession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _TierFactory.Contract.UNISWAPFLAGMASK(&_TierFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactoryCallerSession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _TierFactory.Contract.UNISWAPFLAGMASK(&_TierFactory.CallOpts)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactoryCaller) MineSalt(opts *bind.CallOpts, poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "mineSalt", poolManager, startSalt)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactorySession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _TierFactory.Contract.MineSalt(&_TierFactory.CallOpts, poolManager, startSalt)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactoryCallerSession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _TierFactory.Contract.MineSalt(&_TierFactory.CallOpts, poolManager, startSalt)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactoryCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactorySession) Owner() (common.Address, error) {
	return _TierFactory.Contract.Owner(&_TierFactory.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactoryCallerSession) Owner() (common.Address, error) {
	return _TierFactory.Contract.Owner(&_TierFactory.CallOpts)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactoryTransactor) Deploy(opts *bind.TransactOpts, poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "deploy", poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactorySession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.Contract.Deploy(&_TierFactory.TransactOpts, poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactoryTransactorSession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.Contract.Deploy(&_TierFactory.TransactOpts, poolManager, salt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactoryTransactor) MineDeploy(opts *bind.TransactOpts, poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "mineDeploy", poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactorySession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy(&_TierFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactoryTransactorSession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy(&_TierFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactoryTransactor) MineDeploy0(opts *bind.TransactOpts, poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "mineDeploy0", poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactorySession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy0(&_TierFactory.TransactOpts, poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactoryTransactorSession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy0(&_TierFactory.TransactOpts, poolManager)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactoryTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactorySession) RenounceOwnership() (*types.Transaction, error) {
	return _TierFactory.Contract.RenounceOwnership(&_TierFactory.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactoryTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierFactory.Contract.RenounceOwnership(&_TierFactory.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactoryTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactorySession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.TransferOwnership(&_TierFactory.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactoryTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.TransferOwnership(&_TierFactory.TransactOpts, newOwner)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactoryTransactor) UpdateHookSumVolumeAddress(opts *bind.TransactOpts, _tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "updateHookSumVolumeAddress", _tierHook, _sumVolumeAddress)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactorySession) UpdateHookSumVolumeAddress(_tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.UpdateHookSumVolumeAddress(&_TierFactory.TransactOpts, _tierHook, _sumVolumeAddress)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactoryTransactorSession) UpdateHookSumVolumeAddress(_tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.UpdateHookSumVolumeAddress(&_TierFactory.TransactOpts, _tierHook, _sumVolumeAddress)
}

// TierFactoryOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TierFactory contract.
type TierFactoryOwnershipTransferredIterator struct {
	Event *TierFactoryOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierFactoryOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierFactoryOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierFactoryOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierFactoryOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierFactoryOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierFactoryOwnershipTransferred represents a OwnershipTransferred event raised by the TierFactory contract.
type TierFactoryOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TierFactoryOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierFactory.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TierFactoryOwnershipTransferredIterator{contract: _TierFactory.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TierFactoryOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierFactory.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierFactoryOwnershipTransferred)
				if err := _TierFactory.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) ParseOwnershipTransferred(log types.Log) (*TierFactoryOwnershipTransferred, error) {
	event := new(TierFactoryOwnershipTransferred)
	if err := _TierFactory.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookMetaData contains all meta data concerning the TierHook contract.
var TierHookMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"_poolManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustUseDynamicFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount0\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount1\",\"type\":\"int128\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateSumVolumeAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getFeeBySwapper\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"getHookFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"getHookWithdrawFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"fee\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHooksCalls\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"beforeInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeDonate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterDonate\",\"type\":\"bool\"}],\"internalType\":\"structHooks.Calls\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lockAcquired\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumVolumeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sumVolumeAddress\",\"type\":\"address\"}],\"name\":\"updateSumVolumeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a034620001f657601f62000e4c38819003918201601f19168301916001600160401b03831184841017620001fa57808492602094604052833981010312620001f657516001600160a01b03908181168103620001f6575f8054336001600160a01b03198216811783559193167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08480a36080528060e0620000a06200020e565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260e0620000d56200020e565b60018152826020820152826040820152826060820152826080820152600160a08201528260c082015201526001609f1b30161515600114801590620001e6575b8015620001d6575b8015620001c6575b8015620001b6575b8015620001a2575b801562000192575b801562000182575b6200016a57604051610c1c908162000230823960805181818161023101526103fd0152f35b604051630732d7b560e51b8152306004820152602490fd5b5030600160981b16151562000145565b5030600160991b1615156200013d565b50306001609a1b1615156001141562000135565b50306001609b1b1615156200012d565b50306001609c1b16151562000125565b50306001609d1b1615156200011d565b50306001609e1b16151562000115565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519061010082016001600160401b03811183821017620001fa5760405256fe60406080815260049081361015610014575f80fd5b5f803560e01c806311080b68146107c8578063229c7d8b146107a05780632ab7a3e21461077b57806330b7cdef146107585780633440d820146106ce57806339dfff16146106b2578063575e24b4146106a25780635ae4ce5814610684578063612c39b7146105b4578063715018a61461054a5780638da5cb5b1461052457806390f57fc1146104f2578063a910f80f14610484578063ab6291fe146103c0578063b47b2fb114610259578063b6a8b0fa1461020c578063dc4c90d314610211578063e1b4af691461020c578063f2fde38b1461011d5763fe9a6f45146100f9575f80fd5b3461011a5750610108366108a3565b505050505051630a85dc2960e01b8152fd5b80fd5b50913461020857602036600319011261020857610138610847565b908354906001600160a01b0380831693610153338614610ad3565b1693841561019f57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610981565b509034610255578160031936011261025557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5080fd5b503461011a5761026836610907565b505092505060a08136031261020857835167ffffffffffffffff9360a08201858111838210176103ad57865261029d83610861565b918281526102ad60208501610861565b9360208201948552878101359062ffffff80831683036103a9578984019283526060820135918260020b83036103a557608090606086019384520135926001600160a01b039485851685036103a157608001938452848b51988160208b019916895251168b890152511660608701525160020b6080860152511660a084015260a0835260c08301948386109086111761038e57506020955060e09084865282519020928060801d8552600f0b9101527f6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee833293a35163b47b2fb160e01b8152f35b634e487b7160e01b815260418752602490fd5b8680fd5b8580fd5b8480fd5b634e487b7160e01b825260418852602482fd5b503461011a576020928360031936011261025557803567ffffffffffffffff8111610208576103f29036908301610875565b916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163303610476575061043084928692610a39565b82519382859384528251928382860152825b84811061046057505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610442565b845163570c108560e11b8152fd5b503461011a5761012036600319011261011a5761049f610847565b5060a036602319011261011a576104b461096b565b5060e4358060020b0361011a57610104359067ffffffffffffffff821161011a57506104e39036908401610875565b505051630a85dc2960e01b8152fd5b5090346102555760203660031901126102555760209062ffffff61051c610517610847565b610b1e565b915191168152f35b5090346102555781600319360112610255576001600160a01b0360209254169051908152f35b503461011a578060031936011261011a5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b0382169161058a338414610ad3565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b509034610255578160031936011261025557816101009260e083516105d8816109e6565b82815282602082015282858201528260608201528260808201528260a08201528260c08201520152815161060b816109e6565b6001815260208101928284528082019083825260608301848152608084019185835260a08501936001855260e060c087019688885201968752815197600189525115156020890152511515908701525115156060860152511515608085015251151560a084015251151560c083015251151560e0820152f35b5090346102555760a036600319011261025557602090516155338152f35b503461011a5750610108366108a3565b5090346102555760a03660031901126102555751908152602090f35b503461011a5761010036600319011261011a576106e9610847565b5060a036602319011261011a576106fe61096b565b5060e43567ffffffffffffffff81116102555761071e9036908501610875565b50506064359062ffffff8216820361011a575062800000161561074b57516301a206c160e51b8152602090f35b516315b3d69f60e31b8152fd5b503461011a575061076836610907565b50505050505051630a85dc2960e01b8152fd5b5090346102555760209061078e366108a3565b505050505062ffffff61051c32610b1e565b5090346102555781600319360112610255576020906001600160a01b03600154169051908152f35b5090346102555760203660031901126102555760207fa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a91610807610847565b6001600160a01b039061081e828754163314610ad3565b16908173ffffffffffffffffffffffffffffffffffffffff19600154161760015551908152a180f35b600435906001600160a01b038216820361085d57565b5f80fd5b35906001600160a01b038216820361085d57565b9181601f8401121561085d5782359167ffffffffffffffff831161085d576020838186019501011161085d57565b9061014060031983011261085d576004356001600160a01b038116810361085d579160a060231982011261085d57602491606060c31983011261085d5760c491610124359067ffffffffffffffff821161085d5761090391600401610875565b9091565b61016060031982011261085d576004356001600160a01b038116810361085d579160a060231983011261085d57602491606060c31982011261085d5760c4916101243591610144359067ffffffffffffffff821161085d5761090391600401610875565b60c435906001600160a01b038216820361085d57565b3461085d5761012036600319011261085d576004356001600160a01b0381160361085d5760a036602319011261085d576101043567ffffffffffffffff811161085d576109d2903690600401610875565b5050604051630a85dc2960e01b8152600490fd5b610100810190811067ffffffffffffffff821117610a0357604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff821117610a0357604052565b604051929183918190833781015f9384928284809452039082305af13d15610aca573d67ffffffffffffffff8111610ab65760405190610a83601f8201601f191660200183610a17565b8152809360203d92013e5b610ab45750805115610aa257602081519101fd5b6040516314815f4760e31b8152600490fd5b565b634e487b7160e01b84526041600452602484fd5b60609250610a8e565b15610ada57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b610b2790610b50565b6127109060028103610b3f575060011c627fffff1690565b600114610b495790565b50611f4090565b60206001600160a01b036024816001541693604051948593849263950650c160e01b84521660048301525afa908115610bdb575f91610baa575b50633b9aca00811115610b9d5750600290565b610ba5575f90565b600190565b906020823d8211610bd3575b81610bc360209383610a17565b8101031261011a5750515f610b8a565b3d9150610bb6565b6040513d5f823e3d90fdfea2646970667358221220ca7b196d50b7c878106cc182c7e0c071e9c805e958bc249fe2b729fd872fedfc64736f6c63430008140033",
}

// TierHookABI is the input ABI used to generate the binding from.
// Deprecated: Use TierHookMetaData.ABI instead.
var TierHookABI = TierHookMetaData.ABI

// TierHookBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TierHookMetaData.Bin instead.
var TierHookBin = TierHookMetaData.Bin

// DeployTierHook deploys a new Ethereum contract, binding an instance of TierHook to it.
func DeployTierHook(auth *bind.TransactOpts, backend bind.ContractBackend, _poolManager common.Address) (common.Address, *types.Transaction, *TierHook, error) {
	parsed, err := TierHookMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TierHookBin), backend, _poolManager)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TierHook{TierHookCaller: TierHookCaller{contract: contract}, TierHookTransactor: TierHookTransactor{contract: contract}, TierHookFilterer: TierHookFilterer{contract: contract}}, nil
}

// TierHook is an auto generated Go binding around an Ethereum contract.
type TierHook struct {
	TierHookCaller     // Read-only binding to the contract
	TierHookTransactor // Write-only binding to the contract
	TierHookFilterer   // Log filterer for contract events
}

// TierHookCaller is an auto generated read-only Go binding around an Ethereum contract.
type TierHookCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TierHookTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TierHookFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TierHookSession struct {
	Contract     *TierHook         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TierHookCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TierHookCallerSession struct {
	Contract *TierHookCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// TierHookTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TierHookTransactorSession struct {
	Contract     *TierHookTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// TierHookRaw is an auto generated low-level Go binding around an Ethereum contract.
type TierHookRaw struct {
	Contract *TierHook // Generic contract binding to access the raw methods on
}

// TierHookCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TierHookCallerRaw struct {
	Contract *TierHookCaller // Generic read-only contract binding to access the raw methods on
}

// TierHookTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TierHookTransactorRaw struct {
	Contract *TierHookTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTierHook creates a new instance of TierHook, bound to a specific deployed contract.
func NewTierHook(address common.Address, backend bind.ContractBackend) (*TierHook, error) {
	contract, err := bindTierHook(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TierHook{TierHookCaller: TierHookCaller{contract: contract}, TierHookTransactor: TierHookTransactor{contract: contract}, TierHookFilterer: TierHookFilterer{contract: contract}}, nil
}

// NewTierHookCaller creates a new read-only instance of TierHook, bound to a specific deployed contract.
func NewTierHookCaller(address common.Address, caller bind.ContractCaller) (*TierHookCaller, error) {
	contract, err := bindTierHook(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TierHookCaller{contract: contract}, nil
}

// NewTierHookTransactor creates a new write-only instance of TierHook, bound to a specific deployed contract.
func NewTierHookTransactor(address common.Address, transactor bind.ContractTransactor) (*TierHookTransactor, error) {
	contract, err := bindTierHook(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TierHookTransactor{contract: contract}, nil
}

// NewTierHookFilterer creates a new log filterer instance of TierHook, bound to a specific deployed contract.
func NewTierHookFilterer(address common.Address, filterer bind.ContractFilterer) (*TierHookFilterer, error) {
	contract, err := bindTierHook(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TierHookFilterer{contract: contract}, nil
}

// bindTierHook binds a generic wrapper to an already deployed contract.
func bindTierHook(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TierHookMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierHook *TierHookRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierHook.Contract.TierHookCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierHook *TierHookRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.Contract.TierHookTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierHook *TierHookRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierHook.Contract.TierHookTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierHook *TierHookCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierHook.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierHook *TierHookTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierHook *TierHookTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierHook.Contract.contract.Transact(opts, method, params...)
}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookCaller) BeforeInitialize(opts *bind.CallOpts, arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "beforeInitialize", arg0, key, arg2, arg3)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookSession) BeforeInitialize(arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _TierHook.Contract.BeforeInitialize(&_TierHook.CallOpts, arg0, key, arg2, arg3)
}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookCallerSession) BeforeInitialize(arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _TierHook.Contract.BeforeInitialize(&_TierHook.CallOpts, arg0, key, arg2, arg3)
}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookCaller) GetFee(opts *bind.CallOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getFee", arg0, arg1, arg2, arg3)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookSession) GetFee(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	return _TierHook.Contract.GetFee(&_TierHook.CallOpts, arg0, arg1, arg2, arg3)
}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookCallerSession) GetFee(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	return _TierHook.Contract.GetFee(&_TierHook.CallOpts, arg0, arg1, arg2, arg3)
}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookCaller) GetFeeBySwapper(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getFeeBySwapper", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookSession) GetFeeBySwapper(swapper common.Address) (*big.Int, error) {
	return _TierHook.Contract.GetFeeBySwapper(&_TierHook.CallOpts, swapper)
}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookCallerSession) GetFeeBySwapper(swapper common.Address) (*big.Int, error) {
	return _TierHook.Contract.GetFeeBySwapper(&_TierHook.CallOpts, swapper)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookCaller) GetHookFees(opts *bind.CallOpts, arg0 PoolKey) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHookFees", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookSession) GetHookFees(arg0 PoolKey) (*big.Int, error) {
	return _TierHook.Contract.GetHookFees(&_TierHook.CallOpts, arg0)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookCallerSession) GetHookFees(arg0 PoolKey) (*big.Int, error) {
	return _TierHook.Contract.GetHookFees(&_TierHook.CallOpts, arg0)
}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookCaller) GetHookWithdrawFee(opts *bind.CallOpts, key PoolKey) (uint8, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHookWithdrawFee", key)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookSession) GetHookWithdrawFee(key PoolKey) (uint8, error) {
	return _TierHook.Contract.GetHookWithdrawFee(&_TierHook.CallOpts, key)
}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookCallerSession) GetHookWithdrawFee(key PoolKey) (uint8, error) {
	return _TierHook.Contract.GetHookWithdrawFee(&_TierHook.CallOpts, key)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookCaller) GetHooksCalls(opts *bind.CallOpts) (HooksCalls, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHooksCalls")

	if err != nil {
		return *new(HooksCalls), err
	}

	out0 := *abi.ConvertType(out[0], new(HooksCalls)).(*HooksCalls)

	return out0, err

}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookSession) GetHooksCalls() (HooksCalls, error) {
	return _TierHook.Contract.GetHooksCalls(&_TierHook.CallOpts)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookCallerSession) GetHooksCalls() (HooksCalls, error) {
	return _TierHook.Contract.GetHooksCalls(&_TierHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookSession) Owner() (common.Address, error) {
	return _TierHook.Contract.Owner(&_TierHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookCallerSession) Owner() (common.Address, error) {
	return _TierHook.Contract.Owner(&_TierHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookCaller) PoolManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "poolManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookSession) PoolManager() (common.Address, error) {
	return _TierHook.Contract.PoolManager(&_TierHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookCallerSession) PoolManager() (common.Address, error) {
	return _TierHook.Contract.PoolManager(&_TierHook.CallOpts)
}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookCaller) SumVolumeAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "sumVolumeAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookSession) SumVolumeAddress() (common.Address, error) {
	return _TierHook.Contract.SumVolumeAddress(&_TierHook.CallOpts)
}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookCallerSession) SumVolumeAddress() (common.Address, error) {
	return _TierHook.Contract.SumVolumeAddress(&_TierHook.CallOpts)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterDonate", arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterInitialize", arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterInitialize(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterInitialize(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterModifyPosition", arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookTransactor) AfterSwap(opts *bind.TransactOpts, arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterSwap", arg0, key, arg2, delta, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookSession) AfterSwap(arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterSwap(&_TierHook.TransactOpts, arg0, key, arg2, delta, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookTransactorSession) AfterSwap(arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterSwap(&_TierHook.TransactOpts, arg0, key, arg2, delta, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeDonate", arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeModifyPosition", arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeSwap", arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeSwap(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeSwap(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookTransactor) LockAcquired(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "lockAcquired", data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _TierHook.Contract.LockAcquired(&_TierHook.TransactOpts, data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookTransactorSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _TierHook.Contract.LockAcquired(&_TierHook.TransactOpts, data)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierHook.Contract.RenounceOwnership(&_TierHook.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierHook.Contract.RenounceOwnership(&_TierHook.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.TransferOwnership(&_TierHook.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.TransferOwnership(&_TierHook.TransactOpts, newOwner)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookTransactor) UpdateSumVolumeAddress(opts *bind.TransactOpts, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "updateSumVolumeAddress", _sumVolumeAddress)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookSession) UpdateSumVolumeAddress(_sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.UpdateSumVolumeAddress(&_TierHook.TransactOpts, _sumVolumeAddress)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookTransactorSession) UpdateSumVolumeAddress(_sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.UpdateSumVolumeAddress(&_TierHook.TransactOpts, _sumVolumeAddress)
}

// TierHookOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TierHook contract.
type TierHookOwnershipTransferredIterator struct {
	Event *TierHookOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookOwnershipTransferred represents a OwnershipTransferred event raised by the TierHook contract.
type TierHookOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TierHookOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TierHookOwnershipTransferredIterator{contract: _TierHook.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TierHookOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookOwnershipTransferred)
				if err := _TierHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) ParseOwnershipTransferred(log types.Log) (*TierHookOwnershipTransferred, error) {
	event := new(TierHookOwnershipTransferred)
	if err := _TierHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the TierHook contract.
type TierHookSwapIterator struct {
	Event *TierHookSwap // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookSwapIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookSwap)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookSwap)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookSwapIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookSwapIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookSwap represents a Swap event raised by the TierHook contract.
type TierHookSwap struct {
	Id      [32]byte
	Sender  common.Address
	Amount0 *big.Int
	Amount1 *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterSwap is a free log retrieval operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) FilterSwap(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*TierHookSwapIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &TierHookSwapIterator{contract: _TierHook.contract, event: "Swap", logs: logs, sub: sub}, nil
}

// WatchSwap is a free log subscription operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *TierHookSwap, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookSwap)
				if err := _TierHook.contract.UnpackLog(event, "Swap", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSwap is a log parse operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) ParseSwap(log types.Log) (*TierHookSwap, error) {
	event := new(TierHookSwap)
	if err := _TierHook.contract.UnpackLog(event, "Swap", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookUpdateSumVolumeAddressIterator is returned from FilterUpdateSumVolumeAddress and is used to iterate over the raw logs and unpacked data for UpdateSumVolumeAddress events raised by the TierHook contract.
type TierHookUpdateSumVolumeAddressIterator struct {
	Event *TierHookUpdateSumVolumeAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookUpdateSumVolumeAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookUpdateSumVolumeAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookUpdateSumVolumeAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookUpdateSumVolumeAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookUpdateSumVolumeAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookUpdateSumVolumeAddress represents a UpdateSumVolumeAddress event raised by the TierHook contract.
type TierHookUpdateSumVolumeAddress struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateSumVolumeAddress is a free log retrieval operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) FilterUpdateSumVolumeAddress(opts *bind.FilterOpts) (*TierHookUpdateSumVolumeAddressIterator, error) {

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "UpdateSumVolumeAddress")
	if err != nil {
		return nil, err
	}
	return &TierHookUpdateSumVolumeAddressIterator{contract: _TierHook.contract, event: "UpdateSumVolumeAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateSumVolumeAddress is a free log subscription operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) WatchUpdateSumVolumeAddress(opts *bind.WatchOpts, sink chan<- *TierHookUpdateSumVolumeAddress) (event.Subscription, error) {

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "UpdateSumVolumeAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookUpdateSumVolumeAddress)
				if err := _TierHook.contract.UnpackLog(event, "UpdateSumVolumeAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateSumVolumeAddress is a log parse operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) ParseUpdateSumVolumeAddress(log types.Log) (*TierHookUpdateSumVolumeAddress, error) {
	event := new(TierHookUpdateSumVolumeAddress)
	if err := _TierHook.contract.UnpackLog(event, "UpdateSumVolumeAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultMetaData contains all meta data concerning the TokenVault contract.
var TokenVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"_messageBridge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"remotePegBridges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_remoteChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_remotePegBridge\",\"type\":\"address\"}],\"name\":\"setRemotePegBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a657601f6110fe38819003918201601f19168301916001600160401b038311848410176100aa578084926020946040528339810103126100a657516001600160a01b0390818116908190036100a65760018060a01b031990815f5416175f55600154903390821617600155604051913391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a361103f90816100bf8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c806301e64725146100c457806323463624146100bf5780632f5c5fee146100ba57806333a42db1146100b55780633c29f839146100b05780635ec2fa26146100ab578063715018a6146100a65780638da5cb5b146100a1578063aec95a141461009c578063cd49e90b146100975763f2fde38b14610092575f80fd5b6107a6565b610764565b6106da565b6106b4565b610645565b6104ed565b610480565b61045b565b6103e6565b61015c565b346100f35760203660031901126100f3576004355f526002602052602060ff60405f2054166040519015158152f35b5f80fd5b6001600160a01b038116036100f357565b60643590610115826100f7565b565b6044359067ffffffffffffffff821682036100f357565b6084359067ffffffffffffffff821682036100f357565b6004359067ffffffffffffffff821682036100f357565b346100f35760a03660031901126100f3576103e261032b7f3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f6004356101a0816100f7565b602435906103cf6101af610117565b6064356101bb816100f7565b6101c361012e565b906101ea6101e2866001600160a01b03165f52600460205260405f2090565b548711610857565b61037e866103506001600160a01b03956102328761022a61021d8467ffffffffffffffff165f52600360205260405f2090565b546001600160a01b031690565b1615156108a3565b6040516bffffffffffffffffffffffff1933606090811b8216602084019081528c821b831660348501526048840187905288821b831660688501527fffffffffffffffff00000000000000000000000000000000000000000000000060c08b811b8216607c87015246901b1660848501523090911b909116608c83015260808252601f1992916102c360a082610924565b5190209c8d926102ee6102e86102e1865f52600260205260405f2090565b5460ff1690565b15610946565b604080516001600160a01b038e81166020830152918101889052908916606082015233608082015260a081019490945260c0908101845283610924565b61034a61021d8267ffffffffffffffff165f52600360205260405f2090565b90610f64565b946103736103668c5f52600260205260405f2090565b805460ff19166001179055565b309033908916610a84565b604051958695338a88939460c09567ffffffffffffffff94929998979360e087019a87526001600160a01b039384809216602089015216604087015260608601521660808401521660a08201520152565b0390a16040519081529081906020820190565b0390f35b346100f35760403660031901126100f3576103ff610145565b6024359061040c826100f7565b67ffffffffffffffff6001600160a01b039161042d83600154163314610992565b165f52600360205260405f20911673ffffffffffffffffffffffffffffffffffffffff198254161790555f80f35b346100f3575f3660031901126100f35760206001600160a01b035f5416604051908152f35b346100f35760203660031901126100f3576001600160a01b036004356104a5816100f7565b165f526004602052602060405f2054604051908152f35b9181601f840112156100f35782359167ffffffffffffffff83116100f3576020808501948460051b0101116100f357565b346100f3576040806003193601126100f35767ffffffffffffffff906004358281116100f3576105219036906004016104bc565b90926024359081116100f35761053b9036906004016104bc565b92906105536001600160a01b03600154163314610992565b838303610601575f5b83811061056557005b806105746105fc9287856109ff565b356105a261058b61058684898c6109ff565b610a23565b6001600160a01b03165f52600460205260405f2090565b557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba66105d261058683888b6109ff565b6105dd8389876109ff565b86516001600160a01b03929092168252356020820152604090a16109dd565b61055c565b815162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b346100f3575f806003193601126106b1578060015473ffffffffffffffffffffffffffffffffffffffff196001600160a01b03821691610686338414610992565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b346100f3575f3660031901126100f35760206001600160a01b0360015416604051908152f35b346100f35760803660031901126100f3576106f3610145565b60243590610700826100f7565b6044359067ffffffffffffffff908183116100f357366023840112156100f35782600401359182116100f35736602483850101116100f3576103e29360246107529461074a610108565b500191610cf7565b60405190151581529081906020820190565b346100f35760203660031901126100f35767ffffffffffffffff610786610145565b165f52600360205260206001600160a01b0360405f205416604051908152f35b346100f35760203660031901126100f3576004356107c3816100f7565b6001600160a01b036107da81600154163314610992565b8116156107ec576107ea90610a30565b005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b1561085e57565b60405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c000000000000000000000000000000006044820152606490fd5b156108aa57565b60405162461bcd60e51b815260206004820152601260248201527f696e76616c6964206d696e7420636861696e00000000000000000000000000006044820152606490fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff82111761091f57604052565b6108ef565b90601f8019910116810190811067ffffffffffffffff82111761091f57604052565b1561094d57565b60405162461bcd60e51b815260206004820152600d60248201527f7265636f726420657869737473000000000000000000000000000000000000006044820152606490fd5b1561099957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f1981146109eb5760010190565b634e487b7160e01b5f52601160045260245ffd5b9190811015610a0f5760051b0190565b634e487b7160e01b5f52603260045260245ffd5b35610a2d816100f7565b90565b600154906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b9290604051926323b872dd60e01b60208501526001600160a01b03809216602485015216604483015260648201526064815260a081019181831067ffffffffffffffff84111761091f5761011592604052610b64565b908160209103126100f3575180151581036100f35790565b15610af957565b60405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b03169060405190610b7b82610903565b6020928383527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656484840152803b15610bf1575f8281928287610bcc9796519301915af1610bc6610c36565b90610cb3565b80519081610bd957505050565b8261011593610bec938301019101610ada565b610af2565b60405162461bcd60e51b815260048101859052601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b3d15610c70573d9067ffffffffffffffff821161091f5760405191610c65601f8201601f191660200184610924565b82523d5f602084013e565b606090565b91908251928382525f5b848110610c9f575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201610c7f565b90919015610cbf575090565b815115610ccf5750805190602001fd5b60405162461bcd60e51b815260206004820152908190610cf3906024830190610c75565b0390fd5b9291926001600160a01b0390815f54163303610d7f5767ffffffffffffffff165f5260036020528060405f205416911603610d3a57610d3591610dc4565b600190565b60405162461bcd60e51b815260206004820152601f60248201527f73656e646572206973206e6f742072656d6f74652070656720627269646765006044820152606490fd5b60405162461bcd60e51b815260206004820152601c60248201527f63616c6c6572206973206e6f74206d65737361676520627269646765000000006044820152606490fd5b908160a091810103126100f357807fc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c4829569135610dfe816100f7565b610f1e6020830135604084013592610e15846100f7565b6080606086013595610e26876100f7565b0135906001600160a01b038080921695169516916040516020810190610ea881610e9a8a8789888d30948a949193609096936bffffffffffffffffffffffff19809681809560601b16895260601b166014880152602887015260601b166048850152605c84015260601b16607c8201520190565b03601f198101835282610924565b51902094610ec46102e86102e1885f52600260205260405f2090565b610ed9610366875f52600260205260405f2090565b610ee4828883610f23565b604080519687526001600160a01b039788166020880152908716908601526060850152608084015290921660a082015290819060c0820190565b0390a1565b60405163a9059cbb60e01b60208201526001600160a01b0392909216602483015260448083019390935291815261011591610f5f606483610924565b610b64565b91906020906001600160a01b039267ffffffffffffffff5f8096610fb7878354169460405198899788968795635c85c1a960e11b8752166004860152166024840152606060448401526064830190610c75565b03925af1918215610ffd578092610fcd57505090565b9091506020823d8211610ff5575b81610fe860209383610924565b810103126106b157505190565b3d9150610fdb565b604051903d90823e3d90fdfea26469706673582212203907d6666e07c262416e7ffc7af8ed83174676aabebb4a743bbe2f9ae718409664736f6c63430008140033",
}

// TokenVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use TokenVaultMetaData.ABI instead.
var TokenVaultABI = TokenVaultMetaData.ABI

// TokenVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TokenVaultMetaData.Bin instead.
var TokenVaultBin = TokenVaultMetaData.Bin

// DeployTokenVault deploys a new Ethereum contract, binding an instance of TokenVault to it.
func DeployTokenVault(auth *bind.TransactOpts, backend bind.ContractBackend, _messageBridge common.Address) (common.Address, *types.Transaction, *TokenVault, error) {
	parsed, err := TokenVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TokenVaultBin), backend, _messageBridge)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenVault{TokenVaultCaller: TokenVaultCaller{contract: contract}, TokenVaultTransactor: TokenVaultTransactor{contract: contract}, TokenVaultFilterer: TokenVaultFilterer{contract: contract}}, nil
}

// TokenVault is an auto generated Go binding around an Ethereum contract.
type TokenVault struct {
	TokenVaultCaller     // Read-only binding to the contract
	TokenVaultTransactor // Write-only binding to the contract
	TokenVaultFilterer   // Log filterer for contract events
}

// TokenVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenVaultSession struct {
	Contract     *TokenVault       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenVaultCallerSession struct {
	Contract *TokenVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TokenVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenVaultTransactorSession struct {
	Contract     *TokenVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TokenVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenVaultRaw struct {
	Contract *TokenVault // Generic contract binding to access the raw methods on
}

// TokenVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenVaultCallerRaw struct {
	Contract *TokenVaultCaller // Generic read-only contract binding to access the raw methods on
}

// TokenVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenVaultTransactorRaw struct {
	Contract *TokenVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenVault creates a new instance of TokenVault, bound to a specific deployed contract.
func NewTokenVault(address common.Address, backend bind.ContractBackend) (*TokenVault, error) {
	contract, err := bindTokenVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenVault{TokenVaultCaller: TokenVaultCaller{contract: contract}, TokenVaultTransactor: TokenVaultTransactor{contract: contract}, TokenVaultFilterer: TokenVaultFilterer{contract: contract}}, nil
}

// NewTokenVaultCaller creates a new read-only instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultCaller(address common.Address, caller bind.ContractCaller) (*TokenVaultCaller, error) {
	contract, err := bindTokenVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenVaultCaller{contract: contract}, nil
}

// NewTokenVaultTransactor creates a new write-only instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenVaultTransactor, error) {
	contract, err := bindTokenVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenVaultTransactor{contract: contract}, nil
}

// NewTokenVaultFilterer creates a new log filterer instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenVaultFilterer, error) {
	contract, err := bindTokenVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenVaultFilterer{contract: contract}, nil
}

// bindTokenVault binds a generic wrapper to an already deployed contract.
func bindTokenVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TokenVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenVault *TokenVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenVault.Contract.TokenVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenVault *TokenVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.Contract.TokenVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenVault *TokenVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenVault.Contract.TokenVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenVault *TokenVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenVault *TokenVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenVault *TokenVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenVault.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultSession) MessageBridge() (common.Address, error) {
	return _TokenVault.Contract.MessageBridge(&_TokenVault.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultCallerSession) MessageBridge() (common.Address, error) {
	return _TokenVault.Contract.MessageBridge(&_TokenVault.CallOpts)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultCaller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _TokenVault.Contract.MinDeposit(&_TokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultCallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _TokenVault.Contract.MinDeposit(&_TokenVault.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultSession) Owner() (common.Address, error) {
	return _TokenVault.Contract.Owner(&_TokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultCallerSession) Owner() (common.Address, error) {
	return _TokenVault.Contract.Owner(&_TokenVault.CallOpts)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultSession) Records(arg0 [32]byte) (bool, error) {
	return _TokenVault.Contract.Records(&_TokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _TokenVault.Contract.Records(&_TokenVault.CallOpts, arg0)
}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultCaller) RemotePegBridges(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "remotePegBridges", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultSession) RemotePegBridges(arg0 uint64) (common.Address, error) {
	return _TokenVault.Contract.RemotePegBridges(&_TokenVault.CallOpts, arg0)
}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultCallerSession) RemotePegBridges(arg0 uint64) (common.Address, error) {
	return _TokenVault.Contract.RemotePegBridges(&_TokenVault.CallOpts, arg0)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultTransactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.Contract.Deposit(&_TokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultTransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.Contract.Deposit(&_TokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.ExecuteMessage(&_TokenVault.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.ExecuteMessage(&_TokenVault.TransactOpts, srcChainId, sender, message, executor)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenVault.Contract.RenounceOwnership(&_TokenVault.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenVault.Contract.RenounceOwnership(&_TokenVault.TransactOpts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultTransactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.Contract.SetMinDeposit(&_TokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultTransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.Contract.SetMinDeposit(&_TokenVault.TransactOpts, _tokens, _amounts)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultTransactor) SetRemotePegBridge(opts *bind.TransactOpts, _remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "setRemotePegBridge", _remoteChainId, _remotePegBridge)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultSession) SetRemotePegBridge(_remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.SetRemotePegBridge(&_TokenVault.TransactOpts, _remoteChainId, _remotePegBridge)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultTransactorSession) SetRemotePegBridge(_remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.SetRemotePegBridge(&_TokenVault.TransactOpts, _remoteChainId, _remotePegBridge)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.TransferOwnership(&_TokenVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.TransferOwnership(&_TokenVault.TransactOpts, newOwner)
}

// TokenVaultDepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the TokenVault contract.
type TokenVaultDepositedIterator struct {
	Event *TokenVaultDeposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultDepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultDeposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultDeposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultDepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultDepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultDeposited represents a Deposited event raised by the TokenVault contract.
type TokenVaultDeposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintAccount common.Address
	Nonce       uint64
	MessageId   [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) FilterDeposited(opts *bind.FilterOpts) (*TokenVaultDepositedIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &TokenVaultDepositedIterator{contract: _TokenVault.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *TokenVaultDeposited) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultDeposited)
				if err := _TokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) ParseDeposited(log types.Log) (*TokenVaultDeposited, error) {
	event := new(TokenVaultDeposited)
	if err := _TokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultMinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the TokenVault contract.
type TokenVaultMinDepositUpdatedIterator struct {
	Event *TokenVaultMinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultMinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultMinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultMinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultMinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultMinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultMinDepositUpdated represents a MinDepositUpdated event raised by the TokenVault contract.
type TokenVaultMinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*TokenVaultMinDepositUpdatedIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &TokenVaultMinDepositUpdatedIterator{contract: _TokenVault.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *TokenVaultMinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultMinDepositUpdated)
				if err := _TokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) ParseMinDepositUpdated(log types.Log) (*TokenVaultMinDepositUpdated, error) {
	event := new(TokenVaultMinDepositUpdated)
	if err := _TokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TokenVault contract.
type TokenVaultOwnershipTransferredIterator struct {
	Event *TokenVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultOwnershipTransferred represents a OwnershipTransferred event raised by the TokenVault contract.
type TokenVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TokenVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TokenVaultOwnershipTransferredIterator{contract: _TokenVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TokenVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultOwnershipTransferred)
				if err := _TokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) ParseOwnershipTransferred(log types.Log) (*TokenVaultOwnershipTransferred, error) {
	event := new(TokenVaultOwnershipTransferred)
	if err := _TokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultWithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the TokenVault contract.
type TokenVaultWithdrawnIterator struct {
	Event *TokenVaultWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultWithdrawn represents a Withdrawn event raised by the TokenVault contract.
type TokenVaultWithdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) FilterWithdrawn(opts *bind.FilterOpts) (*TokenVaultWithdrawnIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &TokenVaultWithdrawnIterator{contract: _TokenVault.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *TokenVaultWithdrawn) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultWithdrawn)
				if err := _TokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) ParseWithdrawn(log types.Log) (*TokenVaultWithdrawn, error) {
	event := new(TokenVaultWithdrawn)
	if err := _TokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxMetaData contains all meta data concerning the Tx contract.
var TxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"}],\"name\":\"decodeTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"internalType\":\"structTx.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001a57610e3a908161001f823930815050f35b5f80fdfe6040608081526004361015610012575f80fd5b5f90813560e01c63dae029d314610027575f80fd5b602090816003193601126103d55767ffffffffffffffff916004358381116103d157366023820112156103d15780600401359384116103d157602481019060248536920101116103d1576102e4946102da926102c992610085610526565b9660ff926100ba6002856100b36100ad61009f8789610591565b356001600160f81b03191690565b60f81c90565b16146105ae565b6100df6100da6100d56100ce8580886105fa565b36916106a7565b6109ff565b610a66565b926101136101056100f86100f2876106dd565b51610b79565b67ffffffffffffffff1690565b67ffffffffffffffff168b52565b6101356101256100f86100f2876106ea565b67ffffffffffffffff168b840152565b6101416100f2856106fa565b898b01526101516100f28561070a565b60608b01526101626100f28561071a565b60808b015261018c61017c6101768661072a565b51610b5b565b6001600160a01b031660a08c0152565b6101986100f28561073a565b60c08b01526101af6101a98561074a565b51610be7565b60e08b01526101c96101c36100f28661075b565b60ff1690565b956101ed6101e26101a96101e76101e26101a98a61076c565b6107a2565b9761077d565b958a6102076102026100ad61009f898861059f565b6107d8565b9582871660010361039b576102336101c361022e6100ad610228858a610637565b90610865565b6107f0565b965b61ffff8816603781116102e85750506102bd939261029d8761028f6102b5958561028961027a6102686102a5998e610648565b9d909361027481610891565b91610656565b929093519c8d968701916108f8565b916108f8565b03601f1981018852876104f5565b859716610814565b60f81b6001600160f81b03191690565b901a91610971565b535b8151910120610981565b6001600160a01b0316610100840152565b5191829182610417565b0390f35b909697945083959391925011155f146103615761035b93828261031d61031761009f61032f9661034d98610591565b98610803565b9261032782610891565b931691610673565b8c5195869491929160f81b6001600160f81b03191690888601610940565b03601f1981018352826104f5565b906102bf565b61035b93828261031d61031761009f61037d9661034d98610591565b8c5195869491929160f01b6001600160f01b03191690888601610905565b6103cb6103c66103c06103ba6103b36101c38c610803565b858a61061a565b90610825565b60f01c90565b610851565b96610235565b8480fd5b8280fd5b91908251928382525f5b848110610403575050825f602080949584010152601f8019910116010190565b6020818301810151848301820152016103e3565b6104bd906020815261043660208201845167ffffffffffffffff169052565b602083015167ffffffffffffffff1660408201526040830151606082015260608301516080820152608083015160a082015261048260a084015160c08301906001600160a01b03169052565b60c083015160e082015260e0830151610120906104ac6101009183838601526101408501906103d9565b9401516001600160a01b0316910152565b90565b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176104f057604052565b6104c0565b90601f8019910116810190811067ffffffffffffffff8211176104f057604052565b60405190610524826104d4565b565b60405190610120820182811067ffffffffffffffff8211176104f057604052816101005f918281528260208201528260408201528260608201528260808201528260a08201528260c0820152606060e08201520152565b634e487b7160e01b5f52603260045260245ffd5b901561059a5790565b61057d565b906001101561059a5760010190565b156105b557565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b909291928360011161061657831161061657600101915f190190565b5f80fd5b909291928360021161061657831161061657600201916001190190565b906003116106165760020190600190565b906002116106165790600290565b909291928360031161061657831161061657600301916002190190565b90939293848311610616578411610616578101920390565b67ffffffffffffffff81116104f057601f01601f191660200190565b9291926106b38261068b565b916106c160405193846104f5565b829481845281830111610616578281602093845f960137010152565b80511561059a5760200190565b80516001101561059a5760400190565b80516002101561059a5760600190565b80516003101561059a5760800190565b80516004101561059a5760a00190565b80516005101561059a5760c00190565b80516006101561059a5760e00190565b80516007101561059a576101000190565b80516009101561059a576101400190565b8051600a101561059a576101600190565b8051600b101561059a576101800190565b805182101561059a5760209160051b010190565b6020815191015190602081106107b6575090565b5f199060200360031b1b1690565b634e487b7160e01b5f52601160045260245ffd5b60ff60f6199116019060ff82116107eb57565b6107c4565b60ff6042199116019060ff82116107eb57565b60ff166002019060ff82116107eb57565b60ff1660c0019060ff82116107eb57565b6001600160f01b0319903581811693926002811061084257505050565b60020360031b82901b16169150565b61ffff90811660421901919082116107eb57565b6001600160f81b0319903581811693926001811061088257505050565b60010360031b82901b16169150565b6042198101919082116107eb57565b60bf198101919082116107eb57565b607f198101919082116107eb57565b60200390602082116107eb57565b5f198101919082116107eb57565b60f6198101919082116107eb57565b60b6198101919082116107eb57565b908092918237015f815290565b6001600160f81b0319909116815260f960f81b60018201526001600160f01b031990911660028201526004929182908483013701015f815290565b6001600160f81b03199182168152601f60fb1b6001820152911660028201526003929182908483013701015f815290565b80516001101561059a5760210190565b919260ff8116601b81106109cd575b509160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa156109c2575f5190565b6040513d5f823e3d90fd5b601b9150929192019060ff82116107eb5791906020610990565b604051906109f4826104d4565b5f6020838281520152565b610a076109e7565b50602081519160405192610a1a846104d4565b835201602082015290565b67ffffffffffffffff81116104f05760051b60200190565b90600182018092116107eb57565b919082018092116107eb57565b5f1981146107eb5760010190565b610a6f81610b37565b1561061657610a7d81610c34565b610a8681610a25565b91610a9460405193846104f5565b818352601f19610aa383610a25565b015f5b818110610b20575050610ac7602080920151610ac181610d1a565b90610a4b565b5f905b838210610ad8575050505090565b610b1481610ae8610b1a93610c95565b90610af1610517565b8281528187820152610b03868a61078e565b52610b0e858961078e565b50610a4b565b91610a58565b90610aca565b602090610b2b6109e7565b82828801015201610aa6565b805115610b5657602060c0910151515f1a10610b5257600190565b5f90565b505f90565b601581510361061657610b756001600160a01b0391610b79565b1690565b80518015159081610baf575b501561061657610b9490610bbb565b90519060208110610ba3575090565b6020036101000a900490565b6021915011155f610b85565b906020820191610bcb8351610d1a565b9251908382018092116107eb57519283039283116107eb579190565b80511561061657610bfa6104bd91610bbb565b610c068193929361068b565b92610c1460405194856104f5565b818452601f19610c238361068b565b013660208601378360200190610d87565b805115610b56575f9060208101908151610c4d81610d1a565b81018091116107eb579151905181018091116107eb5791905b828110610c735750905090565b610c7c81610c95565b81018091116107eb57610c8f9091610a58565b90610c66565b80515f1a906080821015610caa575050600190565b60b8821015610cc55750610cc06104bd916108af565b610a3d565b9060c0811015610ce95760b51991600160b783602003016101000a91015104010190565b9060f8821015610d005750610cc06104bd916108a0565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015610d2b57505f90565b60b881108015610d62575b15610d415750600190565b60c0811015610d5657610cc06104bd916108e9565b610cc06104bd916108da565b5060c08110158015610d36575060f88110610d36565b601f81116107eb576101000a90565b929091928315610dfe5792915b602093848410610dc957805182528481018091116107eb579381018091116107eb5791601f1981019081116107eb5791610d94565b9193509180610dd757505050565b610deb610de6610df0926108be565b610d78565b6108cc565b905182518216911916179052565b5091505056fea2646970667358221220b07f4753f140ef3ceac626d63e3ee7ceb25826b409ce6e8a7e8392d0ff758cf364736f6c63430008140033",
}

// TxABI is the input ABI used to generate the binding from.
// Deprecated: Use TxMetaData.ABI instead.
var TxABI = TxMetaData.ABI

// TxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TxMetaData.Bin instead.
var TxBin = TxMetaData.Bin

// DeployTx deploys a new Ethereum contract, binding an instance of Tx to it.
func DeployTx(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Tx, error) {
	parsed, err := TxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TxBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Tx{TxCaller: TxCaller{contract: contract}, TxTransactor: TxTransactor{contract: contract}, TxFilterer: TxFilterer{contract: contract}}, nil
}

// Tx is an auto generated Go binding around an Ethereum contract.
type Tx struct {
	TxCaller     // Read-only binding to the contract
	TxTransactor // Write-only binding to the contract
	TxFilterer   // Log filterer for contract events
}

// TxCaller is an auto generated read-only Go binding around an Ethereum contract.
type TxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TxSession struct {
	Contract     *Tx               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TxCallerSession struct {
	Contract *TxCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// TxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TxTransactorSession struct {
	Contract     *TxTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxRaw is an auto generated low-level Go binding around an Ethereum contract.
type TxRaw struct {
	Contract *Tx // Generic contract binding to access the raw methods on
}

// TxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TxCallerRaw struct {
	Contract *TxCaller // Generic read-only contract binding to access the raw methods on
}

// TxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TxTransactorRaw struct {
	Contract *TxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTx creates a new instance of Tx, bound to a specific deployed contract.
func NewTx(address common.Address, backend bind.ContractBackend) (*Tx, error) {
	contract, err := bindTx(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Tx{TxCaller: TxCaller{contract: contract}, TxTransactor: TxTransactor{contract: contract}, TxFilterer: TxFilterer{contract: contract}}, nil
}

// NewTxCaller creates a new read-only instance of Tx, bound to a specific deployed contract.
func NewTxCaller(address common.Address, caller bind.ContractCaller) (*TxCaller, error) {
	contract, err := bindTx(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TxCaller{contract: contract}, nil
}

// NewTxTransactor creates a new write-only instance of Tx, bound to a specific deployed contract.
func NewTxTransactor(address common.Address, transactor bind.ContractTransactor) (*TxTransactor, error) {
	contract, err := bindTx(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TxTransactor{contract: contract}, nil
}

// NewTxFilterer creates a new log filterer instance of Tx, bound to a specific deployed contract.
func NewTxFilterer(address common.Address, filterer bind.ContractFilterer) (*TxFilterer, error) {
	contract, err := bindTx(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TxFilterer{contract: contract}, nil
}

// bindTx binds a generic wrapper to an already deployed contract.
func bindTx(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Tx *TxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Tx.Contract.TxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Tx *TxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Tx.Contract.TxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Tx *TxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Tx.Contract.TxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Tx *TxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Tx.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Tx *TxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Tx.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Tx *TxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Tx.Contract.contract.Transact(opts, method, params...)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxCaller) DecodeTx(opts *bind.CallOpts, txRaw []byte) (TxTxInfo, error) {
	var out []interface{}
	err := _Tx.contract.Call(opts, &out, "decodeTx", txRaw)

	if err != nil {
		return *new(TxTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(TxTxInfo)).(*TxTxInfo)

	return out0, err

}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxSession) DecodeTx(txRaw []byte) (TxTxInfo, error) {
	return _Tx.Contract.DecodeTx(&_Tx.CallOpts, txRaw)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxCallerSession) DecodeTx(txRaw []byte) (TxTxInfo, error) {
	return _Tx.Contract.DecodeTx(&_Tx.CallOpts, txRaw)
}

// TxVerifierMetaData contains all meta data concerning the TxVerifier contract.
var TxVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedTx\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"}],\"name\":\"decodeTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTxAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f611ce038819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36002541617600255611c2390816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f803560e01c9081631eeb86da146100a757508063361108de146100a2578063724796ed1461009d5780638da5cb5b14610098578063a8da8d6914610093578063dae029d31461008e578063ec4ffc5214610089578063f2fde38b146100845763f5cec6af1461007f575f80fd5b6105e8565b6104fe565b61045c565b610408565b6103dc565b6103b7565b610391565b610306565b34610124576020366003190112610124577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a9860206100e3610127565b6001600160a01b03906100fa82865416331461062a565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a180f35b80fd5b600435906001600160a01b038216820361013d57565b5f80fd5b9181601f8401121561013d5782359167ffffffffffffffff831161013d576020838186019501011161013d57565b90606060031983011261013d5767ffffffffffffffff60043581811161013d578361019c91600401610141565b9390939260243583811161013d57826101b791600401610141565b9390939260443591821161013d576101d191600401610141565b9091565b5f5b8381106101e65750505f910152565b81810151838201526020016101d7565b9060209161020f815180928185528580860191016101d5565b601f01601f1916010190565b610303906020815261023a60208201845167ffffffffffffffff169052565b602083015167ffffffffffffffff1660408201526040830151606082015260608301516080820152608083015160a082015261028660a084015160c08301906001600160a01b03169052565b60c083015160e082015260e083015192610180906102b16101009583878601526101a08501906101f6565b948101516102cd61012091828601906001600160a01b03169052565b8101516102e5610140918286019063ffffffff169052565b81015161016084810191909152015167ffffffffffffffff16910152565b90565b3461013d5761038d61036f7fe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888604061035a6103403661016f565b926103529995999694969291926106fb565b50868a61097e565b9467ffffffffffffffff865116923691610783565b6020815191012082519182526020820152a16040519182918261021b565b0390f35b3461013d575f36600319011261013d5760206001600160a01b0360025416604051908152f35b3461013d575f36600319011261013d5760206001600160a01b035f5416604051908152f35b3461013d5761038d6103fc6103f03661016f565b9493909392919261097e565b6040519182918261021b565b3461013d57602036600319011261013d5760043567ffffffffffffffff811161013d576103fc61043f61038d923690600401610141565b9061117e565b6004359067ffffffffffffffff8216820361013d57565b3461013d57604036600319011261013d57610475610445565b602435906001600160a01b039182811680910361013d5767ffffffffffffffff6040926104c77ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f5416331461062a565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b3461013d57602036600319011261013d57610517610127565b5f908154906001600160a01b038083169161053333841461062a565b1691821561057d5773ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461013d57602036600319011261013d5767ffffffffffffffff61060a610445565b165f52600160205260206001600160a01b0360405f205416604051908152f35b1561063157565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176106a557604052565b610675565b90601f8019910116810190811067ffffffffffffffff8211176106a557604052565b6040519060c0820182811067ffffffffffffffff8211176106a557604052565b604051906106f982610689565b565b60405190610180820182811067ffffffffffffffff8211176106a557604052816101605f918281528260208201528260408201528260608201528260808201528260a08201528260c0820152606060e08201528261010082015282610120820152826101408201520152565b67ffffffffffffffff81116106a557601f01601f191660200190565b92919261078f82610767565b9161079d60405193846106aa565b82948184528183011161013d578281602093845f960137010152565b156107c057565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b908092918237015f815290565b602090836106f993959495604051968361083589955180928880890191016101d5565b84019185830137015f838201520380855201836106aa565b1561085457565b60405162461bcd60e51b815260206004820152601260248201527f6c65616648617368206e6f74206d6174636800000000000000000000000000006044820152606490fd5b9081602091031261013d5751801515810361013d5790565b91909161018081019267ffffffffffffffff815116825260a08063ffffffff926020938085830151168587015260408201516040870152606082015160608701526080820151166080860152015192015f905b600782106109125750505050565b82806001928651815201940191019092610904565b6040513d5f823e3d90fd5b1561093957565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b9093919594929561098d6106fb565b50610998858361117e565b96818189516109ae9067ffffffffffffffff1690565b916109b89261154b565b6109c1906107b9565b6109ca916116be565b936080850151916109da92610812565b9182516020809401208451146109ef9061084d565b6109f891610dea565b86519293919267ffffffffffffffff169060408601938451610a1d9063ffffffff1690565b9584880196875190610a2d6106cc565b67ffffffffffffffff909616865263ffffffff16858701526040850152606084015263ffffffff16608083015260a082015260025482906001600160a01b03166001600160a01b03166001600160a01b0316604051631513dce960e21b81529283919082908190610aa190600483016108b1565b03915afa908115610b3d576106f995610b0295610ad0610ae694606094610af8975f92610b10575b5050610932565b516101408a0152015167ffffffffffffffff1690565b67ffffffffffffffff16610160870152565b5163ffffffff1690565b63ffffffff16610120840152565b610b2f9250803d10610b36575b610b2781836106aa565b810190610899565b5f80610ac9565b503d610b1d565b610927565b15610b4957565b60405162461bcd60e51b815260206004820152601b60248201527f696e636f72726563742061757869426c6b566572696679496e666f00000000006044820152606490fd5b9060201161013d5790602090565b9060241161013d5760200190600490565b906101041161013d5760e40190602090565b909291928360011161013d57831161013d57600101915f190190565b909291928360021161013d57831161013d57600201916001190190565b9060031161013d5760020190600190565b9060021161013d5790600290565b909291928360031161013d57831161013d57600301916002190190565b906101601161013d576101400190602090565b906101801161013d576101700190601090565b906101a01161013d576101800190602090565b906101c01161013d576101b00190601090565b906101e01161013d576101dc0190600490565b906102001161013d576101f80190600890565b9291926102009184831161013d57841161013d5701916101ff190190565b9093929384831161013d57841161013d578101920390565b359060208110610cea575090565b5f199060200360031b1b1690565b7fffffffff000000000000000000000000000000000000000000000000000000009035818116939260048110610d2d57505050565b60040360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b60ff1660ff8114610d615760010190565b610d3c565b60051b90611fe060e0831692168203610d6157565b60ff166024019060ff8211610d6157565b60ff60019116019060ff8211610d6157565b60ff166002019060ff8211610d6157565b60ff1660c0019060ff8211610d6157565b634e487b7160e01b5f52603260045260245ffd5b906007811015610de55760051b0190565b610dc0565b916040519060e0820182811067ffffffffffffffff8211176106a55760405260e036833781610e1c6101048514610b42565b610e2f610e298587610b8e565b90610cdc565b93610e4c610e46610e408389610b9c565b90610cf8565b60e01c90565b945f5b60ff808216906006821015610eb15790610ea6610e9f610e2985948d89610e80610e7b610eac9a610d66565b610d7b565b9280610e96610e7b610e918c610d8c565b610d66565b16931691610cc4565b9189610dd4565b52610d50565b610e4f565b50505095610e2960c092610ec792969496610bad565b910152565b9015610de55790565b9060011015610de55760010190565b15610eeb57565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b805115610de55760200190565b805160011015610de55760400190565b805160021015610de55760600190565b805160031015610de55760800190565b805160041015610de55760a00190565b805160051015610de55760c00190565b805160061015610de55760e00190565b805160071015610de5576101000190565b805160091015610de5576101400190565b8051600a1015610de5576101600190565b8051600b1015610de5576101800190565b8051821015610de55760209160051b010190565b602081519101519060208110610cea575090565b60ff60f6199116019060ff8211610d6157565b60ff6042199116019060ff8211610d6157565b6001600160f01b0319903581811693926002811061104c57505050565b60020360031b82901b16169150565b61ffff9081166042190191908211610d6157565b6001600160f81b0319903581811693926001811061108c57505050565b60010360031b82901b16169150565b604219810191908211610d6157565b60bf19810191908211610d6157565b607f19810191908211610d6157565b6020039060208211610d6157565b5f19810191908211610d6157565b60f619810191908211610d6157565b60b619810191908211610d6157565b6001600160f81b0319909116815260f960f81b60018201526001600160f01b031990911660028201526004929182908483013701015f815290565b6001600160f81b03199182168152601f60fb1b6001820152911660028201526003929182908483013701015f815290565b805160011015610de55760210190565b91906113d46106f99161118f6106fb565b9460ff906111c46002836111bd6111b76111a98887610ecc565b356001600160f81b03191690565b60f81c90565b1614610ee4565b6111e96111e46111df6111d8868086610bbf565b3691610783565b6117e8565b61184f565b9061121d61120f6112026111fc85610f30565b51611962565b67ffffffffffffffff1690565b67ffffffffffffffff168952565b61124061122f6112026111fc85610f3d565b67ffffffffffffffff1660208a0152565b61124c6111fc83610f4d565b604089015261125d6111fc83610f5d565b606089015261126e6111fc83610f6d565b608089015261129861128861128284610f7d565b51611944565b6001600160a01b031660a08a0152565b6112a46111fc83610f8d565b60c08901526112bb6112b583610f9d565b516119d0565b60e08901526112d56112cf6111fc84610fae565b60ff1690565b936112f96112ee6112b56112f36112ee6112b588610fbf565b610ff5565b95610fd0565b9361131261130d6111b76111a98587610ed5565b611009565b928184166001036114935761133e6112cf6113396111b76113338786610bf8565b9061106f565b61101c565b935b61ffff8516603781116113e55750506113ae6113c6926113a68361139861137f61136d896113be98610c09565b9390996113798161109b565b91610c17565b6113926040519a8b956020870191610805565b91610805565b03601f1981018752866106aa565b849516610daf565b60f81b6001600160f81b03191690565b5f1a9161116e565b535b602081519101206114c9565b6001600160a01b0316610100840152565b909492939084106114575761145293828261141261140c6111a96114249661144498610ecc565b98610d9e565b9261141c8261109b565b931691610cc4565b60405195869491929160f81b6001600160f81b031916906020860161113d565b03601f1981018352826106aa565b6113c8565b61145293828261141261140c6111a96114739661144498610ecc565b60405195869491929160f01b6001600160f01b0319169060208601611102565b6114c36114be6114b86114b26114ab6112cf89610d9e565b8786610bdb565b9061102f565b60f01c90565b61105b565b93611340565b919260ff8116601b811061150a575b509160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa15610b3d575f5190565b601b9150929192019060ff8211610d6157919060206114d8565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b909167ffffffffffffffff82165f5260016020526001600160a01b0360405f20541615611600576115d3926115b66115aa6115aa61159d60209667ffffffffffffffff165f52600160205260405f2090565b546001600160a01b031690565b6001600160a01b031690565b906040518095819482936322bb937360e11b845260048401611524565b03915afa908115610b3d575f916115e8575090565b610303915060203d8111610b3657610b2781836106aa565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b6fffffffffffffffffffffffffffffffff19903581811693926010811061166b57505050565b60100360031b82901b16169150565b7fffffffffffffffff00000000000000000000000000000000000000000000000090358181169392600881106116af57505050565b60080360031b82901b16169150565b604051929160a0840167ffffffffffffffff8111858210176106a5576117cc916111d8916040525f86528060208701945f86526117c7604089015f815261179d60608b01915f835260808c019960608b528c611726611720610e298a8a610c34565b60801b90565b61175a61174561173f6117398c8c610c47565b90611645565b60801c90565b6fffffffffffffffffffffffffffffffff1690565b17905261176d611720610e298989610c5a565b61178061174561173f6117398b8b610c6d565b179052611793610e46610e408888610c80565b63ffffffff169052565b6117b96117b36117ad8686610c93565b9061167a565b60c01c90565b67ffffffffffffffff169052565b610ca6565b9052565b604051906117dd82610689565b5f6020838281520152565b6117f06117d0565b5060208151916040519261180384610689565b835201602082015290565b67ffffffffffffffff81116106a55760051b60200190565b9060018201809211610d6157565b91908201809211610d6157565b5f198114610d615760010190565b61185881611920565b1561013d5761186681611a1d565b61186f8161180e565b9161187d60405193846106aa565b818352601f1961188c8361180e565b015f5b8181106119095750506118b06020809201516118aa81611b03565b90611834565b5f905b8382106118c1575050505090565b6118fd816118d161190393611a7e565b906118da6106ec565b82815281878201526118ec868a610fe1565b526118f78589610fe1565b50611834565b91611841565b906118b3565b6020906119146117d0565b8282880101520161188f565b80511561193f57602060c0910151515f1a1061193b57600190565b5f90565b505f90565b601581510361013d5761195e6001600160a01b0391611962565b1690565b80518015159081611998575b501561013d5761197d906119a4565b9051906020811061198c575090565b6020036101000a900490565b6021915011155f61196e565b9060208201916119b48351611b03565b925190838201809211610d615751928303928311610d61579190565b80511561013d576119e3610303916119a4565b6119ef81939293610767565b926119fd60405194856106aa565b818452601f19611a0c83610767565b013660208601378360200190611b70565b80511561193f575f9060208101908151611a3681611b03565b8101809111610d6157915190518101809111610d615791905b828110611a5c5750905090565b611a6581611a7e565b8101809111610d6157611a789091611841565b90611a4f565b80515f1a906080821015611a93575050600190565b60b8821015611aae5750611aa9610303916110b9565b611826565b9060c0811015611ad25760b51991600160b783602003016101000a91015104010190565b9060f8821015611ae95750611aa9610303916110aa565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015611b1457505f90565b60b881108015611b4b575b15611b2a5750600190565b60c0811015611b3f57611aa9610303916110f3565b611aa9610303916110e4565b5060c08110158015611b1f575060f88110611b1f565b601f8111610d61576101000a90565b929091928315611be75792915b602093848410611bb25780518252848101809111610d6157938101809111610d615791601f198101908111610d615791611b7d565b9193509180611bc057505050565b611bd4611bcf611bd9926110c8565b611b61565b6110d6565b905182518216911916179052565b5091505056fea264697066735822122097da30c2dcd75a565c3afd1ba791bef4b5d8384668c492f1b770916dc96cd7dc64736f6c63430008140033",
}

// TxVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use TxVerifierMetaData.ABI instead.
var TxVerifierABI = TxVerifierMetaData.ABI

// TxVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TxVerifierMetaData.Bin instead.
var TxVerifierBin = TxVerifierMetaData.Bin

// DeployTxVerifier deploys a new Ethereum contract, binding an instance of TxVerifier to it.
func DeployTxVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blockChunks common.Address) (common.Address, *types.Transaction, *TxVerifier, error) {
	parsed, err := TxVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TxVerifierBin), backend, _blockChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TxVerifier{TxVerifierCaller: TxVerifierCaller{contract: contract}, TxVerifierTransactor: TxVerifierTransactor{contract: contract}, TxVerifierFilterer: TxVerifierFilterer{contract: contract}}, nil
}

// TxVerifier is an auto generated Go binding around an Ethereum contract.
type TxVerifier struct {
	TxVerifierCaller     // Read-only binding to the contract
	TxVerifierTransactor // Write-only binding to the contract
	TxVerifierFilterer   // Log filterer for contract events
}

// TxVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type TxVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TxVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TxVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TxVerifierSession struct {
	Contract     *TxVerifier       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TxVerifierCallerSession struct {
	Contract *TxVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TxVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TxVerifierTransactorSession struct {
	Contract     *TxVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TxVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type TxVerifierRaw struct {
	Contract *TxVerifier // Generic contract binding to access the raw methods on
}

// TxVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TxVerifierCallerRaw struct {
	Contract *TxVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// TxVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TxVerifierTransactorRaw struct {
	Contract *TxVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTxVerifier creates a new instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifier(address common.Address, backend bind.ContractBackend) (*TxVerifier, error) {
	contract, err := bindTxVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TxVerifier{TxVerifierCaller: TxVerifierCaller{contract: contract}, TxVerifierTransactor: TxVerifierTransactor{contract: contract}, TxVerifierFilterer: TxVerifierFilterer{contract: contract}}, nil
}

// NewTxVerifierCaller creates a new read-only instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierCaller(address common.Address, caller bind.ContractCaller) (*TxVerifierCaller, error) {
	contract, err := bindTxVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TxVerifierCaller{contract: contract}, nil
}

// NewTxVerifierTransactor creates a new write-only instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*TxVerifierTransactor, error) {
	contract, err := bindTxVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TxVerifierTransactor{contract: contract}, nil
}

// NewTxVerifierFilterer creates a new log filterer instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*TxVerifierFilterer, error) {
	contract, err := bindTxVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TxVerifierFilterer{contract: contract}, nil
}

// bindTxVerifier binds a generic wrapper to an already deployed contract.
func bindTxVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TxVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TxVerifier *TxVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TxVerifier.Contract.TxVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TxVerifier *TxVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TxVerifier.Contract.TxVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TxVerifier *TxVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TxVerifier.Contract.TxVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TxVerifier *TxVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TxVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TxVerifier *TxVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TxVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TxVerifier *TxVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TxVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "blockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierSession) BlockChunks() (common.Address, error) {
	return _TxVerifier.Contract.BlockChunks(&_TxVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _TxVerifier.Contract.BlockChunks(&_TxVerifier.CallOpts)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCaller) DecodeTx(opts *bind.CallOpts, txRaw []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "decodeTx", txRaw)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) DecodeTx(txRaw []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.DecodeTx(&_TxVerifier.CallOpts, txRaw)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCallerSession) DecodeTx(txRaw []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.DecodeTx(&_TxVerifier.CallOpts, txRaw)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierSession) Owner() (common.Address, error) {
	return _TxVerifier.Contract.Owner(&_TxVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierCallerSession) Owner() (common.Address, error) {
	return _TxVerifier.Contract.Owner(&_TxVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _TxVerifier.Contract.VerifierAddresses(&_TxVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _TxVerifier.Contract.VerifierAddresses(&_TxVerifier.CallOpts, arg0)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCaller) VerifyTx(opts *bind.CallOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "verifyTx", txRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.VerifyTx(&_TxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCallerSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.VerifyTx(&_TxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.TransferOwnership(&_TxVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.TransferOwnership(&_TxVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "updateBlockChunks", _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateBlockChunks(&_TxVerifier.TransactOpts, _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierTransactorSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateBlockChunks(&_TxVerifier.TransactOpts, _blockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateVerifierAddress(&_TxVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateVerifierAddress(&_TxVerifier.TransactOpts, _chainId, _verifierAddress)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierTransactor) VerifyTxAndLog(opts *bind.TransactOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "verifyTxAndLog", txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.Contract.VerifyTxAndLog(&_TxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierTransactorSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.Contract.VerifyTxAndLog(&_TxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// TxVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TxVerifier contract.
type TxVerifierOwnershipTransferredIterator struct {
	Event *TxVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the TxVerifier contract.
type TxVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TxVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TxVerifierOwnershipTransferredIterator{contract: _TxVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TxVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierOwnershipTransferred)
				if err := _TxVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*TxVerifierOwnershipTransferred, error) {
	event := new(TxVerifierOwnershipTransferred)
	if err := _TxVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the TxVerifier contract.
type TxVerifierUpdateBlockChunksIterator struct {
	Event *TxVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the TxVerifier contract.
type TxVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*TxVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &TxVerifierUpdateBlockChunksIterator{contract: _TxVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *TxVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierUpdateBlockChunks)
				if err := _TxVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*TxVerifierUpdateBlockChunks, error) {
	event := new(TxVerifierUpdateBlockChunks)
	if err := _TxVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the TxVerifier contract.
type TxVerifierUpdateVerifierAddressIterator struct {
	Event *TxVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the TxVerifier contract.
type TxVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*TxVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &TxVerifierUpdateVerifierAddressIterator{contract: _TxVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *TxVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierUpdateVerifierAddress)
				if err := _TxVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*TxVerifierUpdateVerifierAddress, error) {
	event := new(TxVerifierUpdateVerifierAddress)
	if err := _TxVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierVerifiedTxIterator is returned from FilterVerifiedTx and is used to iterate over the raw logs and unpacked data for VerifiedTx events raised by the TxVerifier contract.
type TxVerifierVerifiedTxIterator struct {
	Event *TxVerifierVerifiedTx // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierVerifiedTxIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierVerifiedTx)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierVerifiedTx)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierVerifiedTxIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierVerifiedTxIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierVerifiedTx represents a VerifiedTx event raised by the TxVerifier contract.
type TxVerifierVerifiedTx struct {
	ChainId uint64
	TxHash  [32]byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterVerifiedTx is a free log retrieval operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) FilterVerifiedTx(opts *bind.FilterOpts) (*TxVerifierVerifiedTxIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "VerifiedTx")
	if err != nil {
		return nil, err
	}
	return &TxVerifierVerifiedTxIterator{contract: _TxVerifier.contract, event: "VerifiedTx", logs: logs, sub: sub}, nil
}

// WatchVerifiedTx is a free log subscription operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) WatchVerifiedTx(opts *bind.WatchOpts, sink chan<- *TxVerifierVerifiedTx) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "VerifiedTx")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierVerifiedTx)
				if err := _TxVerifier.contract.UnpackLog(event, "VerifiedTx", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedTx is a log parse operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) ParseVerifiedTx(log types.Log) (*TxVerifierVerifiedTx, error) {
	event := new(TxVerifierVerifiedTx)
	if err := _TxVerifier.contract.UnpackLog(event, "VerifiedTx", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeMetaData contains all meta data concerning the UniswapSumVolume contract.
var UniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"fromChain\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"}],\"name\":\"SumVolume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contractISMT\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"UpdateSmtContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batchTierVkHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"hashes\",\"type\":\"bytes\"}],\"name\":\"setBatchTierVkHashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"submitUniswapSumVolumeProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"volumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f610be838819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36009541617600955610b2b90816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c9081631396511e146109685781633221aec6146109405781633f220b9414610914578163715018a6146108b45781638d35aa9d146104215781638da5cb5b146103fb578163950650c1146103c4578163b1ec4c40146103c4578163bd88d14614610261578163ec4ffc52146101c9578163f2fde38b146100e7575063f5cec6af146100a4575f80fd5b346100e35760203660031901126100e3576001600160a01b038160209367ffffffffffffffff6100d26109db565b168152600885522054169051908152f35b5080fd5b9050346101c55760203660031901126101c557610102610a24565b908354906001600160a01b038083169361011d338614610aaa565b1693841561015c5750506001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b5050346100e357806003193601126100e3576101e36109db565b906024356001600160a01b0380821680920361025d577ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f9361023267ffffffffffffffff928754163314610aaa565b16908185526008602052828520816001600160a01b031982541617905582519182526020820152a180f35b8480fd5b919050346101c557602090816003193601126103c057823567ffffffffffffffff811161025d5761029590369085016109f6565b90916102ac6001600160a01b038754163314610aaa565b60059382851c9460069283871161037e5750875b8681106102cb578880f35b80821b81810484148215171561036b576001908183018084116103585780851b9080820487149015171561035857808211610354578781116103545788820135919003858110610344575b5090858310156103315782015561032c90610a88565b6102c0565b634e487b7160e01b8b5260328a5260248bfd5b5f1990860360031b1b165f610316565b8b80fd5b634e487b7160e01b8c5260118b5260248cfd5b634e487b7160e01b8a526011895260248afd5b5162461bcd60e51b8152808801839052601160248201527f65786365656473206d61782074696572730000000000000000000000000000006044820152606490fd5b8380fd5b5050346100e35760203660031901126100e357806020926001600160a01b036103eb610a24565b1681526007845220549051908152f35b5050346100e357816003193601126100e3576001600160a01b0360209254169051908152f35b9050346101c557816003193601126101c55761043b6109db565b9160249182359367ffffffffffffffff948581116108b0576104618691369085016109f6565b9690921692838852602095600887526001600160a01b039384878b2054161561086e57908891868b526008895285888c205416898c8a51928380926322bb937360e11b8252848a8301528888830152816044998a92818a85850137828201840152601f01601f191681010301915afa908115610864578c91610847575b50156108065787519460c08601908111868210176107f4578852888501998886019160a087019180610160116107f0576101408201356080890152610180918183116107e35761016c81013560601c89526101a0918083116107ec578e93820135809452806101c0116107ec576101e0928184116107e7576101d083013560801c9083013560801b178652610200928184116107e75782013560608b0152610220116107e35701358252156107a25780511561076157518b908c5b6006811061073b575b5050156106fa57858551168b5260078952878b20546106b9578886600954169151848a518094819363080cdb0b60e11b83528c8a840152878301525afa9081156106af578b91610682575b501561064157897fb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e60608b8b8b8b8b8b8551828251168a5260078652848a205551169351928251948552840152820152a180f35b865162461bcd60e51b81529283018890526012908301527f736d7420726f6f74206e6f742076616c6964000000000000000000000000000090820152606490fd5b6106a29150893d8b116106a8575b61069a8183610a3a565b810190610a70565b5f6105ed565b503d610690565b88513d8d823e3d90fd5b875162461bcd60e51b81528085018a9052601c818401527f616c72656164792070726f76656420666f72207468697320757365720000000081850152606490fd5b875162461bcd60e51b81528085018a90526013818401527f766b48617368206973206e6f742076616c69640000000000000000000000000081850152606490fd5b6001818101548314610756575061075190610a88565b610599565b925050505f806105a2565b885162461bcd60e51b81528086018b9052601e818501527f766b486173682073686f756c64206265206c6172676572207468616e2030000081860152606490fd5b885162461bcd60e51b81528086018b9052601e818501527f766f6c756d652073686f756c64206265206c6172676572207468616e2030000081860152606490fd5b8e80fd5b508f80fd5b8f80fd5b8d80fd5b634e487b7160e01b8c5260418552828cfd5b875162461bcd60e51b81528085018a9052600f818401527f70726f6f66206e6f742076616c6964000000000000000000000000000000000081850152606490fd5b61085e91508a3d8c116106a85761069a8183610a3a565b5f6104de565b89513d8e823e3d90fd5b865162461bcd60e51b81528084018990526016818401527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b8680fd5b83346109115780600319360112610911578080546001600160a01b03196001600160a01b038216916108e7338414610aaa565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b9050346101c55760203660031901126101c5573560068110156101c55760209250600101549051908152f35b5050346100e357816003193601126100e3576020906001600160a01b03600954169051908152f35b9050346101c55760203660031901126101c557356001600160a01b03908181168091036103c0577fe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042926109c16020938654163314610aaa565b816001600160a01b0319600954161760095551908152a180f35b6004359067ffffffffffffffff821682036109f257565b5f80fd5b9181601f840112156109f25782359167ffffffffffffffff83116109f257602083818601950101116109f257565b600435906001600160a01b03821682036109f257565b90601f8019910116810190811067ffffffffffffffff821117610a5c57604052565b634e487b7160e01b5f52604160045260245ffd5b908160209103126109f2575180151581036109f25790565b5f198114610a965760010190565b634e487b7160e01b5f52601160045260245ffd5b15610ab157565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfea2646970667358221220a24433e5d79194d585cdee87ce7144f843586b5d6f03233c8c887a86473bbda764736f6c63430008140033",
}

// UniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use UniswapSumVolumeMetaData.ABI instead.
var UniswapSumVolumeABI = UniswapSumVolumeMetaData.ABI

// UniswapSumVolumeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UniswapSumVolumeMetaData.Bin instead.
var UniswapSumVolumeBin = UniswapSumVolumeMetaData.Bin

// DeployUniswapSumVolume deploys a new Ethereum contract, binding an instance of UniswapSumVolume to it.
func DeployUniswapSumVolume(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *UniswapSumVolume, error) {
	parsed, err := UniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UniswapSumVolumeBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &UniswapSumVolume{UniswapSumVolumeCaller: UniswapSumVolumeCaller{contract: contract}, UniswapSumVolumeTransactor: UniswapSumVolumeTransactor{contract: contract}, UniswapSumVolumeFilterer: UniswapSumVolumeFilterer{contract: contract}}, nil
}

// UniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type UniswapSumVolume struct {
	UniswapSumVolumeCaller     // Read-only binding to the contract
	UniswapSumVolumeTransactor // Write-only binding to the contract
	UniswapSumVolumeFilterer   // Log filterer for contract events
}

// UniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type UniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UniswapSumVolumeSession struct {
	Contract     *UniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UniswapSumVolumeCallerSession struct {
	Contract *UniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// UniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UniswapSumVolumeTransactorSession struct {
	Contract     *UniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// UniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type UniswapSumVolumeRaw struct {
	Contract *UniswapSumVolume // Generic contract binding to access the raw methods on
}

// UniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UniswapSumVolumeCallerRaw struct {
	Contract *UniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// UniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UniswapSumVolumeTransactorRaw struct {
	Contract *UniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUniswapSumVolume creates a new instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*UniswapSumVolume, error) {
	contract, err := bindUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolume{UniswapSumVolumeCaller: UniswapSumVolumeCaller{contract: contract}, UniswapSumVolumeTransactor: UniswapSumVolumeTransactor{contract: contract}, UniswapSumVolumeFilterer: UniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewUniswapSumVolumeCaller creates a new read-only instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*UniswapSumVolumeCaller, error) {
	contract, err := bindUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeCaller{contract: contract}, nil
}

// NewUniswapSumVolumeTransactor creates a new write-only instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*UniswapSumVolumeTransactor, error) {
	contract, err := bindUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeTransactor{contract: contract}, nil
}

// NewUniswapSumVolumeFilterer creates a new log filterer instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*UniswapSumVolumeFilterer, error) {
	contract, err := bindUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeFilterer{contract: contract}, nil
}

// bindUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UniswapSumVolume.Contract.UniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UniswapSumVolume *UniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UniswapSumVolume *UniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UniswapSumVolume *UniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) BatchTierVkHashes(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "batchTierVkHashes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) BatchTierVkHashes(arg0 *big.Int) (*big.Int, error) {
	return _UniswapSumVolume.Contract.BatchTierVkHashes(&_UniswapSumVolume.CallOpts, arg0)
}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) BatchTierVkHashes(arg0 *big.Int) (*big.Int, error) {
	return _UniswapSumVolume.Contract.BatchTierVkHashes(&_UniswapSumVolume.CallOpts, arg0)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_UniswapSumVolume.CallOpts, swapper)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_UniswapSumVolume.CallOpts, swapper)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) Owner() (common.Address, error) {
	return _UniswapSumVolume.Contract.Owner(&_UniswapSumVolume.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) Owner() (common.Address, error) {
	return _UniswapSumVolume.Contract.Owner(&_UniswapSumVolume.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) SmtContract() (common.Address, error) {
	return _UniswapSumVolume.Contract.SmtContract(&_UniswapSumVolume.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) SmtContract() (common.Address, error) {
	return _UniswapSumVolume.Contract.SmtContract(&_UniswapSumVolume.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _UniswapSumVolume.Contract.VerifierAddresses(&_UniswapSumVolume.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _UniswapSumVolume.Contract.VerifierAddresses(&_UniswapSumVolume.CallOpts, arg0)
}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) Volumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "volumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) Volumes(arg0 common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.Volumes(&_UniswapSumVolume.CallOpts, arg0)
}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) Volumes(arg0 common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.Volumes(&_UniswapSumVolume.CallOpts, arg0)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) RenounceOwnership() (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.RenounceOwnership(&_UniswapSumVolume.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.RenounceOwnership(&_UniswapSumVolume.TransactOpts)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) SetBatchTierVkHashes(opts *bind.TransactOpts, hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "setBatchTierVkHashes", hashes)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) SetBatchTierVkHashes(hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SetBatchTierVkHashes(&_UniswapSumVolume.TransactOpts, hashes)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) SetBatchTierVkHashes(hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SetBatchTierVkHashes(&_UniswapSumVolume.TransactOpts, hashes)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) SubmitUniswapSumVolumeProof(opts *bind.TransactOpts, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "submitUniswapSumVolumeProof", _chainId, _proof)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) SubmitUniswapSumVolumeProof(_chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SubmitUniswapSumVolumeProof(&_UniswapSumVolume.TransactOpts, _chainId, _proof)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) SubmitUniswapSumVolumeProof(_chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SubmitUniswapSumVolumeProof(&_UniswapSumVolume.TransactOpts, _chainId, _proof)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.TransferOwnership(&_UniswapSumVolume.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.TransferOwnership(&_UniswapSumVolume.TransactOpts, newOwner)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateSmtContract(&_UniswapSumVolume.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateSmtContract(&_UniswapSumVolume.TransactOpts, _smtContract)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateVerifierAddress(&_UniswapSumVolume.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateVerifierAddress(&_UniswapSumVolume.TransactOpts, _chainId, _verifierAddress)
}

// UniswapSumVolumeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the UniswapSumVolume contract.
type UniswapSumVolumeOwnershipTransferredIterator struct {
	Event *UniswapSumVolumeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeOwnershipTransferred represents a OwnershipTransferred event raised by the UniswapSumVolume contract.
type UniswapSumVolumeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*UniswapSumVolumeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeOwnershipTransferredIterator{contract: _UniswapSumVolume.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeOwnershipTransferred)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseOwnershipTransferred(log types.Log) (*UniswapSumVolumeOwnershipTransferred, error) {
	event := new(UniswapSumVolumeOwnershipTransferred)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeSumVolumeIterator is returned from FilterSumVolume and is used to iterate over the raw logs and unpacked data for SumVolume events raised by the UniswapSumVolume contract.
type UniswapSumVolumeSumVolumeIterator struct {
	Event *UniswapSumVolumeSumVolume // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeSumVolumeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeSumVolume)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeSumVolume)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeSumVolumeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeSumVolumeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeSumVolume represents a SumVolume event raised by the UniswapSumVolume contract.
type UniswapSumVolumeSumVolume struct {
	User      common.Address
	FromChain uint64
	Volume    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSumVolume is a free log retrieval operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterSumVolume(opts *bind.FilterOpts) (*UniswapSumVolumeSumVolumeIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "SumVolume")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeSumVolumeIterator{contract: _UniswapSumVolume.contract, event: "SumVolume", logs: logs, sub: sub}, nil
}

// WatchSumVolume is a free log subscription operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchSumVolume(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeSumVolume) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "SumVolume")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeSumVolume)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "SumVolume", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSumVolume is a log parse operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseSumVolume(log types.Log) (*UniswapSumVolumeSumVolume, error) {
	event := new(UniswapSumVolumeSumVolume)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "SumVolume", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeUpdateSmtContractIterator is returned from FilterUpdateSmtContract and is used to iterate over the raw logs and unpacked data for UpdateSmtContract events raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateSmtContractIterator struct {
	Event *UniswapSumVolumeUpdateSmtContract // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeUpdateSmtContract)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeUpdateSmtContract)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeUpdateSmtContract represents a UpdateSmtContract event raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateSmtContract struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterUpdateSmtContract is a free log retrieval operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterUpdateSmtContract(opts *bind.FilterOpts) (*UniswapSumVolumeUpdateSmtContractIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "UpdateSmtContract")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeUpdateSmtContractIterator{contract: _UniswapSumVolume.contract, event: "UpdateSmtContract", logs: logs, sub: sub}, nil
}

// WatchUpdateSmtContract is a free log subscription operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchUpdateSmtContract(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeUpdateSmtContract) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "UpdateSmtContract")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeUpdateSmtContract)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateSmtContract", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateSmtContract is a log parse operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseUpdateSmtContract(log types.Log) (*UniswapSumVolumeUpdateSmtContract, error) {
	event := new(UniswapSumVolumeUpdateSmtContract)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateSmtContract", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateVerifierAddressIterator struct {
	Event *UniswapSumVolumeUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*UniswapSumVolumeUpdateVerifierAddressIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeUpdateVerifierAddressIterator{contract: _UniswapSumVolume.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeUpdateVerifierAddress)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseUpdateVerifierAddress(log types.Log) (*UniswapSumVolumeUpdateVerifierAddress, error) {
	event := new(UniswapSumVolumeUpdateVerifierAddress)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UnsafeMathMetaData contains all meta data concerning the UnsafeMath contract.
var UnsafeMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202faab76223831163a8063e80ebcb394ac61469d94440dd9c42a2ec7b799eea3364736f6c63430008140033",
}

// UnsafeMathABI is the input ABI used to generate the binding from.
// Deprecated: Use UnsafeMathMetaData.ABI instead.
var UnsafeMathABI = UnsafeMathMetaData.ABI

// UnsafeMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UnsafeMathMetaData.Bin instead.
var UnsafeMathBin = UnsafeMathMetaData.Bin

// DeployUnsafeMath deploys a new Ethereum contract, binding an instance of UnsafeMath to it.
func DeployUnsafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *UnsafeMath, error) {
	parsed, err := UnsafeMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UnsafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &UnsafeMath{UnsafeMathCaller: UnsafeMathCaller{contract: contract}, UnsafeMathTransactor: UnsafeMathTransactor{contract: contract}, UnsafeMathFilterer: UnsafeMathFilterer{contract: contract}}, nil
}

// UnsafeMath is an auto generated Go binding around an Ethereum contract.
type UnsafeMath struct {
	UnsafeMathCaller     // Read-only binding to the contract
	UnsafeMathTransactor // Write-only binding to the contract
	UnsafeMathFilterer   // Log filterer for contract events
}

// UnsafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type UnsafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UnsafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UnsafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UnsafeMathSession struct {
	Contract     *UnsafeMath       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UnsafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UnsafeMathCallerSession struct {
	Contract *UnsafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// UnsafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UnsafeMathTransactorSession struct {
	Contract     *UnsafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// UnsafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type UnsafeMathRaw struct {
	Contract *UnsafeMath // Generic contract binding to access the raw methods on
}

// UnsafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UnsafeMathCallerRaw struct {
	Contract *UnsafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// UnsafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UnsafeMathTransactorRaw struct {
	Contract *UnsafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUnsafeMath creates a new instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMath(address common.Address, backend bind.ContractBackend) (*UnsafeMath, error) {
	contract, err := bindUnsafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &UnsafeMath{UnsafeMathCaller: UnsafeMathCaller{contract: contract}, UnsafeMathTransactor: UnsafeMathTransactor{contract: contract}, UnsafeMathFilterer: UnsafeMathFilterer{contract: contract}}, nil
}

// NewUnsafeMathCaller creates a new read-only instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathCaller(address common.Address, caller bind.ContractCaller) (*UnsafeMathCaller, error) {
	contract, err := bindUnsafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathCaller{contract: contract}, nil
}

// NewUnsafeMathTransactor creates a new write-only instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*UnsafeMathTransactor, error) {
	contract, err := bindUnsafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathTransactor{contract: contract}, nil
}

// NewUnsafeMathFilterer creates a new log filterer instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*UnsafeMathFilterer, error) {
	contract, err := bindUnsafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathFilterer{contract: contract}, nil
}

// bindUnsafeMath binds a generic wrapper to an already deployed contract.
func bindUnsafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UnsafeMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UnsafeMath *UnsafeMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UnsafeMath.Contract.UnsafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UnsafeMath *UnsafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UnsafeMath.Contract.UnsafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UnsafeMath *UnsafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UnsafeMath.Contract.UnsafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UnsafeMath *UnsafeMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UnsafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UnsafeMath *UnsafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UnsafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UnsafeMath *UnsafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UnsafeMath.Contract.contract.Transact(opts, method, params...)
}

// UtilsMetaData contains all meta data concerning the Utils contract.
var UtilsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220fceb4d7157c65e692404d7914e7fa9cc44b45af9792187a73dd995b53f6bfea664736f6c63430008140033",
}

// UtilsABI is the input ABI used to generate the binding from.
// Deprecated: Use UtilsMetaData.ABI instead.
var UtilsABI = UtilsMetaData.ABI

// UtilsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UtilsMetaData.Bin instead.
var UtilsBin = UtilsMetaData.Bin

// DeployUtils deploys a new Ethereum contract, binding an instance of Utils to it.
func DeployUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Utils, error) {
	parsed, err := UtilsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// Utils is an auto generated Go binding around an Ethereum contract.
type Utils struct {
	UtilsCaller     // Read-only binding to the contract
	UtilsTransactor // Write-only binding to the contract
	UtilsFilterer   // Log filterer for contract events
}

// UtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type UtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UtilsSession struct {
	Contract     *Utils            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UtilsCallerSession struct {
	Contract *UtilsCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// UtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UtilsTransactorSession struct {
	Contract     *UtilsTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type UtilsRaw struct {
	Contract *Utils // Generic contract binding to access the raw methods on
}

// UtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UtilsCallerRaw struct {
	Contract *UtilsCaller // Generic read-only contract binding to access the raw methods on
}

// UtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UtilsTransactorRaw struct {
	Contract *UtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUtils creates a new instance of Utils, bound to a specific deployed contract.
func NewUtils(address common.Address, backend bind.ContractBackend) (*Utils, error) {
	contract, err := bindUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// NewUtilsCaller creates a new read-only instance of Utils, bound to a specific deployed contract.
func NewUtilsCaller(address common.Address, caller bind.ContractCaller) (*UtilsCaller, error) {
	contract, err := bindUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsCaller{contract: contract}, nil
}

// NewUtilsTransactor creates a new write-only instance of Utils, bound to a specific deployed contract.
func NewUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*UtilsTransactor, error) {
	contract, err := bindUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsTransactor{contract: contract}, nil
}

// NewUtilsFilterer creates a new log filterer instance of Utils, bound to a specific deployed contract.
func NewUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*UtilsFilterer, error) {
	contract, err := bindUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UtilsFilterer{contract: contract}, nil
}

// bindUtils binds a generic wrapper to an already deployed contract.
func bindUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UtilsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.UtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transact(opts, method, params...)
}
